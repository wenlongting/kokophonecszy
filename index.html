<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>koko小手机</title>
    <meta name="apple-mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

<meta name="apple-mobile-web-app-title" content="koko">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
@import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700&display=swap');

        :root {
            --theme-primary: #81c784;
            --theme-primary-hover: #66bb6a;
            --theme-secondary: #aed581;
            --sent-message-bg: #e6f5c9;
            --background-start: #f1f8e9;
            --background-end: #ffffff;
            --text-on-primary: #ffffff;
            --text-dark: #424242;
            --text-gray: #757575;
            --soft-red: #ff8a80;
            --border-color: #e8e8e8;
            --shadow-color: rgba(129, 199, 132, 0.12);
            --soft-radius: 16px;
            --card-background: rgba(255, 255, 255, 0.7);
        }
        
       /* --- 您新增的叙事模式美化样式 --- */
.narrative-speech {
    background-color: #e6f5c9; /* 清新的青苹果色背景 (来自您已有的 --sent-message-bg 变量) */
    padding: 2px 8px;
    border-radius: 8px;
    display: inline-block;
    margin: 1px 0;
}

.narrative-psychology {
    text-decoration: none; /* 去掉下划线 */
    background-color: #e6f5c9; /* 浅绿色背景 (复用已有变量 --sent-message-bg) */
    color: #66bb6a; /* 青苹果绿字体 (复用已有变量 --theme-primary-hover) */
    padding: 2px 6px; /* 增加一点内边距，让背景更好看 */
    border-radius: 6px; /* 增加圆角 */
    font-style: normal; /* 也可以加一点斜体来区分 */
}

.narrative-action {
    font-style: normal;
    color: #517655; /* 深一点的青苹果色 (来自您已有的 --theme-primary-hover 变量) */
} 
        
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    /* ↓↓↓ 就是修改这一行 ↓↓↓ */
    font-family: var(--main-font, 'Nunito', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif);
}
        
        body {
            background-image: linear-gradient(to bottom, var(--background-start), var(--background-end));
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #app-container, #screen {
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        
        #screen {
            display: flex;
            flex-direction: column;
            position: relative;
            box-shadow: 0 5px 25px var(--shadow-color);
        }
        
        .chat-header {
    background-color: rgba(129, 199, 132, 0.75);
    backdrop-filter: blur(12px);
    color: var(--text-on-primary);
    padding: 8px 15px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.2);
    display: grid; /* <--- 核心改动1：使用网格布局 */
    grid-template-columns: 1fr auto 1fr; /* <--- 核心改动2：三列布局 */
    align-items: center;
    z-index: 10;
    flex-shrink: 0;
}
/* 新增：修复顶栏右侧按钮的对齐问题 */
.chat-header > div:last-child {
    text-align: right;
}
        .app-header, .world-book-header, .api-header, .moments-header, .discover-header, .contact-settings-header {
            background-color: rgba(220, 237, 200, 0.7);
            backdrop-filter: blur(12px);
            color: var(--text-dark);
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            box-shadow: none;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            z-index: 10;
            flex-shrink: 0;
        }
        
        .chat-input-area {
            background-color: #f8f9fa;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0;
            position: relative;
        }
        
        #message-input {
            flex-grow: 1;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 20px;
            padding: 8px 15px;
            font-size: 15px;
            outline: none;
            resize: none;
            max-height: 100px;
            overflow-y: auto;
            align-self: flex-end;
            min-height: 38px;
        }

        .input-action-btn {
            border: none;
            border-radius: 50%;
            width: 38px;
            height: 38px;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-left: 8px;
            cursor: pointer;
            font-size: 18px;
            flex-shrink: 0;
            transition: transform 0.2s cubic-bezier(0.18, 0.89, 0.32, 1.28);
            align-self: flex-end;
        }
        .input-action-btn:hover {
            transform: scale(1.1);
        }

        #send-btn {
            background-color: var(--theme-primary);
            color: var(--text-on-primary);
            width: auto;
            padding: 0 18px;
            border-radius: 22px;
        }
        #send-btn .fa-paper-plane {
            font-size: 18px;
        }

        #request-reply-btn {
            background-color: var(--theme-secondary);
            color: var(--text-on-primary);
        }
        
        #chat-screen {
            background-image: url('https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
        }
        
        #main-screen { height: 100%; display: flex; flex-direction: column; }
        .app-title { font-size: 20px; font-weight: 700; }
        .contacts-container { flex-grow: 1; overflow-y: auto; padding: 10px 0; }
        .section-title { padding: 10px 15px; font-size: 14px; color: var(--text-gray); background-color: transparent; font-weight: 600; }
        .contact-item { display: flex; align-items: center; padding: 12px 15px; background-color: transparent; border-bottom: 1px solid var(--border-color); border-radius: var(--soft-radius); margin: 0 8px 4px; cursor: pointer; transition: background-color 0.2s; }
        .contact-item:hover { background-color: rgba(255, 255, 255, 0.7); }
        .contact-avatar { width: 50px; height: 50px; border-radius: 50%; background-color: #ddd; margin-right: 15px; display: flex; align-items: center; justify-content: center; font-size: 20px; color: var(--text-gray); overflow: hidden; flex-shrink: 0; }
        .contact-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .contact-info { flex-grow: 1; min-width: 0; }
        .contact-name { font-weight: 600; margin-bottom: 3px; color: var(--text-dark); }
        .contact-last-message { font-size: 14px; color: var(--text-gray); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 100%; }
        .contact-time { font-size: 12px; color: #999; margin-top: 5px; }
        .unread-count { background-color: var(--theme-primary); color: var(--text-on-primary); font-size: 12px; width: 20px; height: 20px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin-left: 10px; }
        .bottom-nav { display: flex; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(10px); border-top: 1px solid var(--border-color); padding: 10px 0; flex-shrink: 0; }
        .nav-item { flex: 1; text-align: center; color: var(--text-gray); font-size: 14px; cursor: pointer; transition: color 0.2s, transform 0.2s; }
        .nav-item-content { position: relative; display: inline-block; }
        .nav-item.active { color: var(--theme-primary); transform: scale(1.1); }
        .nav-icon { font-size: 20px; margin-bottom: 5px; }
        .notification-dot { position: absolute; top: -2px; right: -8px; width: 8px; height: 8px; background-color: var(--soft-red); border-radius: 50%; border: 1px solid white; display: none; }
        .back-btn { font-size: 24px; cursor: pointer; margin-right: 15px; }
        .chat-info { flex-grow: 1; text-align: center; }
        .chat-name { font-weight: 700; font-size: 18px; }
        .chat-status { font-size: 13px; opacity: 0.8; }
        .chat-messages { flex-grow: 1; padding: 15px; overflow-y: auto; display: flex; flex-direction: column; }
        #load-more-messages { background-color: #e0e0e0; color: #555; border: none; padding: 8px 15px; border-radius: 15px; cursor: pointer; margin: 0 auto 15px; font-size: 13px; display: none; }
        #load-more-messages:hover { background-color: #d1d1d1; }
        .message-wrapper { display: flex; max-width: 85%; margin-bottom: 2px; position: relative; }
        .message-wrapper.received { align-self: flex-start; flex-direction: row; }
        .message-wrapper.sent { align-self: flex-end; flex-direction: row-reverse; }
        .message-avatar { width: 40px; height: 40px; border-radius: 6px; flex-shrink: 0; visibility: hidden; }
        .is-first-in-sequence .message-avatar { visibility: visible; margin-top: 10px; }
        .message-avatar img { width: 100%; height: 100%; border-radius: 6px; object-fit: cover; }
        .message-body { display: flex; flex-direction: column; margin: 0 10px; }
        .message-wrapper.sent .message-body { align-items: flex-end; }
        .message-wrapper.received .message-body { align-items: flex-start; }
        .message-author-name { font-size: 13px; color: #888; margin-bottom: 4px; display: none; }
        .is-first-in-sequence .message-author-name { display: block; margin-top: 10px;}
        .message { padding: 10px 18px; border-radius: 22px; position: relative; animation: fadeIn 0.3s ease; word-wrap: break-word; min-width: 50px; box-shadow: 0 2px 4px var(--shadow-color); font-size: 14px;}
        .message-timestamp { font-size: 11px; color: #aaa; margin-top: 4px; padding: 0 5px; }
        .message-wrapper.selected .message, .message-wrapper.selected .message.red-packet, .message-wrapper.selected .message.voice, .message-wrapper.selected .message.picture-description { background-color: #bde0fe !important; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .message.received { background-color: white; border-top-left-radius: 4px; }
        .message.sent { background-color: var(--sent-message-bg); border-top-right-radius: 4px; }
        .message-image-container { padding: 5px; background-color: inherit; border-radius: inherit; }
        .message-image { max-width: 150px; max-height: 150px; border-radius: 12px; display: block; cursor: default; }
        .message-image-container.sent { border-top-right-radius: 4px; }
        .message-image-container.received { border-top-left-radius: 4px; }
        .message.image-message { padding: 0; background-color: transparent; box-shadow: none; }
        .emoji-btn, .attachment-btn { font-size: 22px; margin-right: 10px; cursor: pointer; color: var(--text-gray); align-self: flex-end; margin-bottom: 10px; }
        .attachment-btn { background: none; border: none; padding: 0; }
        #edit-mode-bar, #moments-edit-mode-bar { display: none; padding: 10px 15px; background-color: #f0f0f0; border-top: 1px solid #ddd; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .edit-action-btn { padding: 8px 16px; border-radius: 20px; border: none; font-size: 14px; cursor: pointer; }
        #delete-selected-btn, #delete-selected-moments-btn { background-color: var(--soft-red); color: white; }
        #cancel-edit-btn, #cancel-moments-edit-btn { background-color: #bdc3c7; color: #333; }
        #profile-screen, #char-profile-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; display: none; flex-direction: column; }
        
        .profile-header {
            background-image: linear-gradient(135deg, var(--sent-message-bg), #dcedc8);
            padding: 30px 20px 15px;
            text-align: center;
            color: var(--text-dark);
            position: relative;
            flex-shrink: 0;
        }
        .avatar-container {
            position: relative;
            margin: 0 auto 15px;
            width: 100px;
            height: 100px;
        }
        .profile-avatar {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            object-fit: cover;
            border: 3px solid white;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
        }
        .change-avatar-btn {
            position: absolute;
            bottom: 0;
            right: 0;
            background-color: rgba(255, 255, 255, 0.7);
            color: var(--text-dark);
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            border: 1px solid rgba(0, 0, 0, 0.05);
        }

        .profile-name { font-size: 22px; font-weight: 700; margin-bottom: 5px; }
        .profile-status { font-size: 16px; opacity: 0.9; }
        .profile-actions { display: flex; justify-content: center; gap: 20px; padding: 10px 0; background-color: white; border-bottom: 1px solid #eee; flex-shrink: 0; }
        .action-item { text-align: center; cursor: pointer; }
        .action-icon { width: 50px; height: 50px; border-radius: 50%; background-color: #f0f2f5; display: flex; align-items: center; justify-content: center; font-size: 24px; color: var(--theme-primary); margin: 0 auto 10px; transition: all 0.3s; }
        .action-icon:hover { background-color: #e0f2f1; transform: scale(1.05); }
        .action-label { font-size: 14px; color: var(--text-gray); }
        .profile-details { flex-grow: 1; overflow-y: auto; padding: 10px; background-color: #f0f2f5; }
        .detail-item { padding: 15px; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center; cursor: pointer; background-color: white; }
        .detail-item:last-child { border-bottom: none; }
        .discover-section .detail-item { border-radius: 0; margin-bottom: 0; }
        .discover-section .detail-item:first-child { border-top-left-radius: var(--soft-radius); border-top-right-radius: var(--soft-radius); }
        .discover-section .detail-item:last-child { border-bottom-left-radius: var(--soft-radius); border-bottom-right-radius: var(--soft-radius); border-bottom: none; }
        .detail-label { font-size: 16px; color: #333; font-weight: 600; }
        .detail-value { font-size: 16px; color: var(--text-gray); max-width: 60%; text-align: right; overflow: hidden; text-overflow: ellipsis; }
        .edit-btn { color: var(--theme-primary); font-size: 18px; cursor: pointer; padding: 5px; }
        #discover-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: transparent; display: none; flex-direction: column; }
        .discover-title { font-size: 20px; font-weight: 700; flex-grow: 1; text-align: center; margin-left: 0; }
        .discover-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .discover-section { background-color: var(--card-background); border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px;}
        .discover-item { padding: 15px; display: flex; align-items: center; border-bottom: 1px solid var(--border-color); cursor: pointer; transition: background-color 0.2s; background-color: transparent; }
        .discover-item:last-child { border-bottom: none; }
        .discover-item:hover { background-color: rgba(255,255,255,0.5); }
        .discover-icon { width: 40px; height: 40px; border-radius: 8px; background-color: #f0f2f5; display: flex; align-items: center; justify-content: center; font-size: 20px; color: var(--theme-primary); margin-right: 15px; }
        .discover-info { flex-grow: 1; }
        .discover-name { font-weight: 600; margin-bottom: 3px; }
        .discover-desc { font-size: 14px; color: var(--text-gray); }
        .discover-arrow { color: #999; font-size: 18px; }
/* ▼▼▼ 使用这个新版本替换上面的旧规则 ▼▼▼ */
#automation-modal, #automation-screen, #world-book-screen, #api-settings-screen, #contact-settings-screen, #moments-screen, #diary-screen, #emoticon-library-screen, .preset-management-screen, #post-detail-screen, #trending-topic-screen, #square-api-settings-screen, #memory-album-screen, #music-library-screen, #shopping-screen, #product-detail-screen, 
#schedule-screen, #events-screen,
#relationship-network-screen /* <--- 在这里加上我们新页面的ID */ {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: transparent;
    display: none;
    flex-direction: column;
}
        .world-book-content, .api-content, .contact-settings-content, .emoticon-library-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .world-book-list { display: flex; flex-direction: column; gap: 15px; }
        .world-book-item { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px; cursor: pointer; transition: transform 0.2s ease, box-shadow 0.2s ease;}
        .world-book-item:hover { transform: translateY(-3px); box-shadow: 0 6px 12px var(--shadow-color); }
        .book-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid #f0f0f0; }
        .book-name { font-weight: 600; font-size: 18px; }
        .book-content { color: var(--text-gray); line-height: 1.5; white-space: pre-wrap; word-break: break-all; }
        .api-title { font-size: 20px; font-weight: 600; margin-left: 15px; }
        .form-group { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .form-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .form-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
        .form-input:focus { outline: none; border-color: var(--theme-primary); }
        .form-button { width: 100%; padding: 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; margin-top: 10px; }
        .form-group-inline { display: flex; align-items: center; gap: 10px; }
        .form-group-inline .form-input { flex-grow: 1; }
        #fetch-models-btn, #fetch-square-models-btn { padding: 10px 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; flex-shrink: 0; }
        #add-world-book-modal, #post-moment-modal, #user-persona-preset-modal, #thought-preset-modal, #add-emoticon-modal, #automation-modal, #send-red-packet-modal, #send-transfer-modal, #send-voice-modal, #send-picture-modal, #add-music-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background-color: white; width: 90%; max-width: 400px; border-radius: var(--soft-radius); overflow: hidden; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2); animation: modalIn 0.3s ease; }
        @keyframes modalIn { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        .modal-header { background-color: var(--theme-primary); color: white; padding: 15px; display: flex; justify-content: space-between; align-items: center; }
        .modal-title { font-size: 18px; font-weight: 600; }
        .close-btn { font-size: 24px; cursor: pointer; }
        .modal-body { padding: 20px; }
        .form-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .form-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .form-button:hover { background-color: var(--theme-primary-hover); }
        #add-contact-modal { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.5); display: none; justify-content: center; align-items: center; z-index: 100; }
        .contact-form-group { margin-bottom: 20px; }
        .contact-form-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .contact-form-input { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; }
        .contact-form-input:focus { outline: none; border-color: var(--theme-primary); }
        .contact-form-textarea { width: 100%; height: 100px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .contact-form-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .contact-form-select { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; background-color: white; }
        .contact-form-select:focus { outline: none; border-color: var(--theme-primary); }
        .mask-editor, .world-book-selector { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .mask-editor-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .mask-editor-group { margin-bottom: 15px; }
        .mask-editor-label { display: block; margin-bottom: 8px; font-weight: 500; color: var(--text-gray); }
        .mask-editor-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .mask-editor-textarea:focus { outline: none; border-color: var(--theme-primary); }
        .world-book-selector-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .world-book-selector .world-book-list { max-height: 200px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px; }
        #world-book-selector-list .world-book-item { padding: 10px; border-bottom: 1px solid #f0f0f0; display: flex; align-items: center; }
        .world-book-checkbox { margin-right: 10px; }
        .world-book-name { font-weight: 500; }
        .save-settings-btn { width: 100%; padding: 15px; background-color: var(--theme-primary); color: white; border: none; border-radius: 8px; font-size: 16px; font-weight: 600; cursor: pointer; }
        .user-mask-editor { background-color: white; border-radius: var(--soft-radius); box-shadow: 0 4px 12px var(--shadow-color); border: 1px solid white; margin-bottom: 20px; padding: 15px;}
        .user-mask-title { font-size: 18px; font-weight: 600; margin-bottom: 15px; color: var(--theme-primary); }
        .user-mask-textarea { width: 100%; height: 150px; padding: 12px; border: 1px solid #ddd; border-radius: 8px; font-size: 16px; resize: vertical; }
        .user-mask-textarea:focus { outline: none; border-color: var(--theme-primary); }
        
        /* --- V7.0 新增: 一起听歌卡片样式 --- */
.message.music-share-card {
    background-color: #f3f4f6;
    color: #333;
    width: 260px;
    padding: 12px;
    display: flex;
    align-items: center;
    gap: 12px;
    cursor: default;
    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.message.sent.music-share-card { background-color: var(--sent-message-bg); }
.music-card-cover {
    width: 60px;
    height: 60px;
    background-color: #555;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 28px;
    flex-shrink: 0;
    position: relative;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    animation: spin 8s linear infinite;
    animation-play-state: paused; /* 默认暂停 */
}
.music-card-cover.playing {
    animation-play-state: running; /* 播放时旋转 */
}
@keyframes spin {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}
.music-card-play-btn {
    position: absolute;
    color: rgba(255, 255, 255, 0.8);
    font-size: 20px;
    cursor: pointer;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
}
.music-card-info {
    flex-grow: 1;
    min-width: 0;
}
.music-card-title {
    font-weight: 600;
    font-size: 15px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}
.music-card-artist {
    font-size: 13px;
    color: var(--text-gray);
    margin-top: 2px;
}
.music-card-progress-bar {
    width: 100%;
    height: 3px;
    background-color: #ddd;
    border-radius: 3px;
    margin-top: 8px;
    overflow: hidden;
}
.music-card-progress {
    width: 0%;
    height: 100%;
    background-color: var(--theme-primary);
}
.music-card-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    color: #999;
    margin-top: 5px;
}
.music-card-loop-btn {
    cursor: pointer;
    font-size: 14px;
}
/* --- V7.0 新增: 小窝相册新样式 --- */
.album-section {
    background-color: white;
    border-radius: 12px;
    padding: 15px 20px;
    margin-bottom: 20px;
    box-shadow: 0 4px 12px var(--shadow-color);
}
.album-section-title {
    font-size: 18px;
    font-weight: bold;
    color: var(--theme-primary);
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 1px solid #f0f0f0;
}
.album-milestone-item, .album-stat-item {
    display: flex;
    align-items: center;
    padding: 10px 0;
    font-size: 16px;
}
.album-item-icon {
    width: 30px;
    text-align: center;
    margin-right: 15px;
    color: var(--text-gray);
}
.album-item-label { color: #333; }
.album-item-value {
    margin-left: auto;
    font-weight: 600;
    color: var(--text-dark);
}
.album-memory-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 10px;
}
.album-memory-item {
    background-color: #f9f9f9;
    border-radius: 8px;
    padding: 10px;
    font-size: 14px;
    line-height: 1.5;
    border: 1px solid #eee;
    cursor: pointer;
}
.album-memory-item .fas {
    margin-right: 5px;
    color: var(--theme-secondary);
}
        
        /* ---论坛/微博 样式--- */
        .moments-header .back-btn { font-size: 24px; cursor: pointer; position: relative; z-index: 1; }
        .moments-header .action-btn { font-size: 20px; }
        .header-actions { display: flex; gap: 20px; position: relative; z-index: 1; }
        .moments-content { flex-grow: 1; overflow-y: auto; background-color: #f0f2f5; }
        .mention {
    color: var(--theme-primary);
    font-weight: 600;
    cursor: pointer;
}
.mention:hover {
    text-decoration: underline;
}
/* --- 新代码：模仿Koko论坛(1)的主导航栏样式 --- */
.feed-tabs {
    display: flex;
    justify-content: space-around;
    padding: 10px 0;          /* 增加上下内边距 */
    background-color: #ffffff; /* 背景改为白色 */
    border-bottom: 1px solid #e0e0e0; /* 添加底部边框线 */
    flex-shrink: 0;
}

.feed-tab-btn {
    text-decoration: none;
    color: #888;              /* 默认文字颜色改为灰色 */
    font-size: 16px;
    font-weight: 500;         /* 字体粗细调整 */
    padding: 10px 15px;       /* 修改内边距，为胶囊形状做准备 */
    border-radius: 20px;      /* 添加圆角 */
    border: none;
    background: none;
    cursor: pointer;
    /* 为背景和颜色变化添加过渡效果 */
    transition: background-color 0.3s, color 0.3s;
}

/* 新增：为图标和文字之间添加一点间距 */
.feed-tab-btn .fas {
    margin-right: 5px;
}

.feed-tab-btn.active {
    color: #000;              /* 激活时文字改为黑色 */
    font-weight: bold;         /* 激活时文字加粗 */
    background-color: #e9ecef; /* 激活时背景改为淡灰色，形成胶囊效果 */
}

/* 关键：删除或确保没有 .feed-tab-btn.active::after 规则，去掉下划线 */
.feed-tab-btn.active::after {
    display: none;
}

        .feed-sub-tabs { display: flex; justify-content: center; gap: 15px; padding: 8px 10px; background-color: #fafafa; flex-shrink: 0; border-bottom: 1px solid #eee; }
/* --- 新代码：模仿Koko论坛(1)的黑白胶囊按钮风格 --- */
.feed-sub-tab-btn {
    padding: 8px 16px;      /* 稍微增大一点内边距，让按钮更大方 */
    font-size: 14px;
    font-weight: 500;
    color: #555;            /* 默认文字颜色改为深灰色 */
    border: 1px solid #ddd; /* 保留一个细边框 */
    background-color: #fff; /* 默认背景为白色 */
    border-radius: 20px;    /* 圆角更圆润 */
    cursor: pointer;
    transition: all 0.3s;
    white-space: nowrap;    /* 防止文字换行 */
}

.feed-sub-tab-btn.active {
    color: #fff;            /* 激活时文字为白色 */
    background-color: #000;  /* 激活时背景为黑色 */
    border-color: #000;      /* 激活时边框也为黑色 */
    font-weight: bold;       /* 激活时文字加粗 */
}

        .posts-list { padding: 10px; display: flex; flex-direction: column; gap: 10px; }
/* --- 新代码：模仿Koko论坛(1)的精致卡片和悬浮效果 --- */
.post-item {
    position: relative;
    display: flex;
    padding: 20px;          /* 增大内边距，让内容更舒展 */
    gap: 15px;              /* 稍微增大头像和内容的间距 */
    background-color: white;
    border-radius: 12px;    /* 调整圆角大小 */
    border: 1px solid #e0e0e0; /* 增加一个非常淡的边框，提升质感 */
    box-shadow: 0 2px 8px rgba(0,0,0,0.06); /* 调整一个更柔和的阴影 */
    cursor: pointer;
    /* 核心动效：为阴影和位移添加过渡效果 */
    transition: box-shadow 0.3s, transform 0.2s;
}

/* 核心动效：添加鼠标悬浮时的样式 */
.post-item:hover {
    transform: translateY(-3px); /* 向上移动3像素，产生上浮感 */
    box-shadow: 0 4px 12px rgba(0,0,0,0.1); /* 阴影变得更深更明显 */
}
        .post-delete-btn { position: absolute; top: 10px; right: 10px; width: 28px; height: 28px; background-color: rgba(255, 255, 255, 0.8); backdrop-filter: blur(5px); border-radius: 50%; display: flex; align-items: center; justify-content: center; color: var(--text-gray); font-size: 14px; cursor: pointer; z-index: 2; transition: all 0.2s; }
        .post-delete-btn:hover { background-color: var(--soft-red); color: white; }

        .post-item-avatar img { width: 45px; height: 45px; border-radius: 50%; flex-shrink: 0; }
        .post-content-area { flex-grow: 1; display: flex; flex-direction: column; gap: 8px; min-width: 0; }
        .post-author-name { font-weight: 700; color: var(--text-dark); }
        .post-author-handle { font-size: 14px; color: var(--text-gray); margin-left: 8px; }
        .post-text { line-height: 1.6; white-space: pre-wrap; word-wrap: break-word; font-size: 15px; }
        .post-meta { color: #999; font-size: 13px; }
        .post-actions { display: flex; justify-content: space-between; align-items: center; color: var(--text-gray); font-size: 14px; margin-top: 12px; padding-top: 8px; border-top: 1px solid #f0f0f0; }
        .post-action-btn { cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s; }
/* --- 新代码：将交互颜色改为更中性的深灰色或黑色 --- */
.post-action-btn {
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    color: #888; /* 将默认图标颜色改为灰色 */
    transition: color 0.2s;
}
.post-action-btn:hover, .post-action-btn.liked {
    color: #000; /* 悬浮和点赞后的颜色改为黑色 */
}
        .post-action-btn.liked .fa-heart { font-weight: 900; }
        .post-action-btn i { font-size: 16px; }

        .post-comments { background-color: #f7f9f9; border-radius: 10px; padding: 10px; font-size: 14px; display: flex; flex-direction: column; gap: 8px; margin-top: 5px; }
        .post-comments:empty { display: none; }
        
        .comment-delete-btn { color: var(--text-gray); font-size: 12px; cursor: pointer; opacity: 0; transition: all 0.2s; }
        .comment-delete-btn:hover { color: var(--soft-red); }
        .post-comment-item:hover .comment-delete-btn { opacity: 1; }

        .post-comment-item { line-height: 1.5; padding: 8px 0; border-bottom: 1px solid #eee; }
        .post-comment-item:last-child { border-bottom: none; }
        .comment-author { font-weight: 600; color: var(--theme-primary); margin-right: 5px; cursor: pointer; }
        .comment-content { color: var(--text-dark); }
        .comment-meta { display: flex; justify-content: space-between; align-items: center; font-size: 12px; color: var(--text-gray); margin-top: 4px; }
        .comment-reply-to { background-color: #e9e9e9; padding: 4px 8px; border-radius: 8px; font-size: 13px; margin-left: 5px; }
        /* --- 新增：用于在帖子中显示作者签名 --- */
.post-author-signature {
    font-size: 13px;
    color: var(--text-gray);
    margin-top: 4px; /* 与昵称拉开一点距离 */
    padding-bottom: 8px; /* 与帖子正文拉开一点距离 */
    white-space: pre-wrap; /* 允许签名中的换行 */
    word-break: break-word;
}


        /* 热搜榜样式 */
        .trending-list { list-style: none; padding: 10px; background-color: white;}
        .trending-item { display: flex; align-items: center; padding: 15px; border-bottom: 1px solid #f0f0f0; cursor: pointer; }
        .trending-item:hover { background-color: #f9f9f9; }
        .trending-item:last-child { border-bottom: none; }
        .trending-rank { font-size: 18px; font-weight: bold; color: var(--text-gray); width: 40px; text-align: center; }
        .trending-rank.top-3 { color: var(--soft-red); }
        .trending-info { flex-grow: 1; }
        .trending-title { font-size: 16px; font-weight: 600; color: var(--text-dark); margin-bottom: 4px; }
        .trending-meta { font-size: 13px; color: var(--text-gray); }
        .trending-tag { background-color: #ffcdd2; color: #c62828; font-size: 11px; padding: 2px 6px; border-radius: 5px; margin-left: 8px; font-weight: bold; }
        
        #post-detail-screen { background-color: #f0f2f5; }
        .post-detail-content { flex-grow: 1; overflow-y: auto; }
        #post-detail-container { padding: 0; }
        #post-detail-container .post-item { cursor: default; }
        .comments-section { padding: 15px; background-color: #f0f2f5; }
        .comments-title { font-size: 16px; font-weight: 700; color: var(--text-dark); padding-bottom: 10px; border-bottom: 1px solid #ddd; margin-bottom: 10px; }
        .comment-input-area { display: flex; padding: 10px 15px; background-color: white; border-top: 1px solid #ddd; flex-shrink: 0; }
        #comment-input { flex-grow: 1; border: 1px solid #ddd; border-radius: 18px; padding: 8px 15px; font-size: 15px; resize: none; }
        #submit-comment-btn { background-color: var(--theme-primary); color: white; border: none; border-radius: 18px; padding: 8px 20px; margin-left: 10px; font-weight: 600; cursor: pointer; }
        
        .diary-entry {
            position: relative;
            background-color: white;
            border-radius: 12px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 12px var(--shadow-color);
        }
        
        .diary-content { flex-grow: 1; overflow-y: auto; padding: 20px; }
        .diary-entry-meta { font-size: 12px; color: #999; margin-bottom: 10px; }
        .diary-entry-content { font-size: 16px; line-height: 1.6; color: #333; }
        .diary-delete-btn { position: absolute; top: 15px; right: 15px; font-size: 18px; color: #aaa; cursor: pointer; transition: color 0.2s ease; }
        .diary-delete-btn:hover { color: var(--soft-red); }
        .preset-list { display: flex; flex-direction: column; gap: 10px; padding: 15px 20px; }
        .preset-item { background-color: white; border-radius: 12px; padding: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); display: flex; justify-content: space-between; align-items: center; }
        .preset-info { flex-grow: 1; cursor: pointer; min-width: 0; margin-right: 10px; }
        .preset-name { font-weight: 500; font-size: 16px; color: #333; margin-bottom: 5px; }
        .preset-desc { font-size: 13px; color: var(--text-gray); overflow: hidden; text-overflow: ellipsis; white-space: pre-wrap; display: -webkit-box; -webkit-line-clamp: 3; -webkit-box-orient: vertical; }
        .preset-actions { display: flex; gap: 10px; flex-shrink: 0; }
        .preset-action-btn { font-size: 18px; color: #999; cursor: pointer; padding: 5px; }
        .preset-action-btn:hover { color: var(--theme-primary); }
        .preset-action-btn.delete:hover { color: var(--soft-red); }
        /* ▼▼▼ 把这段新代码粘贴进去 ▼▼▼ */
.preset-action-btn.active {
    color: var(--theme-primary); /* 使用主题绿色作为激活颜色 */
}
        .emoticon-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 15px; }
        .emoticon-item { background-color: #fff; border-radius: 8px; padding: 8px; box-shadow: 0 1px 3px var(--shadow-color); position: relative; display: flex; flex-direction: column; align-items: center; justify-content: space-between; }
        .emoticon-item img { max-width: 100%; height: 60px; object-fit: contain; margin-bottom: 5px; }
        .emoticon-name { font-size: 12px; color: #333; text-align: center; word-break: break-all; }
        .emoticon-delete-btn { position: absolute; top: -5px; right: -5px; background-color: var(--soft-red); color: white; width: 20px; height: 20px; border-radius: 50%; border: none; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 12px; line-height: 20px; box-shadow: 0 1px 2px rgba(0,0,0,0.2); }
        #emoticon-picker { position: absolute; bottom: 65px; left: 10px; right: 10px; background-color: #fff; border: 1px solid #ddd; border-radius: 10px; box-shadow: 0 -2px 10px rgba(0,0,0,0.1); max-height: 250px; overflow-y: auto; padding: 10px; display: none; z-index: 50; grid-template-columns: repeat(auto-fill, minmax(60px, 1fr)); gap: 10px; }
        #emoticon-picker.active { display: grid; }
        #emoticon-picker .emoticon-item { cursor: pointer; transition: transform 0.2s; }
        #emoticon-picker .emoticon-item:hover { transform: scale(1.1); }
        #emoticon-picker .emoticon-delete-btn { display: none; }
        
        /* --- 音乐库新增样式 --- */
        #music-library-list { display: flex; flex-direction: column; gap: 10px; }
        .music-item { background-color: white; border-radius: 8px; padding: 12px 15px; display: flex; align-items: center; justify-content: space-between; box-shadow: 0 1px 3px var(--shadow-color); }
        .music-info { flex-grow: 1; }
        .music-title { font-weight: 600; color: #333; }
        .music-artist { font-size: 14px; color: var(--text-gray); margin-top: 3px; }
        .music-delete-btn { background: none; border: none; font-size: 16px; color: #aaa; cursor: pointer; padding: 5px; }
        .music-delete-btn:hover { color: var(--soft-red); }
        #music-library-picker .picker-title { font-weight: 600; color: var(--text-gray); margin-bottom: 8px; border-bottom: 1px solid #eee; padding-bottom: 8px; }
        #music-library-picker .picker-list { max-height: 120px; overflow-y: auto; }
        #music-library-picker .picker-item { padding: 8px 5px; cursor: pointer; border-radius: 4px; }
        #music-library-picker .picker-item:hover { background-color: #f0f0f0; }

        #feed-status-indicator {
            padding: 10px;
            text-align: center;
            background-color: #e8f5e9;
            color: var(--text-gray);
            font-size: 14px;
            display: none;
            border-bottom: 1px solid var(--border-color);
            flex-shrink: 0;
            order: 1; /* 确保它在header下面 */
        }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: var(--theme-primary); }
        input:focus + .slider { box-shadow: 0 0 1px var(--theme-primary); }
        input:checked + .slider:before { transform: translateX(22px); }
        .slider.round { border-radius: 28px; }
        .slider.round:before { border-radius: 50%; }
        #attachment-menu { position: absolute; bottom: 65px; left: 10px; right: 10px; background-color: #f9f9f9; border: 1px solid #ddd; border-radius: 12px; box-shadow: 0 -4px 15px rgba(0,0,0,0.1); padding: 15px; display: none; grid-template-columns: repeat(4, 1fr); gap: 15px; z-index: 50; transition: opacity 0.2s ease, transform 0.2s ease; transform: translateY(10px); opacity: 0; }
        #attachment-menu.active { display: grid; transform: translateY(0); opacity: 1; }
        .attachment-menu-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; text-align: center; }
        .attachment-menu-item .icon-wrapper { width: 60px; height: 60px; background-color: white; border-radius: 12px; display: flex; align-items: center; justify-content: center; font-size: 28px; color: #555; margin-bottom: 8px; border: 1px solid #eee; }
        .attachment-menu-item .label { font-size: 13px; color: var(--text-gray); }
        .attachment-menu-item:hover .icon-wrapper { background-color: #f0f0f0; }
        .system-notification { align-self: center; background-color: #e1e1e1; color: var(--text-gray); font-size: 12px; padding: 5px 12px; border-radius: 15px; margin: 10px 0; text-align: center; }
        .message.picture-description { display: flex; align-items: center; cursor: pointer; }
        .message.sent.picture-description { background-color: var(--sent-message-bg); }
        .message.received.picture-description { background-color: #fff; }
        .message.picture-description i { font-size: 20px; color: var(--text-gray); margin-right: 10px; }
        .message.picture-description span { color: #333; }
        .message.voice { display: flex; align-items: center; justify-content: space-between; cursor: pointer; }
        .message.voice .fa-wifi { font-size: 20px; transform: rotate(90deg); color: var(--text-gray); }
        .message.sent.voice { background-color: var(--sent-message-bg); }
        .message.received.voice { background-color: #fff; }
        .message.sent.voice .fa-wifi { order: 2; margin-left: 15px; }
        .message.received.voice .fa-wifi { margin-right: 15px; }
        .voice-duration { color: var(--text-gray); }
        .transcribed-text { background-color: #fff; border: 1px solid #eee; padding: 10px; border-radius: 8px; margin-top: 5px; font-size: 14px; color: #333; max-height: 0; opacity: 0; overflow: hidden; transition: max-height 0.3s ease-out, opacity 0.3s ease-out, margin-top 0.3s ease-out; }
        .transcribed-text.visible { max-height: 200px; opacity: 1; }
        .message.red-packet { background-color: #FFCC80; color: #5D4037; width: 240px; padding: 0; overflow: hidden; cursor: pointer; transition: background-color 0.3s, box-shadow 0.3s; box-shadow: 0 2px 5px rgba(255, 152, 0, 0.2); }
        .message.red-packet.opened { background-color: #FFF3E0; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05); }
        .message.red-packet .red-packet-header { padding: 10px 15px; display: flex; align-items: center; }
        .message.red-packet .red-packet-icon { font-size: 24px; margin-right: 10px; color: #FFA726; }
        .message.red-packet .red-packet-blessing { font-size: 15px; flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: 500; }
        .message.red-packet .red-packet-status { font-size: 13px; opacity: 0.9; }
        .message.red-packet.opened .red-packet-icon, .message.red-packet.opened .red-packet-blessing, .message.red-packet.opened .red-packet-status { color: #BCAAA4; }
        .message.red-packet .red-packet-footer { background-color: transparent; color: #A1887F; font-size: 12px; padding: 5px 15px; border-top: 1px solid rgba(161, 136, 127, 0.2); }
        .message.red-packet.opened .red-packet-footer { color: #cebeba; border-top: 1px solid rgba(161, 136, 127, 0.1); }
        .message.sent.red-packet { border-top-right-radius: 0; }
        .message.received.red-packet { border-top-left-radius: 0; }
        .message.transfer { background-color: var(--theme-primary); color: white; width: 240px; padding: 0; overflow: hidden; position: relative; box-shadow: 0 2px 5px var(--shadow-color); }
        .message.transfer.completed { background-color: #C8E6C9; }
        .message.transfer.completed .transfer-info .transfer-text, .message.transfer.completed .transfer-info .transfer-amount { color: #388E3C; }
        .message.transfer.completed .transfer-icon i { color: var(--theme-primary-hover); }
        .message.transfer.completed::after { content: '\f00c'; font-family: 'Font Awesome 6 Free'; font-weight: 900; position: absolute; right: 15px; top: 50%; transform: translateY(-50%); font-size: 18px; color: var(--theme-primary-hover); }
        .message.transfer .transfer-header { padding: 10px 15px; display: flex; align-items: center; }
        .message.transfer .transfer-icon { font-size: 24px; margin-right: 10px; }
        .message.transfer .transfer-info .transfer-text { font-size: 15px; font-weight: 500; }
        .message.transfer .transfer-info .transfer-amount { font-size: 18px; font-weight: bold; }
        .message.transfer .transfer-footer { background-color: transparent; color: white; font-size: 12px; padding: 5px 15px; border-top: 1px solid rgba(255,255,255,0.3); opacity: 0.9; }
        .message.transfer.completed .transfer-footer { color: var(--theme-primary-hover); border-top: 1px solid rgba(102, 187, 106, 0.2); }
        .message.sent.transfer { border-top-right-radius: 0; }
        .message.received.transfer { border-top-left-radius: 0; }

        /* --- Pet Game Styles --- */
        #pet-container {
            background-color: white;
            border-radius: 10px;
            padding: 15px;
            margin-top: 20px;
        }
        .pet-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
        }
        #pet-name {
            color: var(--text-dark);
        }
        #pet-gold-display {
            font-size: 16px;
            color: #E6A23C;
        }
        .pet-visual-area {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            margin-bottom: 15px;
        }
        .pet-stats {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
        }
        .stat-bar-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .stat-bar-label {
            width: 60px;
            text-align: right;
        }
        .stat-bar {
            flex-grow: 1;
            height: 10px;
            background-color: #eee;
            border-radius: 5px;
            overflow: hidden;
        }
        .stat-bar-inner {
            height: 100%;
            width: 100%;
            border-radius: 5px;
            background-color: var(--theme-primary);
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        .pet-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .pet-action-btn {
            padding: 10px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #f0f2f5;
            color: var(--text-dark);
        }
        .pet-action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .pet-action-btn:disabled {
            background-color: #e9ecef;
            color: #adb5bd;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        #work-pet-btn {
            background-color: var(--theme-secondary);
            color: white;
        }
        
        .slime {
    width: 55px; /* 宽度设为55px */
    height: 40px; /* 高度设为40px，这样基础形状更稳定 */
    /* 背景色和半透明效果保持不变 */
    background-color: rgba(209, 233, 206, 0.8); 
    
    /* 核心修改：只设置左上角和右上角的圆角，让底部保持平坦 */
    /* 这四个值分别对应：左上、右上、右下、左下 */
    border-radius: 60px 60px 30px 30px; 

    position: relative;
    animation: slime-bob 2s infinite ease-in-out;
    transition: all 0.5s ease;
    
    /* 边框效果保持不变 */
    border: 2px solid rgba(76, 175, 80, 0.5);
    /* 新增：移除底部边框线，让它完美地“贴”在地面上 */
    border-bottom: none; 
    
    /* 内阴影果冻质感保持不变 */
    box-shadow: inset 0 -4px 8px rgba(0, 0, 0, 0.15), 
                inset 0 4px 6px rgba(255, 255, 255, 0.4);
}
        .slime.hungry { background-color: #ffb74d; }
        .slime.dirty { background-color: #bdbdbd; }
        .slime::before {
            content: '';
            position: absolute;
            width: 7px;
            height: 7px;
            background-color: #212121;
            border-radius: 50%;
            top: 15px;
            left: 12px;
            transition: all 0.5s ease;
        }
        .slime::after {
            content: '';
            position: absolute;
            width: 7px;
            height: 7px;
            background-color: #212121;
            border-radius: 50%;
            top: 15px;
            right: 12px;
            transition: all 0.5s ease;
        }
        .slime-shadow {
            width: 50px;
            height: 8px;
            background-color: rgba(0,0,0,0.1);
            border-radius: 50%;
            margin-top: 5px;
            animation: slime-shadow-squish 2s infinite ease-in-out;
            transition: all 0.5s ease;
        }
        @keyframes slime-bob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        @keyframes slime-shadow-squish {
             0%, 100% { transform: scaleX(1); }
            50% { transform: scaleX(0.8); }
        }

        /* --- V6.0 新增：宠物进化形态 --- */
        /* 初始宝宝期形态 */
        .slime.baby-form { }

        /* 幼年期 */
        .slime.toddler-form {
            transform: scale(1.15); /* 长大一点 */
            background-color: #a5d6a7; /* 颜色变嫩一点 */
        }
        .slime.toddler-form::before, 
        .slime.toddler-form::after {
            width: 7px; /* 眼睛变大一点 */
            height: 7px;
            box-shadow: 0 0 2px rgba(255, 255, 255, 0.6); /* 眼睛里有光 */
        }

        /* 少年期，眼睛变成 > < 的样子*/
        .slime.teenager-form {
            transform: scale(1.25);
            animation-duration: 1.5s; /* 变得更活泼，跳得快一点 */
        }
        .slime.teenager-form::before { /* 左眼 */
            content: '>';
            font-weight: bold;
            color: white;
            background: none;
            font-size: 12px;
            line-height: 1;
            transform: rotate(-15deg);
            top: 18px;
            left: 18px;
        }
        .slime.teenager-form::after { /* 右眼 */
            content: '<';
            font-weight: bold;
            color: white;
            background: none;
            font-size: 12px;
            line-height: 1;
            transform: rotate(15deg);
            top: 18px;
            right: 18px;
        }
        /* --- 新增：史莱姆互动动画 --- */
        .slime.happy-jiggle {
            animation: happy-jiggle 0.5s ease-in-out;
        }
        @keyframes happy-jiggle {
            0%, 100% { transform: scale(1, 1); }
            25% { transform: scale(0.95, 1.05); }
            50% { transform: scale(1.05, 0.95); }
            75% { transform: scale(0.98, 1.02); }
        }

        .slime .blush {
            position: absolute;
            width: 15px;
            height: 6px;
            background-color: rgba(255, 105, 180, 0); /* 默认透明 */
            border-radius: 50%;
            top: 22px;
            transition: background-color 0.3s ease;
        }
        .slime .blush.left { left: 5px; transform: rotate(-15deg); }
        .slime .blush.right { right: 5px; transform: rotate(15deg); }
        .slime.is-blushing .blush {
            background-color: rgba(255, 105, 180, 0.6); /* 脸红 */
        }
/* --- 新增：用于隐藏思维预设的编辑功能 --- */
/*

/ * 1. 隐藏“思维预设管理”页面右上角的“+”添加按钮 * /
#add-thought-preset-btn {
    display: none;
}

/ * 2. 隐藏每个思维预设项目右侧包含“编辑”和“删除”图标的整个操作区 * /
#thought-presets-list .preset-actions {
    display: none;
}

*/
/* --- 钱包收支明细样式 --- */
        #transaction-list {
            padding: 10px 0;
        }
        .transaction-item {
            background-color: white;
            padding: 15px;
            margin: 0 15px 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px var(--shadow-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .transaction-info .desc {
            font-weight: 600;
            color: var(--text-dark);
            margin-bottom: 4px;
            font-size: 16px;
        }
        .transaction-info .time {
            font-size: 13px;
            color: var(--text-gray);
        }
        .transaction-amount {
            font-size: 16px;
            font-weight: bold;
            flex-shrink: 0;
            margin-left: 15px;
        }
        .transaction-amount.income {
            color: var(--theme-primary-hover);
        }
        .transaction-amount.expense {
            color: var(--soft-red);
        }

/* --- 转账退还样式 --- */
        .message.transfer.returned {
            background-color: #bdc3c7; /* 中性灰色背景 */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .message.transfer.returned .transfer-info .transfer-text,
        .message.transfer.returned .transfer-info .transfer-amount,
        .message.transfer.returned .transfer-footer {
            color: #6c757d;
            text-decoration: line-through; /* 添加删除线表示作废 */
        }
        .message.transfer.returned .transfer-icon i {
            color: #6c757d;
        }
        /* 将退还后的图标从对勾变为退还箭头 */
        .message.transfer.returned::after {
            content: '\f0e2'; /* Font Awesome "reply/undo" icon */
            font-family: 'Font Awesome 6 Free';
            font-weight: 900; 
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 18px;
            color: #6c757d;
        }
        /* 转账弹窗里的退还按钮样式 */
        #return-transfer-btn {
            margin-top: 10px;
            background-color: #e67e22; /* 胡萝卜橙色 */
        }
        /* --- 全新美化的转账弹窗样式 --- */
        #transfer-modal .modal-header { /* 优化头部 */
            background-color: #f7f9f9;
            color: var(--text-dark);
            border-bottom: 1px solid #eee;
        }
        #transfer-modal .close-btn { color: #999; }
        #transfer-modal .modal-body {
            padding: 20px 25px 30px;
            text-align: center;
        }
        .transfer-sender-profile { /* 发起人信息 */
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 25px;
        }
        .transfer-sender-avatar {
            width: 50px;
            height: 50px;
            border-radius: 8px;
            margin-right: 12px;
        }
        .transfer-sender-info { text-align: left; }
        .transfer-sender-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--text-dark);
        }
        .transfer-recipient-name {
            font-size: 14px;
            color: var(--text-gray);
        }
        .transfer-amount-display { /* 金额显示 */
            padding-bottom: 25px;
            margin-bottom: 25px;
            border-bottom: 1px dashed #ddd;
        }
        .transfer-amount-display span:first-child { /* '¥' 符号 */
            font-size: 32px;
            font-weight: 500;
            margin-right: 4px;
        }
        .transfer-amount-display span:last-child { /* 金额数字 */
            font-size: 48px;
            font-weight: 700;
            color: var(--text-dark);
        }
        .transfer-action-area .form-button { /* 按钮区域 */
            margin-top: 10px;
        }
        #confirm-transfer-btn { background-color: var(--theme-primary); }
        #return-transfer-btn { background-color: #e67e22; }

        /* --- 已收款/已退还状态视图 --- */
        .transfer-status-info {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: 600;
            color: var(--text-dark);
        }
        .transfer-status-info i {
            font-size: 24px;
            margin-right: 10px;
        }
        .transfer-status-info i.fa-check-circle { color: var(--theme-primary-hover); }
        .transfer-status-info i.fa-undo-alt { color: #e67e22; }
        .transfer-status-subtext {
            margin-top: 8px;
            font-size: 14px;
            color: var(--text-gray);
        }
        /* --- 修正系统消息包裹层，使其居中 --- */
        .message-wrapper.system-wrapper {
            align-self: center;
            /* 解除最大宽度限制，让内部的灰色消息自己决定宽度 */
            max-width: none;
        }
        /* --- 论坛帖子内的红包卡片样式 --- */
        .forum-red-packet-card {
            background-color: #FFCC80;
            color: #5D4037;
            padding: 10px 15px;
            margin-top: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .forum-red-packet-card:hover {
            transform: scale(1.02);
        }
        .forum-red-packet-card .red-packet-icon {
            font-size: 24px;
            margin-right: 10px;
            color: #FFA726;
        }
        .forum-red-packet-card .red-packet-blessing {
            font-weight: 500;
        }

        /* --- 帖子分享到私聊里的卡片样式 --- */
        .message.post-share-card {
            background-color: #fff;
            border: 1px solid #eee;
            width: 250px;
            padding: 12px;
            border-radius: 12px;
            cursor: pointer;
        }
        .post-share-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #f0f0f0;
        }
        .post-share-avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .post-share-name {
            font-weight: 600;
            font-size: 14px;
        }
        .post-share-content {
            font-size: 14px;
            color: var(--text-gray);
            display: -webkit-box;
            -webkit-line-clamp: 3;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis;
            line-height: 1.5;
        }
        .post-share-footer {
            margin-top: 8px;
            font-size: 12px;
            color: #ccc;
            text-align: right;
        }
        
        /* --- 发布动态时添加红包的按钮样式 --- */
        .moment-extra-actions {
            display: flex;
            justify-content: flex-start;
            padding-top: 10px;
            border-top: 1px solid #f0f0f0;
        }
        .moment-action-btn {
            font-size: 20px;
            color: var(--text-gray);
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
        }
        .moment-action-btn:hover {
            background-color: #f0f0f0;
        }
        .moment-action-btn.active {
            color: var(--soft-red);
        }
        
        /* --- 转发时选择联系人的弹窗样式 --- */
        .contact-picker-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 15px;
        }
        .contact-picker-item {
            display: flex;
            align-items: center;
            padding: 10px;
            border-radius: 6px;
        }
        .contact-picker-item:hover {
            background-color: #f9f9f9;
        }
        .contact-picker-item input {
            margin-right: 15px;
        }
        .contact-picker-item img {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 10px;
        }
        #custom-confirm-confirm-btn.danger {
    background-color: var(--soft-red) !important;
}
/* ========================================================== */
/* V9.0 新增：悬浮音乐播放器样式 */
/* ========================================================== */
:root {
    --apple-green: #8DB600; /* 新增苹果绿 */
}
#music-player-card {
    display: none; /* 默认隐藏，由JS控制 */
    flex-direction: column;
    position: absolute; /* 使用absolute定位在#screen内 */
    width: 320px;
    height: 500px;
    background-color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
    overflow: hidden;
    top: 50px; 
    left: 50px;
    z-index: 1000;
    transition: all 0.4s ease-in-out;
}
.player-header {
    padding: 0 15px;
    height: 45px;
    font-weight: 600;
    color: var(--text-dark);
    background-color: rgba(0,0,0,0.05);
    cursor: move;
    position: relative;
    user-select: none;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-shrink: 0;
}
.player-collapse-btn {
    position: absolute;
    top: 50%;
    left: 15px;
    transform: translateY(-50%);
    cursor: pointer;
    color: var(--text-light);
    padding: 5px;
}
/* --- ▼▼▼ 新增的关闭按钮样式 ▼▼▼ --- */
#player-close-btn {
    position: absolute;
    top: 50%;
    right: 15px;
    transform: translateY(-50%);
    cursor: pointer;
    color: var(--text-gray);
    padding: 5px;
    font-size: 18px;
    transition: transform 0.2s ease;
}
#player-close-btn:hover {
    transform: translateY(-50%) scale(1.15);
}
.header-collapsed-content {
    display: none;
    align-items: center;
    gap: 10px;
    width: 100%;
    padding-left: 35px;
}
.header-avatar-stack { display: flex; align-items: center; }
.header-avatar {
    width: 28px;
    height: 28px;
    border-radius: 50%;
    border: 2px solid white;
    object-fit: cover;
}
.header-avatar:last-child { margin-left: -10px; }
.header-lyric {
    flex-grow: 1;
    font-size: 14px;
    font-weight: 600;
    color: var(--apple-green);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.player-main-content {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
    transition: opacity 0.3s;
}
.player-avatar-stack { display: flex; justify-content: center; align-items: center; padding: 20px 0 15px; }
.player-avatar { width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 3px solid white; box-shadow: 0 4px 10px rgba(0,0,0,0.15); }
.player-avatar:last-child { margin-left: -25px; }
.player-song-info { text-align: center; }
.player-title { font-size: 18px; font-weight: 700; color: var(--text-dark); }
.player-artist { font-size: 14px; color: var(--text-light); margin-top: 5px; }
.lyrics-container { flex-grow: 1; overflow: hidden; position: relative; mask-image: linear-gradient(transparent 0%, black 20%, black 80%, transparent 100%); margin-top: 15px; }
.lyrics-wrapper { position: absolute; width: 100%; transition: transform 0.5s ease-out; }
.lyric-line { padding: 8px 20px; text-align: center; font-size: 16px; color: var(--text-light); transition: color 0.5s, transform 0.5s; }
.lyric-line.active {
    color: var(--apple-green);
    font-weight: 600; 
    transform: scale(1.1); 
}
.player-controls-wrapper { padding: 15px 20px; border-top: 1px solid rgba(0,0,0,0.05); }
.player-progress-bar-wrapper { display: flex; align-items: center; gap: 10px; font-size: 12px; color: var(--text-light); }
.player-progress-bar { flex-grow: 1; height: 4px; background-color: rgba(0,0,0,0.1); border-radius: 2px; cursor: pointer; padding: 4px 0; background-clip: content-box; }
.player-progress { width: 0%; height: 100%; background-color: var(--theme-primary); border-radius: 2px; }
.player-controls { display: flex; justify-content: space-around; align-items: center; font-size: 20px; margin-top: 10px; color: var(--text-dark); }
.player-control-btn { cursor: pointer; transition: transform 0.2s; width: 30px; text-align: center;}
.player-control-btn:hover { transform: scale(1.15); }
.player-play-btn { font-size: 40px; color: var(--theme-primary); }

#music-player-card.collapsed {
    height: 45px;
    background-color: rgba(255, 255, 255, 0.2);
    backdrop-filter: blur(25px);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.25);
}
#music-player-card.collapsed .header-collapsed-content,
#music-player-card.collapsed .player-collapse-btn {
    text-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
#music-player-card.collapsed .player-header-title { display: none; }
#music-player-card.collapsed .header-collapsed-content { display: flex; }
#music-player-card.collapsed .player-main-content { visibility: hidden; opacity: 0; }

.player-playlist-view {
    position: absolute;
    top: 45px;
    left: 0; right: 0; bottom: 95px; 
    background-color: rgba(255, 255, 255, 0.92); 
    backdrop-filter: blur(20px); 
    transform: translateY(100%);
    transition: transform 0.4s ease-in-out, opacity 0.4s ease-in-out; /* 建议给opacity也加上过渡效果 */
    opacity: 0;
    padding: 10px 0;
    overflow-y: auto;
    border-top: 1px solid rgba(0,0,0,0.05);
    pointer-events: none; /* <-- 核心新增：隐藏时忽略点击事件 */
    z-index: 3;
}
.player-playlist-view.active { 
    transform: translateY(0); 
    opacity: 1; 
    pointer-events: auto; /* <-- 核心新增：显示时恢复点击事件 */
}
.playlist-item { padding: 12px 20px; cursor: pointer; border-bottom: 1px solid rgba(0,0,0,0.05); }
.playlist-item:hover { background-color: rgba(0,0,0,0.05); }
.playlist-item.playing .playlist-title { color: var(--theme-primary); }
.playlist-title { font-weight: 600; color: var(--text-dark); font-size: 14px; }
.playlist-artist { font-size: 12px; color: var(--text-light); }
/* ========================================================== */
/* V16.0 最终完美版：无缝、平滑的呼吸光晕 */
/* ========================================================== */

/* 1. 【防重叠魔法】(此部分无变化) */
.player-avatar {
    position: relative;
}
.player-avatar:first-child {
    z-index: 2;
}
.player-avatar:last-child {
    z-index: 1;
}

/* 2. 【重新定义动画】创建一个完整的“吸气-呼气”循环 */
@keyframes pulse-glow-left {
    /* 动画的开始和结束点都是同一个状态：最小、最明显的光晕 */
    0%, 100% {
        box-shadow: -2px 0 5px 0px rgba(129, 199, 132, 0.7);
    }
    /* 动画的中点是另一个状态：最大、最微弱的光晕 */
    50% {
        /* 关键：这里的透明度不是0，而是0.1，保留了一丝微光，确保动画永不中断！ */
        box-shadow: -8px 0 20px 12px rgba(129, 199, 132, 0.1);
    }
}

@keyframes pulse-glow-right {
    0%, 100% {
        box-shadow: 2px 0 5px 0px rgba(129, 199, 132, 0.7);
    }
    50% {
        box-shadow: 8px 0 20px 12px rgba(129, 199, 132, 0.1);
    }
}

/* 3. 【应用新动画】移除 alternate，并使用更平滑的 ease-in-out */
#player-avatar-stack.is-playing .player-avatar:first-child {
    /* 动画时长3秒，无限循环，缓入缓出效果，不再需要 alternate */
    animation: pulse-glow-left 3s infinite ease-in-out;
}
#player-avatar-stack.is-playing .player-avatar:last-child {
    animation: pulse-glow-right 3s infinite ease-in-out;
}
/* --- 红包领取详情弹窗样式 --- */
.claimer-item {
    display: flex;
    align-items: center;
    padding: 12px 15px;
    border-bottom: 1px solid #f0f0f0;
}
.claimer-item:last-child {
    border-bottom: none;
}
.claimer-avatar {
    width: 40px;
    height: 40px;
    border-radius: 6px;
    margin-right: 12px;
}
.claimer-info {
    flex-grow: 1;
}
.claimer-name {
    font-weight: 500;
    color: var(--text-dark);
}
.claim-time {
    font-size: 12px;
    color: var(--text-gray);
    margin-top: 2px;
}
.claim-amount {
    font-size: 15px;
    font-weight: 600;
    color: var(--text-dark);
}
.best-luck-badge {
    background-color: #FFD700;
    color: #A67C00;
    font-size: 11px;
    font-weight: bold;
    padding: 2px 6px;
    border-radius: 5px;
    margin-left: 8px;
}
/* --- V-Final 新增: 游戏转盘样式 --- */
.wheel-option-item {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
}
.wheel-option-item input[type="text"] {
    flex-grow: 1;
}
.wheel-option-item input[type="number"] {
    width: 60px;
    text-align: center;
}
.wheel-option-item .delete-option-btn {
    background: none;
    border: none;
    color: var(--soft-red);
    cursor: pointer;
    font-size: 18px;
}
.message.game-wheel-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 250px;
    padding: 12px;
    border-radius: 12px;
}
.wheel-card-title {
    font-weight: bold;
    text-align: center;
    padding-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
    margin-bottom: 12px;
}
.wheel-card-result-area {
    display: flex;
    flex-direction: column;
    gap: 10px;
}
.wheel-result-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
}
.wheel-player-name {
    font-size: 14px;
    color: #555;
}
.wheel-player-result {
    font-size: 14px;
    font-weight: 600;
    background-color: #f0f2f5;
    padding: 4px 10px;
    border-radius: 12px;
}
.spin-btn {
    background-color: var(--theme-primary);
    color: white;
    border: none;
    padding: 4px 12px;
    border-radius: 12px;
    cursor: pointer;
    font-size: 14px;
}
.spin-btn:hover {
    background-color: var(--theme-primary-hover);
}
/* --- 引用回复功能样式 --- */
.message-wrapper {
    position: relative; /* 确保回复按钮可以正确定位 */
}

.reply-btn {
    position: absolute;
    top: 50%;
    background-color: rgba(240, 240, 240, 0.8);
    backdrop-filter: blur(2px);
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    color: #555;
    cursor: pointer;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    opacity: 0; /* 默认完全透明，隐藏 */
    transform: translateY(-50%) scale(0.8); /* 默认缩小一点 */
    transition: opacity 0.2s ease, transform 0.2s ease; /* 添加平滑过渡动画 */
    pointer-events: none; /* 隐藏时不可点击 */
}

/* 当父级 message-wrapper 拥有 .show-reply-btn 类时，让按钮显示出来 */
.message-wrapper.show-reply-btn .reply-btn {
    opacity: 1;
    transform: translateY(-50%) scale(1);
    pointer-events: auto; /* 显示时恢复点击 */
}

.message-wrapper.sent .reply-btn {
    left: -35px; /* 发送的消息，按钮在左边 */
}
.message-wrapper.received .reply-btn {
    right: -35px; /* 收到的消息，按钮在右边 */
}
.reply-btn:hover {
    transform: translateY(-50%) scale(1.1) !important;
}

/* 聊天输入框上方的引用预览条 */
#reply-preview-bar {
    padding: 8px 15px;
    background-color: #f0f0f0;
    font-size: 13px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #e0e0e0;
}
#reply-preview-content {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    color: #666;
}
#reply-preview-content .sender {
    font-weight: 600;
    color: #333;
}
#cancel-reply-btn {
    cursor: pointer;
    font-size: 16px;
    margin-left: 10px;
    color: #888;
}

/* 聊天气泡中的引用消息框 */
.message-quote {
    background-color: rgba(0, 0, 0, 0.05);
    padding: 6px 12px;
    border-left: 3px solid var(--theme-primary);
    border-radius: 6px;
    margin-bottom: 8px;
    font-size: 13px;
    cursor: pointer; /* 添加手型光标，提示可以点击 */
}
.message-quote .sender {
    font-weight: 600;
    color: var(--theme-primary);
}
.message-quote .content {
    color: #555;
    white-space: normal; /* Allows the text to wrap naturally */
    word-wrap: break-word; /* Ensures long words don't overflow */
    display: block;
    /* The overflow and text-overflow properties are no longer needed */
}

/* 点击引用框跳转后，目标消息的高亮效果 */
.message-wrapper.highlighted .message {
    animation: highlight-anim 1.5s ease;
}
@keyframes highlight-anim {
    0% { background-color: #fff3cd; }
    100% { background-color: inherit; }
}
.message-wrapper.sent.highlighted .message.sent {
     animation: highlight-anim-sent 1.5s ease;
}
@keyframes highlight-anim-sent {
    0% { background-color: #bde0fe; }
    100% { background-color: var(--sent-message-bg); }
}
/* --- V-Final 新增: 叙事模式气泡加宽 --- */
#chat-messages.narrative-mode-active .message-wrapper {
    max-width: 90%; /* 从默认的 85% 增加到 95% */
}
/* --- V-Final 新增: 在聊天中隐藏角色头像 --- */
.message-wrapper.contact-avatar-hidden .message-avatar {
    display: none;
}
.message-wrapper.received.contact-avatar-hidden .message-body {
    margin-left: 0;
}
/* ========================================================== */
/* V17.0 新增：视频通话样式 (简化版) */
/* ========================================================== */
.video-call-card-content {
    width: 90%;
    max-width: 400px;
    height: 75%;
    max-height: 650px;
    background-color: rgba(255, 255, 255, 0.92);
    backdrop-filter: blur(18px);
    border-radius: 24px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.5);
    display: flex;
    flex-direction: column;
    color: var(--text-dark);
    overflow: hidden;
}
.video-call-header { padding: 15px; text-align: center; flex-shrink: 0; border-bottom: 1px solid rgba(0,0,0,0.07); }
#call-contact-name { font-size: 18px; font-weight: 700; }
#call-status { display: block; font-size: 13px; color: var(--theme-primary); margin-top: 4px; font-weight: 600; }
.video-call-main { flex-grow: 1; padding: 15px; overflow: hidden; }
.narrative-feed { height: 100%; overflow-y: auto; padding-right: 10px; display: flex; flex-direction: column; }
.char-bubble { align-self: flex-start; max-width: 90%; background-color: #fff; border: 1px solid var(--border-color); box-shadow: 0 1px 2px rgba(0,0,0,0.04); padding: 10px 15px; border-radius: 18px; border-top-left-radius: 4px; margin-bottom: 12px; font-size: 15px; line-height: 1.6; }
.char-bubble p { margin: 0 0 8px 0; }
.char-bubble p:last-child { margin-bottom: 0; }
.char-bubble .narrative-speech { color: var(--text-dark); font-weight: 500; }
.char-bubble .narrative-action { color: var(--text-gray); font-style: italic; }
.char-bubble .narrative-psychology { color: var(--theme-primary-hover); font-style: italic; }
.narrative-feed > .narrative-action { color: var(--text-gray); font-style: italic; align-self: center; text-align: center; font-size: 13px; margin: 5px 0 15px 0; }
.user-message { align-self: flex-end; background-color: var(--sent-message-bg); padding: 10px 15px; border-radius: 18px; border-bottom-right-radius: 4px; color: var(--text-dark); font-weight: 500; margin-bottom: 12px; max-width: 90%; font-size: 15px; line-height: 1.6; }
.video-call-input-area { padding: 8px 15px; display: flex; align-items: center; border-top: 1px solid rgba(0,0,0,0.07); background-color: rgba(0,0,0,0.03); flex-shrink: 0; }
#video-call-input { flex-grow: 1; background-color: white; border: 1px solid var(--border-color); border-radius: 20px; padding: 8px 15px; font-size: 15px; outline: none; resize: none; max-height: 100px; overflow-y: auto; font-family: inherit; }
#video-call-send-btn { background-color: var(--theme-primary); color: var(--text-on-primary); border: none; border-radius: 50%; width: 38px; height: 38px; display: flex; justify-content: center; align-items: center; margin-left: 8px; cursor: pointer; font-size: 16px; flex-shrink: 0; transition: background-color 0.2s; }
.video-call-controls { display: flex; justify-content: space-around; align-items: center; padding: 15px 20px; background-color: rgba(0,0,0,0.03); flex-shrink: 0; }
.control-btn { display: flex; flex-direction: column; align-items: center; cursor: pointer; width: 80px; text-align: center; }
.control-btn i { width: 60px; height: 60px; border-radius: 50%; background-color: #e9ecef; color: var(--text-dark); display: flex; justify-content: center; align-items: center; font-size: 26px; margin-bottom: 6px; transition: all 0.2s ease; }
.control-btn span { font-size: 12px; font-weight: 500; color: var(--text-gray); }
.control-btn.hang-up i { background-color: var(--soft-red); color: white; }

/* 来电界面样式 */
#incoming-call-screen {
    display: none; 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    z-index: 1002; 
    background-color: rgba(0,0,0,0.7); 
    backdrop-filter: blur(10px); 
    color: white; 
    text-align: center; 
    flex-direction: column; 
    justify-content: space-around; 
    align-items: center;
}

/* 实际通话界面样式 */
#video-call-screen {
    display: none; 
    position: absolute; 
    top: 0; 
    left: 0; 
    width: 100%; 
    height: 100%; 
    justify-content: center; 
    align-items: center; 
    z-index: 1001; 
    background-color: rgba(0,0,0,0.4);
}
/* --- 新增：响应式手机屏幕模拟 --- */
#app-container {
    /* 默认情况下（手机访问时），占满整个屏幕 */
    width: 100%;
    height: 100%;
    background-color: #f0f2f5; /* 给电脑屏幕背景一个颜色，突出手机区域 */
}

/* 当屏幕宽度大于等于 600px 时（可以理解为平板或电脑）*/
@media (min-width: 600px) {
    #app-container {
        /* 将其最大宽度限制为手机尺寸 */
        max-width: 414px;

        /* 高度也限制为手机尺寸 */
        height: 896px;

        /* 保留圆角来模拟屏幕形状 */
        border-radius: 40px; 
        
        /* 加一点阴影，让它在电脑上有悬浮感，如果完全不想要也可以删除这行 */
        box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);

        /* 确保内部内容不会溢出圆角 */
        overflow: hidden; 
        
        /* 确保内部的 #screen 元素能正确继承尺寸 */
        position: relative; 
    }
}
/* --- V-Final 新增: 购物中心样式 V3 (修正版) --- */
.product-list {
    display: grid;
    grid-template-columns: 1fr 1fr;
    align-items: start;
    gap: 6px;
    padding: 10px;
}
.product-item {
    background-color: white;
    border-radius: var(--soft-radius);
    box-shadow: 0 1px 4px rgba(0,0,0,0.07);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: 1px solid #f0f0f0;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    cursor: pointer;
}
.product-item:hover {
    transform: translateY(-3px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.08);
}
/* V3核心修正：瀑布流错位效果 */
.product-item:nth-child(even) {
    margin-top: 10px;
}
.product-details {
    padding: 12px;
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-title {
    font-size: 15px;
    font-weight: 600;
    line-height: 1.4;
    color: var(--text-dark);
    margin-bottom: 8px;
}
.product-description {
    font-size: 13px;
    color: #555;
    background-color: #f7f9fa;
    padding: 8px 10px;
    border-radius: 8px;
    margin-bottom: 10px;
    line-height: 1.5;
}
.product-shop {
    font-size: 12px;
    color: var(--text-gray);
    margin-top: auto;
    padding-top: 5px;
}
.product-footer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 8px;
}
.product-price {
    font-size: 16px;
    font-weight: bold;
    color: #ff7043;
}
.product-price span {
    font-size: 12px;
    font-weight: normal;
}
.product-share-btn {
    background: none;
    border: none;
    font-size: 18px;
    color: var(--text-gray);
    cursor: pointer;
    padding: 5px;
}
.product-share-btn:hover {
    color: var(--theme-primary);
}
.message.product-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 240px;
    padding: 10px;
    border-radius: 12px;
}
.product-share-intent {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-gray);
    padding-bottom: 8px;
    margin-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
.product-share-body {
    display: flex;
    flex-direction: column;
    gap: 8px;
}
.product-share-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-share-info .product-title {
    -webkit-line-clamp: 3;
    font-weight: 600;
}
.product-share-info .product-price {
    margin-top: 5px;
    text-align: right;
}
.product-share-accompanying-msg {
    margin-top: 10px;
    padding: 8px;
    background-color: #f7f9fa;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    white-space: pre-wrap;
    word-break: break-all;
}
.product-share-accompanying-msg:empty {
    display: none;
}
#product-detail-content #product-main-info {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--soft-radius);
    box-shadow: var(--shadow-color);
}
#detail-action-bar {
    border-top: 1px solid var(--border-color);
    padding: 10px 15px;
}

/* --- V3 新增: 商品详情页样式 --- */
#product-detail-content #product-main-info {
    background-color: #fff;
    padding: 20px;
    border-radius: var(--soft-radius);
    box-shadow: var(--shadow-color);
}
#detail-action-bar {
    border-top: 1px solid var(--border-color);
    padding: 10px 15px;
}
/* --- V-Final 新增: 聊天内分享的商品卡片样式 V2 --- */
.message.product-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 240px;
    padding: 10px;
    border-radius: 12px;
}
.product-share-intent {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-gray);
    padding-bottom: 8px;
    margin-bottom: 8px;
    border-bottom: 1px solid #f0f0f0;
}
/* V2改动：卡片内不再有图片，改为显示文字描述 */
.product-share-body {
    display: flex;
    flex-direction: column; /* 改为垂直布局 */
    gap: 8px;
}
.product-share-info {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}
.product-share-info .product-title {
    -webkit-line-clamp: 3;
    font-weight: 600;
}
.product-share-info .product-price {
    margin-top: 5px;
    text-align: right;
}
.product-share-accompanying-msg {
    margin-top: 10px;
    padding: 8px;
    background-color: #f7f9f9;
    border-radius: 8px;
    font-size: 13px;
    color: #555;
    white-space: pre-wrap;
    word-break: break-all;
}
.product-share-accompanying-msg:empty {
    display: none;
}
/* --- 聊天顶栏“更多操作”菜单样式 (小竖条版) --- */
#chat-options-menu {
    position: absolute;
    top: 55px; /* 从顶栏下方弹出 */
    right: 10px; /* 对齐右侧的按钮 */
    width: 160px; /* 核心改动：固定宽度，让它成为一个“竖条” */
    background-color: rgba(248, 249, 250, 0.92); /* 使用一个更明亮的背景色 */
    backdrop-filter: blur(12px);
    border-radius: 12px; /* 圆角可以稍微小一点，更显精致 */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); /* 一个更柔和的阴影 */
    z-index: 100;
    overflow: hidden;
    border: 1px solid rgba(0, 0, 0, 0.08);
}

.chat-option-item {
    display: flex;
    align-items: center;
    padding: 10px 15px; /* 减少一点垂直内边距，让菜单更紧凑 */
    cursor: pointer;
    font-size: 14px; /* 字体也可以稍微小一点 */
    color: var(--text-gray);
    transition: background-color 0.2s; /* 添加一个过渡效果 */
}

.chat-option-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}

.chat-option-item i {
    margin-right: 12px;
    color: var(--text-gray);
    width: 20px; /* 固定图标宽度，让文字对齐 */
    text-align: center;
}

.chat-option-divider {
    height: 1px;
    background-color: var(--border-color);
    margin: 4px 10px; /* 分割线也调整一下边距 */
}
/* --- ▼▼▼ 把这段新代码粘贴到 <style> 标签里 --- */
.collapsible-title {
    cursor: pointer; /* 鼠标悬浮时显示为小手形状 */
    display: flex; /* 使用flex布局，让标题和箭头能在一行显示 */
    justify-content: space-between; /* 让标题在左，箭头在右 */
    align-items: center;
}

.collapsible-title .collapse-icon {
    transition: transform 0.2s ease-in-out; /* 让箭头旋转有动画效果 */
    font-size: 14px;
}

.collapsible-title.collapsed .collapse-icon {
    transform: rotate(-90deg); /* 折叠时，箭头旋转-90度 */
}
/* --- ▲▲▲ 粘贴到这里结束 --- */
/* --- 新增：史莱姆随机表情 --- */
/* 移除默认眼睛，为新表情做准备 */
.slime.expression-happy::before, .slime.expression-happy::after,
.slime.expression-sad::before, .slime.expression-sad::after,
.slime.expression-annoyed::before, .slime.expression-annoyed::after,
.slime.expression-shocked::before, .slime.expression-shocked::after {
    background: none; /* 隐藏原来的黑点背景 */
    font-weight: bold;
    font-size: 12px;
    line-height: 1;
    color: #212121; /* 统一设为深灰色 */
}

/* 1. 开心表情 ^_^ */
.slime.expression-happy::before,
.slime.expression-happy::after {
    content: '^';
    top: 18px;
}

/* 2. 难过表情 T_T */
.slime.expression-sad::before,
.slime.expression-sad::after {
    content: 'T';
    top: 18px;
    color: #4285F4; /* 来点蓝色眼泪 */
}

/* 3. 生气/不爽表情 >_< */
.slime.expression-annoyed::before {
    content: '>';
    transform: rotate(-15deg);
    top: 18px;
    left: 18px;
}
.slime.expression-annoyed::after {
    content: '<';
    transform: rotate(15deg);
    top: 18px;
    right: 18px;
}

/* 4. 震惊表情 o_o */
.slime.expression-shocked::before,
.slime.expression-shocked::after {
    content: ''; /* 恢复为空，我们用边框画圆 */
    width: 8px;
    height: 8px;
    border: 2px solid #212121; /* 用边框画一个空心圆 */
    background: white; /* 中间是白色的 */
}
/* --- 新增：更多可爱表情 --- */

/* 1. 开心满足 (u u) */
.slime.expression-pleased::before,
.slime.expression-pleased::after {
    content: 'u';
    font-size: 13px; /* 字体尺寸可以微调 */
    top: 18px;
    font-weight: 600; /* 加粗一点更明显 */
    color: #333;
    background: none;
}

/* 2. 晕乎乎 (x x) */
.slime.expression-dizzy::before,
.slime.expression-dizzy::after {
    content: '×'; /* 使用乘号 × 比字母 x 更好看 */
    font-size: 14px;
    top: 17px;
    font-weight: 600;
    color: #555;
    background: none;
}

/* 3. 无语/怀疑 (- .) */
.slime.expression-doubtful::before {
    content: '';
    width: 10px; /* 横线宽度 */
    height: 3px;  /* 横线厚度 */
    background: #212121;
    border-radius: 2px; /* 让横线两端圆润 */
    top: 20px;
    left: 10px;
}
.slime.expression-doubtful::after {
    /* 右眼还是一个点 */
    content: '';
    width: 7px;
    height: 7px;
    background-color: #212121;
    border-radius: 50%;
    top: 15px;
    right: 12px;
}
/* --- 新增：嘴巴的基础样式和“猫猫嘴”表情 --- */

/* 1. 嘴巴的基础样式 (定位和默认隐藏) */
.slime .mouth {
    position: absolute;
    bottom: 8px; /* 嘴巴在底部偏上一点的位置 */
    left: 50%;
    transform: translateX(-50%); /* 水平居中 */
    width: 0;
    height: 0;
    transition: all 0.3s ease; /* 让表情变化更平滑 */
}

/* 2. 可爱的猫猫嘴 (owo) 表情 */
.slime.expression-cat-face::before,
.slime.expression-cat-face::after {
    /* 眼睛是两个空心圆圈 'o' */
    content: '';
    width: 9px;
    height: 9px;
    border: 2px solid #212121;
    background: white;
    border-radius: 50%;
    top: 14px;
}
/* 用边框“画”一个 'w' 形的嘴巴 */
.slime.expression-cat-face .mouth {
    width: 14px;
    height: 7px;
    border-radius: 0 0 10px 10px / 0 0 6px 6px;
    border: 3px solid #212121;
    border-top: none;
    border-left: 2px solid transparent; /* 用透明边框切出豁口 */
    border-right: 2px solid transparent;
    box-sizing: border-box;
}
/* --- 新增：联系人列表的删除按钮样式 --- */
.contact-delete-btn {
    color: #b0b0b0; /* 默认灰色，不显眼 */
    margin-bottom: 6px; /* 在按钮和下方的时间/未读数之间创建一些间距 */
    cursor: pointer;
    font-size: 10px; /* 图标大小 */
    padding: 5px 8px; /* 增加可点击区域，防止误触 */
    transition: color 0.2s ease;
    display: block; /* 确保按钮在时间的上方 */
    text-align: right; /* 确保图标在容器内是右对齐的 */
}

.contact-delete-btn:hover {
    color: var(--soft-red); /* 鼠标悬浮时变为醒目的红色 */
}
/* --- 新增：用于隐藏AI发送的HTML消息的气泡和头像 --- */
.message-wrapper.ai-html-message .message-avatar,
.message-wrapper.ai-html-message .message-author-name,
.message-wrapper.ai-html-message .message-timestamp {
    display: none !important; /* 彻底隐藏头像、名字和时间戳 */
}
/* --- 新增：热搜话题描述框样式 --- */
#trending-topic-description-container {
    background-color: #e8f5e9; /* 一个淡淡的背景色 */
    padding: 15px;
    margin: 10px; /* 与列表和边缘保持距离 */
    border-radius: var(--soft-radius); /* 使用已有的圆角变量 */
    font-size: 15px;
    line-height: 1.6;
    color: var(--text-dark);
    border: 1px solid var(--border-color);
}
/* --- 新增：地图功能样式 --- */
#map-grid-container {
    position: relative; /* 这个很重要，让后面的图标能相对于它定位 */
    width: 1000px;      /* <--- 新增：给地图一个固定的宽度 */
    height: 1000px;     /* <--- 新增：给地图一个固定的高度 */
    background-color: #e8f5e9; /* 新增：给个底色，防止意外透明 */
    overflow: hidden;   /* 新增：防止图标被拖到地图外面 */
    cursor: crosshair;  /* 新增：鼠标放上去时变成十字准星，更像编辑器 */
    background-image:
        linear-gradient(rgba(129, 199, 132, 0.3) 1px, transparent 1px),
        linear-gradient(90deg, rgba(129, 199, 132, 0.3) 1px, transparent 1px);
    background-size: 20px 20px;
}

.map-icon {
    position: absolute;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    cursor: pointer;
    font-size: 16px;
    transition: transform 0.2s, background-color 0.2s;
    border: 2px solid white;
}
.map-icon:hover {
    transform: scale(1.2);
    background-color: white;
}
.map-icon-label {
    position: absolute;
    bottom: -20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0,0,0,0.7);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    pointer-events: none; /* 让标签不影响点击图标 */
    opacity: 0;
    transition: opacity 0.2s;
}
.map-icon:hover .map-icon-label {
    opacity: 1;
}
/* --- 新增：地图编辑器中轴线 --- */
#map-grid-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%; /* 水平居中 */
    width: 1px; /* 线的宽度 */
    height: 100%; /* 线的高度 */
    background-color: rgba(255, 0, 0, 0.4); /* 半透明红色，很醒目 */
    z-index: 1; /* 确保它在网格之上，但在图标之下 */
    pointer-events: none; /* 让这条线不会影响你点击图标 */
}

#map-grid-container::after {
    content: '';
    position: absolute;
    left: 0;
    top: 50%; /* 垂直居中 */
    width: 100%; /* 线的宽度 */
    height: 1px; /* 线的高度 */
    background-color: rgba(255, 0, 0, 0.4); /* 半透明红色 */
    z-index: 1; /* 确保它在网格之上，但在图标之下 */
    pointer-events: none; /* 让这条线不会影响你点击图标 */
}
/* --- 新增：分级地点样式 --- */
.map-icon.tier-1 {
    width: 40px;
    height: 40px;
    font-size: 20px;
    border-width: 3px;
    z-index: 10; /* 让一级地点永远在最上层 */
}

.map-icon.tier-2 {
    /* 默认大小，可以不写，或者明确写出来 */
    width: 30px;
    height: 30px;
    font-size: 16px;
    z-index: 5;
}

.map-icon.tier-3 {
    width: 22px;
    height: 22px;
    font-size: 12px;
    z-index: 2; /* 让三级地点在最下层 */
}

/* 鼠标悬浮时，统一放大，体验更好 */
.map-icon.tier-1:hover { transform: scale(1.2); }
.map-icon.tier-2:hover { transform: scale(1.3); }
.map-icon.tier-3:hover { transform: scale(1.4); }
.message.location-share-card {
    background-color: #fff;
    border: 1px solid #eee;
    width: 250px;
    padding: 12px;
    border-radius: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 12px;
}
.location-card-icon {
    font-size: 24px;
    color: var(--theme-primary);
    flex-shrink: 0;
}
.location-card-info .name {
    font-weight: 600;
    font-size: 15px;
}
.location-card-info .footer {
    font-size: 12px;
    color: #999;
    margin-top: 4px;
}
/* --- 新增：联系人列表的操作按钮和菜单样式 --- */
.contact-options-btn {
    color: #b0b0b0;
    cursor: pointer;
    padding: 5px 10px;
    font-size: 16px;
    margin-right: -5px;
    margin-bottom: 4px;
    display: block;
}
.contact-options-btn:hover {
    color: var(--theme-primary);
}
#contact-item-menu {
    background-color: rgba(248, 249, 250, 0.95);
    backdrop-filter: blur(10px);
    border-radius: 8px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(0, 0, 0, 0.08);
    overflow: hidden;
    width: 200px;
}
#contact-item-menu .menu-item {
    display: flex;
    align-items: center;
    padding: 10px 15px;
    cursor: pointer;
    font-size: 14px;
    color: var(--text-dark);
}
#contact-item-menu .menu-item:hover {
    background-color: rgba(0, 0, 0, 0.05);
}
#contact-item-menu .menu-item i {
    margin-right: 12px;
    color: var(--text-gray);
    width: 20px;
    text-align: center;
}
/* ========================================================== */
/* V-Final 新增: 锁屏界面 (V3.0 最终样式版) */
/* ========================================================== */
#lock-screen {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    z-index: 2000;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* 顶部和底部分离，中间留白 */
    color: white;
    font-family: var(--main-font, 'Nunito', sans-serif);
    opacity: 1;
    visibility: visible;
    transition: opacity 0.5s ease, visibility 0.5s;
    padding: 20px; /* 给整个屏幕一个内边距 */
}

#lock-screen.hidden {
    opacity: 0;
    visibility: hidden;
}

.lock-screen-background {
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    /* 背景图被移除了，会由JS动态添加 */
    background-size: cover;
    background-position: center center;
    background-repeat: no-repeat;
    filter: blur(8px);
    transform: scale(1.1);
    z-index: -1;
}

#lock-screen::before {
    content: '';
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background-color: rgba(0, 0, 0, 0.35);
    z-index: -1;
}

.lock-screen-body {
    display: flex;
    flex-direction: column;
    gap: 15px; /* 行与行之间的间距 */
}

.widget-row {
    display: flex;
    gap: 15px;
}

.lock-block {
    background-color: rgba(255, 255, 255, 0.15);
    border-radius: 20px;
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px S15px rgba(0,0,0,0.1);
    padding: 15px;
}

.photo-block {
    flex: 1.3;
    min-height: 250px;
    /* ▼▼▼ 在这里添加下面三行 ▼▼▼ */
    background-size: contain;     /* 核心：保证图片完整显示 */
    background-position: center;  /* 图片在区块内居中 */
    background-repeat: no-repeat; /* 防止图片平铺重复 */
}
.right-column {
    flex: 1; /* 窄一点 */
    display: flex;
    flex-direction: column;
    gap: 15px;
}
.right-column .widget {
    flex: 1; /* 均分高度 */
}

/* 第二行布局 */
#lock-screen-time-widget { flex: 1; }
#lock-screen-music-widget { flex: 1.3; }

/* 第三行布局 */
#lock-screen-notification-widget {
    width: 100%;
    flex-direction: row;
    align-items: center;
    gap: 12px;
    font-size: 15px; /* 稍微增大字体 */
    opacity: 0.9;
    min-height: 50px; /* 新增：增加最小高度 */
    padding: 0 15px;  /* 新增：增加左右内边距 */
    overflow: hidden; /* 新增：隐藏滚出边界的文字 */
}

.lock-screen-footer {
    text-align: center;
    font-size: 14px;
    opacity: 0.8;
    padding: 10px 0;
}

/* 组件内部样式 */
.widget { display: flex; flex-direction: column; }
.widget-header { font-size: 14px; font-weight: 600; color: rgba(255, 255, 255, 0.8); margin-bottom: 8px; padding-bottom: 5px; border-bottom: 1px solid rgba(255, 255, 255, 0.2); }
.widget-header i { margin-right: 6px; }
.widget-content { flex-grow: 1; display: flex; flex-direction: column; justify-content: center; }
.memo-content { font-size: 15px; line-height: 1.6; cursor: pointer; justify-content: flex-start; overflow-y: auto; }
.countdown-content { text-align: center; }
.countdown-days { font-size: 36px; font-weight: 700; }
.countdown-label { font-size: 13px; color: rgba(255, 255, 255, 0.8); margin-top: 4px; }
.placeholder-text { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: center; align-items: center; color: rgba(255, 255, 255, 0.7); }
#lock-screen-time-widget { font-weight: 600; text-align: center; font-size: 42px; line-height: 1.2; }
#lock-screen-date { font-size: 14px; opacity: 0.8; font-weight: normal; }
.music-content { text-align: center; }
#lock-screen-song-info { font-size: 14px; opacity: 0.9; }
.music-controls { margin-top: 10px; display: flex; justify-content: center; align-items: center; gap: 25px; font-size: 20px;}
.music-controls i { cursor: pointer; }
/* --- 新增：为置顶按钮添加激活样式 --- */
.pin-event-btn.active {
    color: var(--theme-primary); /* 使用主题绿色作为激活颜色 */
}
/* ========================================================== */
/* V-Final 新增: 锁屏消息滚动条动画 (V3-图标分离版) */
/* ========================================================== */
#lock-screen-notification-widget {
    width: 100%;
    min-height: 50px;
    padding: 0 15px;
    display: flex; /* 使用flex布局让图标和文字容器并排 */
    align-items: center; /* 垂直居中 */
    gap: 12px;
    font-size: 15px;
    opacity: 0.9;
}

#lock-screen-notification-widget > i {
    opacity: 0.8; /* 图标稍微淡一点 */
}

/* 这是新的滚动“轨道”，负责隐藏超出部分的文字 */
.notification-scroll-wrapper {
    flex-grow: 1; /* 占据剩余的所有宽度 */
    height: 1.5em; /* 限定滚动区域的高度为大约一行文字的高度 */
    overflow: hidden; /* 隐藏超出这个区域的文字 */
    position: relative;
}

/* 这是真正滚动的文字容器 */
#lock-screen-notification-text {
    position: absolute;
    width: 100%;
    animation-name: vertical-scroll;
    animation-timing-function: linear;
    animation-iteration-count: infinite;
    transform: translateY(100%); /* 默认位置在轨道下方 */
}

#lock-screen-notification-text div {
    padding-bottom: 20px;
    white-space: nowrap;
}

@keyframes vertical-scroll {
    from {
        transform: translateY(100%);
    }
    to {
        transform: translateY(-100%);
    }
}
/* --- 新的心声面板样式 (猫咪主题 - 硬编码颜色版) --- */
#heart-voice-panel {
    position: absolute;
    top: 60px;
    left: 50%;
    transform: translateX(-50%);
    width: 280px;
    background-color: #FFFBF5; /* 直接使用颜色 */
    border-radius: 16px;
    border: 2px solid #EAD9D5; /* 直接使用颜色 */
    box-shadow: 4px 4px 0px #EAD9D5; /* 直接使用颜色 */
    display: none;
    flex-direction: column;
    gap: 14px;
    padding: 18px 20px;
    z-index: 100;
}

.hv-item {
    display: flex;
    align-items: flex-start;
    font-size: 14px;
    padding-bottom: 12px;
    border-bottom: 1px dashed #EAD9D5; /* 直接使用颜色 */
}

.hv-item:last-child {
    border-bottom: none;
    padding-bottom: 0;
}

.hv-icon {
    font-size: 18px;
    margin-right: 12px;
    width: 20px;
    text-align: center;
    margin-top: -2px;
}

.hv-label {
    font-weight: 600;
    color: #7D6C65; /* 直接使用颜色 */
    flex-shrink: 0;
}

.hv-value {
    color: #A28F88; /* 直接使用颜色 */
    margin-left: 8px;
    line-height: 1.5;
}

#hv-jealousy {
    color: #FFB347; /* 直接使用颜色 */
    font-size: 16px;
    font-weight: bold;
    letter-spacing: 2px;
}
/* --- 新样式结束 --- */
/* --- 新增：为自动提取的标题和摘要添加样式 --- */
.post-item h3 {
    margin-top: 0;
    margin-bottom: 10px; /* 标题和摘要之间的间距 */
    font-size: 18px;     /* 标题字号 */
    font-weight: 600;    /* 标题加粗 */
    line-height: 1.4;
}

.post-summary {
    font-size: 15px;
    color: #666;        /* 摘要文字颜色 */
    margin: 0;
    /* 以下三行用于摘要文字过多时，显示省略号 */
    display: -webkit-box;
    -webkit-line-clamp: 2; /* 最多显示2行 */
    -webkit-box-orient: vertical;
    overflow: hidden;
}
/* --- 新增/修改：作者与时间戳同行并两端对齐的样式 --- */

/* 这是新的容器样式 */
.post-card-meta-line {
    display: flex;                /* 启用 Flex 布局 */
    justify-content: space-between; /* 核心：让内部元素两端对齐 */
    align-items: center;          /* 垂直居中，防止高低不平 */
    margin: 12px 0;               /* 保持和上下元素的间距 */
}

/* 这是修改后的作者信息样式 */
.post-author-info {
    font-size: 14px;
    color: #888;
    margin: 0; /* 移除它自己的上下边距，交给父容器管理 */
}

/* 确保时间戳本身也没有多余的边距 */
.post-item .post-meta {
    margin: 0;
}
</style>
</head>
<body>
    <div id="app-container">
        <div id="screen">
            <div id="main-screen">
                <div class="app-header">
    <div class="app-title">聊天</div>
    <div>
        <i class="fas fa-user-plus action-btn" id="add-contact-btn" title="添加联系人"></i>
        <i class="fas fa-users action-btn" id="create-group-btn" title="创建群聊" style="margin-left: 15px;"></i>
    </div>
</div>
                
                <div class="contacts-container">
                </div>
                
                <div class="bottom-nav">
                    <div class="nav-item active" id="nav-chat">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-discover">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-profile">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="chat-screen">
                <div class="chat-header">
                    <div class="back-btn" id="back-from-chat">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="chat-info">
                        <div class="chat-name" id="chat-contact-name"></div>
                        <div class="chat-status" id="chat-contact-status"></div>
                    </div>
                    <div>
                        <i class="fas fa-ellipsis-v action-btn" id="more-chat-options-btn" title="更多操作"></i>
                    </div>
                </div>
                <div id="chat-options-menu" style="display: none;">
                    <div class="chat-option-item" id="rewind-btn-menu"><i class="fas fa-undo fa-fw"></i> <span>回溯回复</span></div>
                    <div class="chat-option-item" id="summarize-chat-btn-menu"><i class="fas fa-feather-alt fa-fw"></i> <span>总结对话</span></div>
                    <div class="chat-option-item" id="toggle-chat-pet-btn-menu"><i class="fas fa-paw fa-fw"></i> <span>显示/隐藏宠物</span></div>
                    <div class="chat-option-item" id="delete-history-btn-menu"><i class="fas fa-trash-alt fa-fw"></i> <span>编辑消息</span></div>
                    <div class="chat-option-divider"></div>
                    <div class="chat-option-item" id="contact-settings-btn-menu"><i class="fas fa-cog fa-fw"></i> <span>联系人设置</span></div>
                </div>
                <div id="heart-voice-panel" style="display: none;">
    <div class="hv-item">
        <span class="hv-icon">😊</span>
        <span class="hv-label">情绪：</span>
        <span class="hv-value" id="hv-emotion"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">💭</span>
        <span class="hv-label">思绪：</span>
        <span class="hv-value" id="hv-thoughts"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">❤️</span>
        <span class="hv-label">心率：</span>
        <span class="hv-value" id="hv-heart-rate"></span>
    </div>
    <div class="hv-item">
        <span class="hv-icon">😶‍🌫️</span>
        <span class="hv-label">醋意：</span>
        <span class="hv-value" id="hv-jealousy"></span>
    </div>
</div>
                <div class="chat-messages" id="chat-messages">
                </div>
                <div id="emoticon-picker"></div>
                <div id="attachment-menu"></div>
                <div id="reply-preview-bar" style="display: none;"></div>
                <div class="chat-input-area" id="chat-input-area">
                    <div class="emoji-btn" id="emoji-btn"><i class="far fa-laugh-beam"></i></div>
                    <button class="attachment-btn" id="attachment-btn">📎</button>
                    <textarea id="message-input" placeholder="输入消息..." rows="1"></textarea>
                    <button id="send-btn" class="input-action-btn" title="发送消息"><i class="fas fa-paper-plane"></i></button>
                    <button id="request-reply-btn" class="input-action-btn" title="请求AI回复"><i class="fas fa-apple-whole"></i></button>
                </div>
                <div id="edit-mode-bar">
                    <button id="delete-selected-btn" class="edit-action-btn">删除已选</button>
                    <button id="cancel-edit-btn" class="edit-action-btn">取消</button>
                </div>
            </div>
            
            <div id="profile-screen">
                <div class="profile-header">
                    <div class="avatar-container">
                        <img src="https://via.placeholder.com/100/A0DCF8/FFFFFF?text=ME" alt="我的头像" class="profile-avatar" id="my-profile-avatar">
                        <div class="change-avatar-btn" id="change-avatar-btn">
                            <i class="fas fa-camera"></i>
                        </div>
                    </div>
                    <div class="profile-name" id="profile-name">我的名字</div>
                    <div class="profile-status" id="profile-status">在线</div>
                </div>
                
                <div class="profile-actions">
                    <div class="action-item" id="edit-status-btn">
                        <div class="action-icon">
                            <i class="fas fa-comment"></i>
                        </div>
                        <div class="action-label">我的状态</div>
                    </div>
                </div>
                
                <div class="profile-details">
                    <div class="detail-item">
                        <div class="detail-label">昵称</div>
                        <div class="detail-value" id="nickname-value">我的昵称</div>
                        <div class="edit-btn" data-field="name">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">个性签名</div>
                        <div class="detail-value" id="signature-value">我的个性签名</div>
                        <div class="edit-btn" data-field="signature">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">地区</div>
                        <div class="detail-value" id="region-value">我的地区</div>
                        <div class="edit-btn" data-field="region">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    
                    <div class="detail-item">
                        <div class="detail-label">生日</div>
                        <div class="detail-value" id="birthday-value">我的生日</div>
                        <div class="edit-btn" data-field="birthday">
                            <i class="fas fa-edit"></i>
                        </div>
                    </div>
                    <div class="detail-item" id="appearance-settings-btn" style="margin-top: 20px;">
    <div class="detail-label"><i class="fas fa-palette" style="margin-right: 8px; color: var(--theme-primary);"></i>外观设置</div>
    <div class="detail-value">背景、气泡、字体</div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>

<div class="detail-item" id="my-wallet-btn" style="margin-top: 20px;">

                        <div class="detail-label"><i class="fas fa-wallet" style="margin-right: 8px; color: var(--theme-primary);"></i>我的钱包</div>
                        <div class="detail-value" id="my-balance-value" style="color: #E6A23C; font-weight: bold;">¥ 1000.00</div>
                        <i class="fas fa-chevron-right" style="color:#999;"></i>
                    </div>
                    
                    <div class="detail-item" style="margin-top: 20px; flex-direction: column; align-items: stretch; padding: 10px; background-color: transparent; border: none; box-shadow: none;">
                        <button class="form-button" id="export-data-btn" style="margin-top: 0; margin-bottom: 10px; background-color: var(--theme-secondary);"><i class="fas fa-download"></i> 导出数据 (备份)</button>
                        <button class="form-button" id="export-light-data-btn" style="margin-top: 0; margin-bottom: 10px; background-color: #81c784;"> <i class="fas fa-feather-alt"></i> 局部导出 (仅角色与世界书) </button>
                        <button class="form-button" id="import-data-btn" style="margin-top: 0; background-color: #7f8c8d;"><i class="fas fa-upload"></i> 导入数据 (恢复)</button>
                        <input type="file" id="import-file-input" accept=".json" style="display: none;">
                    </div>
                    <div class="detail-item" style="margin-top: 10px;">
                        <button class="form-button" id="initialize-app-btn" style="background-color: #e74c3c; width: 100%;">
                            <i class="fas fa-undo"></i> 初始化应用 (清除所有数据)
                        </button>
                    </div>
                </div>
                
                <div class="bottom-nav">
                    <div class="nav-item" id="nav-chat-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-discover-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot"></div>
                        </div>
                    </div>
                    <div class="nav-item active" id="nav-profile-2">
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="char-profile-screen">
                <div class="chat-header">
                    <div class="back-btn" id="back-from-char-profile">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                     <div class="chat-info" style="font-weight: 600;"> 资料 </div>
                     <div style="width: 40px;"></div>
                </div>
                <div class="profile-details">
                    <div style="background-color: white; padding: 20px; border-radius: 10px;">
                        <div class="contact-item" style="padding: 0; border-bottom: none; align-items: flex-start;">
                             <div class="avatar-container" style="width: 70px; height: 70px; margin: 0;">
                                 <img src="" alt="联系人头像" class="profile-avatar" id="char-profile-avatar" style="width: 70px; height: 70px; border-radius: 8px;">
                                 <div class="change-avatar-btn" id="change-char-avatar-btn" style="width: 25px; height: 25px;">
                                     <i class="fas fa-camera" style="font-size: 12px;"></i>
                                 </div>
                             </div>
                             <div class="contact-info" style="margin-left: 20px;">
                                 <div id="char-profile-name" class="contact-name" style="font-size: 22px; font-weight: bold;"></div>
                                 <div id="char-profile-signature-display" class="contact-last-message" style="margin-top: 5px; white-space: normal;"></div>
                             </div>
                        </div>
                    </div>
                    
                    <div id="pet-container-wrapper"></div>
                    
                    <div class="discover-section" style="margin-top: 20px; border-radius: 10px;">
                        <div class="detail-item" id="edit-char-name-btn" style="padding:15px; background:white; border-radius: 10px 10px 0 0;">
                            <div class="detail-label">设置备注</div>
                            <div class="detail-value" id="char-name-value"></div>
                            <i class="fas fa-chevron-right" style="color:#999;"></i>
                        </div>
                         <div class="detail-item" id="edit-char-signature-btn" style="padding:15px; background:white;">
                             <div class="detail-label">设置签名</div>
                             <div class="detail-value" id="char-signature-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                         <div class="detail-item" id="view-char-diary-btn" style="padding:15px; background:white;">
                             <div class="detail-label">他的日记</div>
                             <div class="detail-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                         <div class="detail-item" id="view-memory-album-btn" style="padding:15px; background:white;">
    <div class="detail-label">我们的小窝相册</div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>

<div class="detail-item" id="view-schedule-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-calendar-alt" style="margin-right: 8px; color: #64b5f6;"></i> <b>我的课程表</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-events-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-heart" style="margin-right: 8px; color: #ec407a;"></i> <b>我们的日子</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="view-relationship-network-btn" style="padding:15px; background:white;">
    <div class="detail-label"><i class="fas fa-users" style="margin-right: 8px; color: #ff7043;"></i> <b>TA的关系网</b></div>
    <i class="fas fa-chevron-right" style="color:#999;"></i>
</div>
<div class="detail-item" id="char-more-info-btn" style="padding:15px; background:white; border-radius: 0 0 10px 10px;">
                             <div class="detail-label">更多信息</div>
                             <div class="detail-value"></div>
                             <i class="fas fa-chevron-right" style="color:#999;"></i>
                         </div>
                    </div>
                    
                    <div style="padding: 20px 0;">
                        <button class="form-button" id="delete-contact-btn" style="background-color: #e74c3c; width: 100%;">删除联系人</button>
                    </div>

                </div>
            </div>
            
            <div id="discover-screen">
                <div class="discover-header">
                    <div class="discover-title">发现</div>
                </div>
                
                <div class="discover-content">
                    <div class="discover-section">
                        <div class="discover-item" id="moments-btn">
                            <div class="discover-icon">
                                <i class="fas fa-comments"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛</div>
                                <div class="discover-desc">看看大家在聊什么</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    <div class="discover-item" id="shopping-center-btn">
                            <div class="discover-icon">
                                <i class="fas fa-shopping-bag"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">购物中心</div>
                                <div class="discover-desc">发现好物，与TA分享</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                    <div class="discover-section">
                        <div class="discover-item" id="emoticon-library-btn">
                            <div class="discover-icon">
                                <i class="far fa-grin-alt"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">表情包库</div>
                                <div class="discover-desc">管理和添加我的表情包</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="music-library-btn">
                        
                            <div class="discover-icon">
                                <i class="fas fa-music"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">音乐库</div>
                                <div class="discover-desc">管理和添加我的歌曲</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="forum-archives-btn">
                            <div class="discover-icon">
                                <i class="fas fa-archive"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛档案馆</div>
                                <div class="discover-desc">管理和切换不同的世界线</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                         <div class="discover-item" id="user-persona-presets-btn">
                            <div class="discover-icon">
                                <i class="fas fa-theater-masks"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">用户面具预设</div>
                                <div class="discover-desc">管理你在对话中的不同身份</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="world-book-btn">
                            <div class="discover-icon">
                                <i class="fas fa-book"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">世界书</div>
                                <div class="discover-desc">探索世界知识</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="thought-presets-btn">
                            <div class="discover-icon">
                                <i class="fas fa-brain"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">思维预设</div>
                                <div class="discover-desc">管理AI的“破限”模式</div>
                            </div>
                            
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>    
                            </div>
                        </div>
                        <div class="discover-item" onclick="window.open('https://www.xiaohongshu.com/user/profile/67382078000000001c01951d?xsec_token=YBfrN-IIvdSPK2t1l95UJMhWtuMLn9U_lUCIOMS1LVRDw=&xsec_source=app_share&xhsshare=CopyLink&appuid=67382078000000001c01951d&apptime=1756779911&share_id=df9cd221b1944d819f1cd87b2c9fb2ee')">
    <div class="discover-icon">
        <i class="fas fa-user-circle"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">作者主页</div>
        <div class="discover-desc">点击跳转到我的小红书</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
<div class="discover-item" id="map-management-btn">
    <div class="discover-icon">
        <i class="fas fa-map-marked-alt"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">地图管理中心</div>
        <div class="discover-desc">创建和编辑你的世界地图</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
<div class="discover-item" id="automation-btn">
    <div class="discover-icon">
        <i class="fas fa-robot"></i>
    </div>
    <div class="discover-info">
        <div class="discover-name">自动回复设置</div>
        <div class="discover-desc">让角色们自己找你聊天</div>
    </div>
    <div class="discover-arrow">
        <i class="fas fa-chevron-right"></i>
    </div>
</div>
    <div class="discover-item" id="lock-screen-photos-btn">
        <div class="discover-icon">
            <i class="fas fa-photo-video"></i>
        </div>
        <div class="discover-info">
            <div class="discover-name">锁屏相册</div>
            <div class="discover-desc">管理锁屏界面轮播的照片</div>
        </div>
        <div class="discover-arrow">
            <i class="fas fa-chevron-right"></i>
        </div>
</div>
                    </div>
                    
                    <div class="discover-section">
                         <div class="discover-item" id="square-api-settings-btn">
                            <div class="discover-icon">
                                <i class="fas fa-rss-square"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">论坛API设置</div>
                                <div class="discover-desc">为论坛帖子、评论生成配置专属API</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                        <div class="discover-item" id="api-settings-btn">
                            <div class="discover-icon">
                                <i class="fas fa-comments-dollar"></i>
                            </div>
                            <div class="discover-info">
                                <div class="discover-name">聊天API设置</div>
                                <div class="discover-desc">为聊天功能配置API</div>
                            </div>
                            <div class="discover-arrow">
                                <i class="fas fa-chevron-right"></i>
                            </div>
                        </div>
                    </div>
                </div>
                 <div class="bottom-nav">
                    <div class="nav-item" id="nav-chat-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-comment"></i></div>
                            <div>聊天</div>
                        </div>
                    </div>
                    <div class="nav-item active" id="nav-discover-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-compass"></i></div>
                            <div>发现</div>
                            <div class="notification-dot moments-notification-dot"></div>
                        </div>
                    </div>
                    <div class="nav-item" id="nav-profile-discover"> 
                        <div class="nav-item-content">
                            <div class="nav-icon"><i class="fas fa-user"></i></div>
                            <div>我</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="thought-preset-management-screen" class="preset-management-screen">
                <div class="api-header"> 
                    <div class="back-btn" id="back-from-thought-presets">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">思维预设管理</div>
                    <div class="action-btn" id="add-thought-preset-btn">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>
                <div class="api-content">
                    <div id="thought-presets-list" class="preset-list">
                    </div>
                    <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-thought-preset-message">
                        <p>还没有思维预设。</p>
                        <p>点击右上角"+"添加新的预设。</p>
                    </div>
                </div>
            </div>
            
            <div id="world-book-screen">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-world-book">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">世界书</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-world-book-btn"></i>
                    </div>
                </div>
                
                <div class="world-book-content">
                    <div class="world-book-list" id="world-book-list">
                    </div>
                </div>
            </div>

            <div id="emoticon-library-screen">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-emoticon-library">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">表情包库</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-emoticon-btn"></i>
                    </div>
                </div>
                <div class="emoticon-library-content">
                    <div class="emoticon-grid" id="emoticon-library-grid">
                    </div>
                    <div id="no-emoticon-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                        <i class="far fa-grin-alt" style="font-size: 48px; margin-bottom: 15px;"></i>
                        <p>你的表情包库是空的</p>
                        <p>点击右上角 "+" 添加你的第一个表情包吧！</p>
                    </div>
                </div>
            </div>

            <div id="music-library-screen">
                <div class="world-book-header">
                    <div class="back-btn" id="back-from-music-library">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="world-book-title">音乐库</div>
                    <div>
                        <i class="fas fa-plus action-btn" id="add-music-btn"></i>
                    </div>
                </div>
                <div class="api-content" id="music-library-content">
                    <div id="music-library-list"></div>
                    <div id="no-music-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                        <i class="fas fa-music" style="font-size: 48px; margin-bottom: 15px;"></i>
                        <p>你的音乐库是空的</p>
                        <p>点击右上角 "+" 添加你的第一首歌吧！</p>
                    </div>
                </div>
            </div>
            <div id="api-settings-screen">
                <div class="api-header">
                    <div class="back-btn" id="back-from-api">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">聊天API设置</div>
                </div>
                
                <div class="api-content">
                   <div class="form-group">
            <label class="form-label">API预设</label>
            <div class="form-group-inline">
                <select class="form-input" id="api-preset-select">
                    <option value="">-- 手动配置或选择预设 --</option>
                </select>
                <button id="manage-api-presets-btn" title="管理预设" class="form-button" style="width: auto; padding: 10px 15px; font-size: 14px; flex-shrink: 0; margin-top: 0;">
                    管理
                </button>
            </div>
        </div>
                     <div class="form-group">
                        <label class="form-label">API密钥</label>
                        <input type="password" class="form-input" id="api-key-input" placeholder="输入聊天API密钥">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">API 基础地址 (Base URL)</label>
                        <div class="form-group-inline">
                            <input type="text" class="form-input" id="api-endpoint-input" placeholder="例如: https://api.openai.com">
                            <button id="fetch-models-btn" title="拉取模型列表">
                                <i class="fas fa-sync-alt"></i> 拉取
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">模型选择</label>
                        <select class="form-input" id="model-select">
                        </select>
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">短期对话记忆条数 (当前私聊)</label>
                        <input type="number" class="form-input" id="context-length-input" value="20" min="2" max="100" title="决定AI能记住当前私聊窗口中最近的几句话。">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">长期线性记忆条数 (跨场景)</label>
                        <input type="number" class="form-input" id="long-term-memory-length-input" value="30" min="5" max="200" title="决定AI能从“统一时序记忆流”中看到多少最近的事件（包括私聊和论坛）。这是AI的核心记忆。">
                    </div>
                    <div class="form-group" style="border-top: 2px dashed #ddd; padding-top: 20px; margin-top: 20px;">
    <label class="form-label" style="font-size: 18px; font-weight: 600;">语音服务 API (MiniMax)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为语音消息和视频通话提供声音。请在 MiniMax 开放平台获取。
    </p>

    <div class="form-group">
        <label class="form-label">MiniMax Group ID</label>
        <input type="text" class="form-input" id="minimax-group-id-input" placeholder="输入你的 MiniMax Group ID">
    </div>
    
    <div class="form-group">
        <label class="form-label">MiniMax API Key</label>
        <input type="password" class="form-input" id="minimax-api-key-input" placeholder="输入你的 MiniMax API Key">
    </div>
</div>
<div class="form-group">
    <label class="form-label" style="font-size: 18px; font-weight: 600;">语音服务 API (SiliconFlow)</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        作为 MiniMax 的备选。请在硅基流动官网获取。
    </p>
    <div class="form-group">
        <label class="form-label">SiliconFlow API Key</label>
        <input type="password" class="form-input" id="siliconflow-api-key-input" placeholder="输入你的 SiliconFlow API Key">
    </div>
</div>
                    <button class="form-button" id="save-api-settings-btn">保存设置</button>
                    <button class="form-button" id="save-as-api-preset-btn" style="margin-top: 10px; background-color: var(--theme-secondary);">另存为预设</button>
                </div>
            </div>

             <div id="square-api-settings-screen">
                <div class="api-header">
                    <div class="back-btn" id="back-from-square-api">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">论坛API设置</div>
                </div>
                
                <div class="api-content">
                     <div class="form-group" style="border: 1px solid var(--theme-secondary); background: #f1f8e9;">
                        <p style="color: var(--text-gray); font-size: 14px; line-height: 1.6;">
                            此处的API配置将专门用于论坛中的内容生成，例如刷新帖子、生成AI评论回复等。如果留空，将默认使用“聊天API设置”中的配置。
                        </p>
                    </div>
                    <div class="form-group">
                        <label class="form-label">论坛专用API密钥 (可选)</label>
                        <input type="password" class="form-input" id="square-api-key-input" placeholder="输入论坛专用API密钥">
                    </div>
                    
                    <div class="form-group">
                        <label class="form-label">论坛专用API基础地址 (可选)</label>
                        <div class="form-group-inline">
                            <input type="text" class="form-input" id="square-api-endpoint-input" placeholder="输入论坛专用Base URL">
                            <button id="fetch-square-models-btn" title="拉取模型列表">
                                <i class="fas fa-sync-alt"></i> 拉取
                            </button>
                        </div>
                    </div>

                    <div class="form-group">
                        <label class="form-label">论坛专用模型选择 (可选)</label>
                        <select class="form-input" id="square-model-select">
                        </select>
                    </div>
                    <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">🎭 我的论坛身份</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">选择一个“用户面具”作为你在论坛的身份，AI会根据这个身份与你互动。</p>
            <select class="form-input" id="forum-persona-select">
                <option value="">-- 不使用特定身份 --</option>
            </select>
        </div>

        <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">📚 论坛世界观</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">选择一本或多本“世界书”来定义论坛的背景故事，所有AI内容都将基于此设定。</p>
            <div class="world-book-list" id="forum-worldbook-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                </div>
        </div>

        <div class="form-group">
            <label class="form-label" style="font-size: 16px; font-weight: 600;">🎬 论坛风格描述</label>
             <p style="font-size: 13px; color: #888; margin-bottom: 10px;">用文字告诉AI你希望论坛呈现什么样的氛围和文风。例如：“整体风格黑暗压抑，人们的对话充满谜语和不安。”</p>
            <textarea class="form-textarea" id="forum-style-description" placeholder="输入你想要的风格描述..." style="height: 100px;"></textarea>
        </div>
        <div class="form-group">
    <label class="form-label" style="font-size: 16px; font-weight: 600;">🎭 允许发帖的角色</label>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        在这里勾选的角色，AI才有权限让他们在论坛发帖。如果全部不勾选，AI将只会创建新的“路人甲”进行发言。
    </p>
    <div class="world-book-list" id="forum-allowed-posters-list" style="max-height: 150px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
        </div>
</div>
                    <button class="form-button" id="save-square-api-settings-btn">保存设置</button>
                </div>
            </div>
            
            <div id="add-world-book-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title" id="world-book-modal-title">添加世界书</div>
                        <div class="close-btn" id="close-world-book-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">书名</label>
                            <input type="text" class="form-input" id="book-name-input" placeholder="输入书名">
                        </div>
                        <div class="form-group">
                            <label class="form-label">分类 (可选)</label>
                            <input type="text" class="form-input" id="book-category-input" placeholder="例如：人物设定 (留空则为'未分类')">
                        </div>
                        <div class="form-group">
                            <label class="form-label">内容</label>
                            <textarea class="form-textarea" id="book-content-input" placeholder="输入内容..."></textarea>
                        </div>
                        
                        <button class="form-button" id="save-world-book-btn">保存</button>
                    </div>
                </div>
            </div>

            <div id="add-emoticon-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">批量添加表情包</div>
                        <div class="close-btn" id="close-emoticon-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                    </div>
                </div>
            </div>

            <div id="add-music-modal">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="add-music-modal-title">添加歌曲</div>
            <div class="close-btn" id="close-add-music-modal">
                <i class="fas fa-times"></i>
            </div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">歌曲名 (*)</label>
                <input type="text" class="contact-form-input" id="add-music-title-input" placeholder="例如：晴天">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌手 (*)</label>
                <input type="text" class="contact-form-input" id="add-music-artist-input" placeholder="例如：周杰伦">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌曲URL (*)</label>
                <input type="text" class="contact-form-input" id="add-music-url-input" placeholder="http://music.163.com/song/media/outer/url?id=....mp3">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">歌词 (LRC格式, 可选)</label>
                <textarea class="form-textarea" id="add-music-lrc-input" placeholder="将从歌词API获取的LRC文本粘贴到这里..." style="height: 100px; font-size: 12px;"></textarea>
            </div>
            <button class="form-button" id="save-music-btn">保存到音乐库</button>
        </div>
    </div>
</div>
            
            <div id="add-contact-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">添加联系人</div>
                        <div class="close-btn" id="close-contact-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">姓名</label>
                            <input type="text" class="contact-form-input" id="contact-name-input" placeholder="输入姓名">
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">人设</label>
                            <textarea class="contact-form-textarea" id="contact-persona-input" placeholder="输入人设描述..."></textarea>
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">头像URL (可选)</label>
                            <input type="text" class="contact-form-input" id="contact-avatar-input" placeholder="输入头像URL，例如：https://example.com/avatar.jpg">
                        </div>
                        
                        <div class="contact-form-group">
                            <label class="contact-form-label">关联世界书</label>
                            <select class="contact-form-select" id="world-book-select" multiple>
                            </select>
                        </div>
                        
                        <button class="form-button" id="save-contact-btn">添加联系人</button>
                    </div>
                </div>
            </div>
            
            <div id="contact-settings-screen">
                <div class="contact-settings-header">
                    <div class="back-btn" id="back-from-contact-settings">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="contact-settings-title">更多信息</div>
                </div>
                
                <div class="contact-settings-content">
                <div class="mask-editor">
                        <div class="mask-editor-title">显示设置</div>
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                            <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">在聊天中隐藏角色头像</label>
                            <label class="switch">
                                <input type="checkbox" id="hide-avatar-toggle">
                                <span class="slider round"></span>
                            </label>
                        </div>
                        <p style="font-size: 13px; color: #888; margin-top: 5px;">开启后，仅在聊天界面中不再显示该角色的头像。</p>
                    </div>
                    <div class="mask-editor">
    <div class="mask-editor-title">个性化聊天背景</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        为你们的聊天设置一张专属壁纸。
    </p>
    <div style="display: flex; gap: 10px;">
        <button class="form-button" id="upload-contact-background-btn" style="flex: 1; background-color: var(--theme-secondary);">
            <i class="fas fa-upload"></i> 上传背景
        </button>
        <button class="form-button" id="reset-contact-background-btn" style="flex: 1; background-color: #7f8c8d;">
            <i class="fas fa-undo"></i> 恢复默认
        </button>
    </div>
</div>

<div class="mask-editor">
    <div class="mask-editor-title">自定义我的头像</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 15px;">
        仅在此聊天中，将“我”的头像显示为特定样式。
    </p>
    <div style="text-align: center; margin-bottom: 15px;">
        <img id="custom-user-avatar-preview" src="" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none;">
    </div>
    <div style="display: flex; gap: 10px;">
        <button class="form-button" id="upload-contact-user-avatar-btn" style="flex: 1; background-color: var(--theme-secondary);">
            <i class="fas fa-camera"></i> 上传头像
        </button>
        <button class="form-button" id="reset-contact-user-avatar-btn" style="flex: 1; background-color: #7f8c8d;">
            <i class="fas fa-undo"></i> 恢复默认
        </button>
    </div>
</div>
<div class="mask-editor">
    <div class="mask-editor-title">语音声线设置</div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">语音服务商</label>
        <select class="form-input" id="char-voice-provider-select">
            <option value="">-- 不使用语音 --</option>
            <option value="minimax">MiniMax</option>
            <option value="siliconflow">硅基流动 (SiliconFlow)</option>
        </select>
    </div>
    <div class="mask-editor-group">
        <label class="mask-editor-label">音色 ID (Voice ID)</label>
        <input type="text" class="form-input" id="char-voice-id-input" placeholder="选择服务商后，在此粘贴对应的音色ID">
    </div>
    <p style="font-size: 13px; color: #888; margin-top: 10px;">
        请前往所选服务商的开放平台获取音色ID。
    </p>
</div>
                    <div class="user-mask-editor">
                        <div class="user-mask-title">用户面具设置</div>
                        <div class="mask-editor-group">
                            <label class="mask-editor-label">用户面具描述</label>
                            <textarea class="user-mask-textarea" id="user-mask-textarea" placeholder="描述你在这个对话中扮演的角色..."></textarea>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-bottom: 20px;">
                        <label class="form-label">选择预设面具</label>
                        <select class="form-input" id="select-user-persona-preset">
                            <option value="">-- 选择或输入自定义面具 --</option>
                        </select>
                    </div>

                    <div class="mask-editor">
    <div class="mask-editor-title">对话模式</div>
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
        <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">叙事模式 (单气泡长回复)</label>
        <label class="switch">
            <input type="checkbox" id="narrative-mode-toggle">
            <span class="slider round"></span>
        </label>
    </div>
</div>

                   <div class="mask-editor">
    <div class="mask-editor-title">时间感知</div>
    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
        <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">允许TA感知现实时间</label>
        <label class="switch">
            <input type="checkbox" id="time-awareness-toggle">
            <span class="slider round"></span>
        </label>
    </div>
    <p style="font-size: 13px; color: #888; margin-top: 5px;">开启后，TA会知道当前的真实日期和时间，并可能在对话中提及（如“早上好”、“深夜了”等）。</p>
</div>
                     <div class="mask-editor">
                        <div class="mask-editor-title">联系人面具设置</div>
                        <div class="mask-editor-group">
                            <label class="mask-editor-label">联系人面具描述</label>
                            <textarea class="mask-editor-textarea" id="char-mask-textarea" placeholder="描述这个联系人的角色设定..."></textarea>
                        </div>
                    </div>

                    <div class="form-group" style="background-color: white; border-radius: 10px; padding: 15px; margin-bottom: 15px; margin-top:-5px;">
                        <label class="form-label">思维预设 (破限模式)</label>
                        <select class="form-input" id="thought-preset-select">
                        </select>
                    </div>
                    
                    <div class="world-book-selector">
                        <div class="world-book-selector-title">关联世界书</div>
                        <div class="world-book-list" id="world-book-selector-list">
                        </div>
                        <div class="world-book-selector" style="margin-top: 15px;">
    <div class="world-book-selector-title">关联地图</div>
    <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
        为该角色选择一张主活动地图。AI会基于此地图信息进行对话。
    </p>
    <select class="form-input" id="contact-map-select">
        <option value="">-- 不关联任何地图 --</option>
        </select>
</div>
                    </div>
                    
                    <button class="save-settings-btn" id="save-contact-settings-btn">保存设置</button>
                    <button class="save-settings-btn" id="clear-chat-history-btn" style="background-color: #e74c3c; margin-top: 15px;">清空聊天记录</button>
                </div>
            </div>

            <div id="moments-screen">
                <div class="moments-header">
                <div id="feed-status-indicator" style="display: none;"></div>
                    <div class="back-btn" id="back-from-moments">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="moments-title">论坛</div>
                    <div class="header-actions">
                        <i class="fas fa-sync-alt action-btn" id="refresh-feed-btn" title="刷新"></i>
                        <i class="fas fa-plus-circle action-btn" id="post-moment-btn" title="发布动态"></i>
                    </div>
                </div>
                <div id="feed-tabs-container" class="feed-tabs"></div>
                <div id="feed-sub-tabs-container" class="feed-sub-tabs" style="display: none;"></div>
                <div class="moments-content" id="moments-content">
                    <div class="posts-list" id="posts-list"></div>
                </div>
            </div>

            <div id="post-detail-screen">
                <div class="moments-header">
                    <div class="back-btn" id="back-from-post-detail"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title">帖子详情</div>
                    <div class="header-actions">
                        <i class="fas fa-sync-alt action-btn" id="refresh-post-comments-btn" title="刷新评论"></i>
                    </div>
                </div>
                <div class="post-detail-content">
                    <div id="post-detail-container"></div>
                    <div class="comments-section">
                        <div class="comments-title">全部评论</div>
                        <div id="comments-list"></div>
                    </div>
                </div>
                <div class="comment-input-area">
                    <input type="text" id="comment-input" placeholder="留下你的精彩评论吧...">
                    <button id="submit-comment-btn">发送</button>
                </div>
            </div>

            <div id="trending-topic-screen">
                 <div class="moments-header">
                    <div class="back-btn" id="back-from-trending-topic"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title" id="trending-topic-title">话题区</div>
                    <div style="width: 40px;"></div>
                </div>
                <div class="moments-content">
                    <div id="trending-topic-description-container" style="display: none;"></div>
                    <div class="posts-list" id="trending-topic-posts-list"></div>
                </div>
            </div>
            
            <div id="diary-screen">
                <div class="moments-header">
                    <div class="back-btn" id="back-from-diary">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="moments-title" id="diary-title">他的日记</div>
                </div>
                <div class="diary-content" id="diary-content-list">
                    </div>
            </div>

            <div id="memory-album-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
                <div class="moments-header">
                    <div class="back-btn" id="back-from-memory-album"><i class="fas fa-arrow-left"></i></div>
                    <div class="moments-title">小窝相册</div>
                </div>
                <div class="diary-content" id="memory-album-list">
                    </div>
            </div>

            <div id="post-moment-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发布动态</div>
                        <div class="close-btn" id="close-post-moment-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group" style="padding:0; box-shadow:none; border:none;">
                            <textarea class="form-textarea" id="moment-content-input" placeholder="有什么新鲜事想分享？"></textarea>
                        </div>
                         <div class="form-group" style="padding:0; box-shadow:none; border:none;">
                             <label class="form-label">选择板块</label>
                             <select id="post-category-select" class="form-input">
                                 <option value="daily">日常</option>
                                 <option value="food">美食</option>
                                 <option value="gossip">八卦</option>
                                 <option value="horror">恐怖</option>
                             </select>
                         </div>
                        <div class="moment-extra-actions">
                            <i class="fas fa-wallet moment-action-btn" id="add-post-red-packet-btn" title="添加红包"></i>
                        </div>
                        <button class="form-button" id="publish-moment-btn">发布</button>
                    </div>
                </div>
            </div>         
            
            <div id="user-persona-management-screen" class="preset-management-screen">
                <div class="api-header">
                    <div class="back-btn" id="back-from-user-persona-management">
                        <i class="fas fa-arrow-left"></i>
                    </div>
                    <div class="api-title">用户面具预设</div>
                    <div class="action-btn" id="add-user-persona-preset-btn">
                        <i class="fas fa-plus"></i>
                    </div>
                </div>
                <div class="api-content">
                    <div id="user-persona-presets-list" class="preset-list">
                    </div>
                    <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-user-persona-message">
                        <p>还没有用户面具预设。</p>
                        <p>点击右上角"+"添加新的面具。</p>
                    </div>
                </div>
            </div>
            <div id="automation-screen" class="preset-management-screen">
    <div class="api-header">
        <div class="back-btn" id="back-from-automation">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">自动回复设置</div>
        <div style="width: 40px;"></div>
    </div>
    <div class="api-content">
        <div class="form-group">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <label class="form-label" style="margin-bottom: 0; font-size: 16px; font-weight: 600;">启用自动回复</label>
                <label class="switch">
                    <input type="checkbox" id="automation-enabled-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <p id="automation-status-indicator" style="font-size: 13px; color: #888; margin-top: 10px; text-align: center;">
                当前已关闭
            </p>
        </div>

        <div class="form-group">
            <label class="form-label">检查间隔 (秒)</label>
            <input type="number" class="form-input" id="automation-interval-input" value="300" min="30">
            <p style="font-size: 13px; color: #888; margin-top: 5px;">建议设置不低于60秒，以免API调用过于频繁。</p>
        </div>
        
        <div class="form-group">
            <label class="form-label">每次随机回复人数</label>
            <div style="display: flex; gap: 15px; align-items: center;">
                <span>最少</span>
                <input type="number" class="form-input" id="automation-min-replies-input" value="1" min="1" style="width: 60px; text-align: center;">
                <span>最多</span>
                <input type="number" class="form-input" id="automation-max-replies-input" value="2" min="1" style="width: 60px; text-align: center;">
                <span>人</span>
            </div>
        </div>

        <div class="form-group">
            <label class="form-label">选择参与自动回复的角色</label>
            <div class="world-book-list" id="automation-contact-list" style="max-height: 250px; overflow-y: auto; border: 1px solid #eee; border-radius: 8px; padding: 10px;">
                </div>
        </div>

        <button class="form-button" id="save-automation-settings-btn">保存设置</button>
    </div>
</div>

            <div id="user-persona-preset-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title" id="user-persona-modal-title">添加用户面具预设</div>
                        <div class="close-btn" id="close-user-persona-preset-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">面具名称</label>
                            <input type="text" class="form-input" id="user-persona-name-input" placeholder="例如：程序员，历史爱好者">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">面具描述</label>
                            <textarea class="form-textarea" id="user-persona-description-input" placeholder="详细描述你扮演的角色，例如：你是一个经验丰富的软件工程师..."></textarea>
                        </div>
                        
                        <button class="form-button" id="save-user-persona-preset-btn">保存</button>
                    </div>
                </div>
            </div>
            
            <div id="api-preset-management-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-api-presets">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">API预设管理</div>
        <div style="width: 40px;"></div> </div>
    <div class="api-content">
        <div id="api-presets-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-api-preset-message">
            <p>还没有任何API预设。</p>
            <p>在“聊天API设置”页面配置好后，点击“另存为预设”来创建你的第一个预设吧！</p>
        </div>
    </div>
</div>

            <div id="thought-preset-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title" id="thought-preset-modal-title">添加思维预设</div>
                        <div class="close-btn" id="close-thought-preset-modal">
                            <i class="fas fa-times"></i>
                        </div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label class="form-label">预设名称</label>
                            <input type="text" class="form-input" id="thought-preset-name-input" placeholder="例如：深度角色扮演">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label">预设指令 (Prompt)</label>
                            <textarea class="form-textarea" id="thought-preset-prompt-input" placeholder="详细描述AI需要遵守的思维规则..."></textarea>
                        </div>
                        
                        <button class="form-button" id="save-thought-preset-btn">保存</button>
                    </div>
                </div>
            </div>
            
            <div id="send-picture-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发送图片</div>
                        <div class="close-btn" id="close-send-picture-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group" style="padding:0; background:none;">
                            <label class="form-label">图片描述</label>
                            <textarea class="form-textarea" id="send-picture-description-input" placeholder="由于是模拟，请输入图片的文字描述..." style="height: 120px;"></textarea>
                        </div>
                        <button class="form-button" id="confirm-send-picture-btn">发送</button>
                    </div>
                </div>
            </div>

            <div id="send-voice-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发送语音</div>
                        <div class="close-btn" id="close-send-voice-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="form-group" style="padding:0; background:none;">
                            <label class="form-label">语音内容</label>
                            <textarea class="form-textarea" id="send-voice-text-input" placeholder="请输入您想通过语音发送的文字..." style="height: 120px;"></textarea>
                        </div>
                        <button class="form-button" id="confirm-send-voice-btn">发送</button>
                    </div>
                </div>
            </div>

            <div id="send-red-packet-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">发红包</div>
                        <div class="close-btn" id="close-send-red-packet-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">金额 (元)</label>
                            <input type="number" class="contact-form-input" id="send-red-packet-amount-input" placeholder="0.00">
                        </div>
                        <div class="contact-form-group">
                            <label class="contact-form-label">祝福语 (可选)</label>
                            <input type="text" class="contact-form-input" id="send-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
                        </div>
                        <button class="form-button" id="confirm-send-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
                    </div>
                </div>
            </div>

            <div id="send-transfer-modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title">转账</div>
                        <div class="close-btn" id="close-send-transfer-modal">&times;</div>
                    </div>
                    <div class="modal-body">
                        <div class="contact-form-group">
                            <label class="contact-form-label">转账金额 (元)</label>
                            <input type="number" class="contact-form-input" id="send-transfer-amount-input" placeholder="0.00">
                        </div>
                        <button class="form-button" id="confirm-send-transfer-btn">转账</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="chat-pet-container" style="display: none; position: fixed; z-index: 999; cursor: move; bottom: 80px; left: 20px;">
        <div class="slime">
     <div class="blush left"></div>
     <span class="mouth"></span> <div class="blush right"></div>
</div>
        <div class="slime-shadow"></div>
    </div>

    <input type="file" id="moments-bg-upload" accept="image/*" style="display: none;">

    <div id="red-packet-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div id="red-packet-content" style="background-color: #DB5A48; width: 85%; max-width: 300px; border-radius: 10px; text-align: center; color: #FADFC6; position: relative; padding-bottom: 30px;">
            <div id="close-red-packet-modal" style="position: absolute; top: 10px; left: 15px; font-size: 24px; color: #FADFC6; cursor: pointer;">&times;</div>
            <div style="padding: 40px 0 20px;">
                <img id="red-packet-sender-avatar" src="" style="width: 50px; height: 50px; border-radius: 6px; margin-bottom: 10px;">
                <div id="red-packet-sender-name" style="font-size: 16px;"></div>
                <div id="red-packet-blessing-text" style="font-size: 22px; margin-top: 15px; font-weight: bold; padding: 0 20px;">恭喜发财，大吉大利！</div>
            </div>
            <div id="open-red-packet-btn" style="background-color: #FADDC4; width: 80px; height: 80px; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto; color: #C35645; font-size: 50px; font-weight: bold; cursor: pointer; transform: rotate(0deg); transition: transform 0.5s ease;">开</div>
            <div id="red-packet-result" style="display: none; padding-top: 20px;">
                <div id="red-packet-amount-text" style="font-size: 40px; font-weight: bold; color: white;"></div>
                <div id="red-packet-collected-by" style="font-size: 14px; margin-top: 10px;"></div>
                <a id="view-red-packet-details" href="#" style="font-size: 12px; color: #FADFC4; text-decoration: none; margin-top: 15px; display: inline-block;">查看领取详情 &gt;</a>
            </div>
        </div>
    </div>
    <input type="file" id="avatar-uploader" accept="image/*" style="display: none;">

    <div id="transfer-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); z-index: 200;">
        <div class="modal-content" style="max-width: 320px; background-color: #f7f9f9;">
            <div class="modal-header">
                <div class="modal-title" id="transfer-modal-title">转账</div>
                <div class="close-btn" id="close-transfer-modal">&times;</div>
            </div>
            <div class="modal-body">
                <div id="transfer-confirm-view">
                    <div class="transfer-sender-profile">
                        <img id="transfer-sender-avatar" src="" class="transfer-sender-avatar">
                        <div class="transfer-sender-info">
                            <div class="transfer-sender-name" id="transfer-sender-name"></div>
                            <div class="transfer-recipient-name" id="transfer-recipient-text"></div>
                        </div>
                    </div>
                    <div class="transfer-amount-display">
                        <span>¥</span><span id="transfer-amount-value"></span>
                    </div>
                    <div class="transfer-action-area">
                        <button id="confirm-transfer-btn" class="form-button">确认收款</button>
                        <button id="return-transfer-btn" class="form-button">退还</button>
                    </div>
                </div>
                <div id="transfer-status-view" style="display: none;">
                    <div class="transfer-amount-display">
                        <span>¥</span><span id="transfer-status-amount-value"></span>
                    </div>
                    <div class="transfer-status-info">
                        <i id="transfer-status-icon" class="fas fa-check-circle"></i>
                        <span id="transfer-status-text">已收款</span>
                    </div>
                    <div id="transfer-status-sender-info" class="transfer-status-subtext"></div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="wallet-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
        <div class="api-header"> 
            <div class="back-btn" id="back-from-wallet">
                <i class="fas fa-arrow-left"></i>
            </div>
            <div class="api-title">收支明细</div>
            <div style="width:40px;"></div>
        </div>
        <div class="api-content" style="padding: 0;">
            <div id="transaction-list">
                </div>
            <div id="no-transaction-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
                <p>还没有任何收支记录哦。</p>
            </div>
        </div>
    </div>

    <audio id="global-audio-player"></audio>
    <audio id="voice-message-player"></audio>
<div id="send-music-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content" style="height: 75%; max-height: 600px; display: flex; flex-direction: column;">
        <div class="modal-header">
            <div class="modal-title">分享音乐</div>
            <div class="close-btn" id="close-send-music-modal">&times;</div>
        </div>
        <div class="modal-body" style="display: flex; flex-direction: column; overflow: hidden; padding: 10px 20px;">
            
            <div class="feed-tabs" id="music-share-tabs" style="flex-shrink: 0;">
                <button class="feed-tab-btn active" data-tab="search"><i class="fas fa-search"></i> 在线搜索</button>
                <button class="feed-tab-btn" data-tab="library"><i class="fas fa-music"></i> 从曲库选择</button>
                <button class="feed-tab-btn" data-tab="manual"><i class="fas fa-edit"></i> 手动输入</button>
            </div>

            <div id="music-share-tab-content" style="flex-grow: 1; overflow-y: auto; padding-top: 15px;">
                <div id="music-tab-search">
                    <div class="form-group-inline">
                        <input type="search" class="form-input" id="online-music-search-input" placeholder="输入歌曲名或歌手...">
                        <button id="online-music-search-btn" class="form-button" style="width: auto; padding: 10px 15px; margin-top: 0;"><i class="fas fa-search"></i></button>
                    </div>
                    <div id="online-music-search-results" style="margin-top: 10px;"></div>
                </div>

                <div id="music-tab-library" style="display: none;">
                    </div>

                <div id="music-tab-manual" style="display: none;">
                    <div class="contact-form-group">
                        <label class="contact-form-label">歌曲URL (*)</label>
                        <input type="text" class="contact-form-input" id="manual-music-url-input" placeholder="http://.../song.mp3">
                    </div>
                    <div class="contact-form-group">
                        <label class="contact-form-label">歌曲名 (*)</label>
                        <input type="text" class="contact-form-input" id="manual-music-title-input" placeholder="例如：晴天">
                    </div>
                    <div class="contact-form-group">
                        <label class="contact-form-label">歌手</label>
                        <input type="text" class="contact-form-input" id="manual-music-artist-input" placeholder="例如：周杰伦">
                    </div>
                     <div class="contact-form-group">
                        <label class="contact-form-label">歌词 (LRC格式, 可选)</label>
                        <textarea class="form-textarea" id="manual-music-lrc-input" placeholder="粘贴从API获取的LRC文本..." style="height: 100px; font-size: 12px;"></textarea>
                    </div>
                    <button class="form-button" id="confirm-manual-share-btn" style="margin-top: 10px;">分享</button>
                </div>
            </div>
            
            <div style="display: flex; align-items: center; margin-top: 10px; flex-shrink: 0; border-top: 1px solid #eee; padding-top: 10px;">
                <input type="checkbox" id="notify-ai-checkbox" checked style="margin-right: 10px;">
                <label for="notify-ai-checkbox" style="color: #666;">通知对方并邀请评论</label>
            </div>
        </div>
    </div>
</div>
    <div id="create-forum-red-packet-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">在帖子中添加红包</div>
                <div class="close-btn" id="close-forum-red-packet-modal">&times;</div>
            </div>
            <div class="modal-body">
                <div class="contact-form-group">
                    <label class="contact-form-label">总金额 (元)</label>
                    <input type="number" class="contact-form-input" id="forum-red-packet-amount-input" placeholder="0.00">
                </div>
                <div class="contact-form-group">
                    <label class="contact-form-label">红包个数</label>
                    <input type="number" class="contact-form-input" id="forum-red-packet-count-input" placeholder="填写个数，比如10">
                </div>
                <div class="contact-form-group">
                    <label class="contact-form-label">祝福语 (可选)</label>
                    <input type="text" class="contact-form-input" id="forum-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
                </div>
                <button class="form-button" id="confirm-forum-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
            </div>
        </div>
    </div>

    <div id="repost-contact-picker-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">转发给</div>
                <div class="close-btn" id="close-repost-modal">&times;</div>
            </div>
            <div class="modal-body">
                <div class="contact-picker-list" id="repost-contact-list"></div>
                <div class="contact-form-group">
                    <label class="contact-form-label">留言 (可选)</label>
                    <input type="text" class="contact-form-input" id="repost-message-input" placeholder="说点什么吧...">
                </div>
                <button class="form-button" id="confirm-repost-btn">发送</button>
            </div>
        </div>
    </div>
    <div id="custom-prompt-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="custom-prompt-title">修改信息</div>
            </div>
            <div class="modal-body">
                <div class="contact-form-group">
                    <input type="text" class="contact-form-input" id="custom-prompt-input">
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="form-button" id="custom-prompt-cancel-btn" style="background-color: #bdc3c7; flex: 1;">取消</button>
                    <button class="form-button" id="custom-prompt-confirm-btn" style="flex: 1;">确定</button>
                </div>
            </div>
        </div>
    </div>

    <div id="custom-confirm-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 300;">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="custom-confirm-title">请确认</div>
            </div>
            <div class="modal-body">
                <p id="custom-confirm-text" style="line-height: 1.6; font-size: 16px; margin-bottom: 20px;"></p>
                <div style="display: flex; gap: 10px;">
                    <button class="form-button" id="custom-confirm-cancel-btn" style="background-color: #bdc3c7; flex: 1;">取消</button>
                    <button class="form-button" id="custom-confirm-confirm-btn" style="flex: 1;">确定</button>
                </div>
            </div>
        </div>
    </div>
   
     <div id="music-player-card" style="display: none;">
        <div class="player-header" id="player-header">
            <i class="fas fa-chevron-down player-collapse-btn" id="player-collapse-btn"></i>
            <span class="player-header-title">一起听歌中</span>
            <div class="header-collapsed-content">
                <div class="header-avatar-stack">
                    <img id="header-user-avatar" class="header-avatar">
                    <img id="header-contact-avatar" class="header-avatar">
                </div>
                <span id="header-lyric" class="header-lyric">...</span>
            </div>
            <i class="fas fa-times" id="player-close-btn"></i>
        </div>
        
        <div class="player-main-content">
            <div class="player-avatar-stack" id="player-avatar-stack">
                <img id="player-user-avatar" class="player-avatar">
                <img id="player-contact-avatar" class="player-avatar">
            </div>
            <div class="player-song-info">
                <div id="player-title" class="player-title"></div>
                <div id="player-artist" class="player-artist"></div>
            </div>
            <div class="lyrics-container" id="lyrics-container">
                <div class="lyrics-wrapper" id="lyrics-wrapper"></div>
            </div>
            <div class="player-controls-wrapper">
                <div class="player-progress-bar-wrapper">
                    <span id="player-current-time">00:00</span>
                    <div class="player-progress-bar" id="player-progress-bar">
                        <div class="player-progress" id="player-progress"></div>
                    </div>
                    <span id="player-duration">00:00</span>
                </div>
                <div class="player-controls">
                    <i class="fas fa-repeat player-control-btn" id="player-mode-btn" title="列表循环"></i>
                    <i class="fas fa-backward-step player-control-btn" id="player-prev-btn"></i>
                    <i class="fas fa-play-circle player-control-btn player-play-btn" id="player-play-btn"></i>
                    <i class="fas fa-forward-step player-control-btn" id="player-next-btn"></i>
                    <i class="fas fa-list-ul player-control-btn" id="player-playlist-btn" title="播放列表"></i>
                </div>
            </div>
        </div>

        <div class="player-playlist-view" id="player-playlist-view">
            <ul id="playlist-list" style="list-style: none; margin: 0; padding: 0;"></ul>
        </div>
    </div>
    <div id="red-packet-details-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 250;">
        <div class="modal-content" style="max-width: 340px; background-color: #f7f9f9;">
            <div class="modal-header" style="background-color: #f7f9f9; color: var(--text-dark); border-bottom: 1px solid #eee;">
                <div class="modal-title" id="red-packet-details-title">红包详情</div>
                <div class="close-btn" id="close-red-packet-details-modal">&times;</div>
            </div>
            <div class="modal-body" style="padding: 0; max-height: 400px; overflow-y: auto;">
                <div id="red-packet-details-header" style="text-align: center; padding: 20px; border-bottom: 1px solid #eee;">
                    <img id="details-sender-avatar" src="" style="width: 60px; height: 60px; border-radius: 8px; margin-bottom: 10px;">
                    <div id="details-sender-name" style="font-weight: 600;"></div>
                    <div id="details-blessing" style="color: var(--text-gray); margin-top: 5px; font-size: 14px;"></div>
                </div>
                <div id="red-packet-details-summary" style="font-size: 14px; color: var(--text-gray); padding: 10px 15px; background-color: #f0f2f5;"></div>
                <div id="red-packet-claimer-list">
                    </div>
            </div>
        </div>
    </div>
    <div id="appearance-settings-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header"> 
        <div class="back-btn" id="back-from-appearance-settings">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">自由外观设置</div>
        <div style="width:40px;"></div>
    </div>
    <div class="api-content">
            <div class="form-group">
            <label class="form-label">自动锁屏延迟 (秒)</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">
                当程序在此时间内无任何操作，将自动显示锁屏。填 0 则禁用此功能。
            </p>
            <input type="number" class="form-input" id="auto-lock-delay-input" placeholder="例如: 60">
        </div>
        <div class="form-group">
            <label class="form-label">自定义聊天背景</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">从你的设备上传一张图片作为背景。</p>
            <button class="form-button" id="upload-background-btn" style="background-color: var(--theme-secondary); margin-bottom: 10px;">
                <i class="fas fa-upload"></i> 上传本地图片
            </button>
            <button class="form-button" id="reset-background-btn" style="background-color: #7f8c8d;">
                <i class="fas fa-undo"></i> 恢复默认背景
            </button>
            <input type="file" id="background-file-input" accept="image/*" style="display: none;">
        </div>

        <div class="form-group">
            <label class="form-label">自定义气泡CSS</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此粘贴CSS代码来定义气泡样式。留空则使用默认样式。</p>
            <textarea class="form-textarea" id="bubble-css-input" placeholder="例如：&#10;.message.sent {&#10;  background: #333 !important;&#10;  color: #fff !important;&#10;  border-radius: 20px 20px 0 20px !important;&#10;}" style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
        </div>

        <div class="form-group">
            <label class="form-label">自定义主题CSS</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此粘贴CSS代码来定义整体主题。你可以修改颜色、图标等任何样式。</p>
            <textarea class="form-textarea" id="theme-css-input" placeholder="在此输入你的自定义主题CSS..." style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
        </div>
        <div class="form-group">
        <label class="form-label">自定义叙事模式CSS (可选)</label>
        <p style="font-size: 13px; color: #888; margin-bottom: 10px;">在此处输入样式可覆盖默认效果。清空则恢复默认。</p>
        <textarea class="form-textarea" id="narrative-css-input" placeholder="/* 默认样式参考 */&#10;.narrative-psychology { color: #66bb6a; }&#10;.narrative-action { color: #517655; }" style="height: 150px; font-family: monospace; font-size: 12px;"></textarea>
    </div>
        <div class="form-group">
            <label class="form-label">自定义字体URL</label>
            <p style="font-size: 13px; color: #888; margin-bottom: 10px;">输入 `.ttf`, `.woff`, 或 `.woff2` 格式的字体文件链接。</p>
            <input type="text" class="form-input" id="font-url-input" placeholder="例如：https://.../myfont.woff2">
            <p style="font-size: 13px; color: #888; margin-top: 10px;">为上面的字体指定一个CSS名称（仅英文）。</p>
            <input type="text" class="form-input" id="font-name-input" placeholder="例如：MyCustomFont" style="margin-top: 5px;">
        </div>
        <div class="form-group">
        <label class="form-label">全局字体大小 (px)</label>
        <p style="font-size: 13px; color: #888; margin-bottom: 10px;">调整应用内大部分文字的大小。推荐范围 13-18。</p>
        <input type="number" class="form-input" id="font-size-input" placeholder="默认 15" step="0.5" min="12" max="20">
    </div>

        <button class="form-button" id="save-appearance-btn" style="margin-top: 20px;">应用并保存设置</button>
    </div>
</div>

<div id="create-wheel-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">创建转盘游戏</div>
            <div class.="close-btn" id="close-create-wheel-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">转盘名称</label>
                <input type="text" class="contact-form-input" id="wheel-name-input" placeholder="例如：今天吃什么？">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">转盘选项</label>
                <div id="wheel-options-container">
                    </div>
                <button class="form-button" id="add-wheel-option-btn" style="margin-top: 10px; background-color: var(--theme-secondary);">+ 添加选项</button>
            </div>
            <button class="form-button" id="confirm-send-wheel-btn">发起转盘</button>
        </div>
    </div>
</div>
<div id="incoming-call-screen">
    <div>
        <img id="incoming-caller-avatar" src="" style="width: 100px; height: 100px; border-radius: 50%; border: 3px solid white; margin-bottom: 15px;">
        <div id="incoming-caller-name" style="font-size: 24px; font-weight: 600;"></div>
        <div style="font-size: 16px; margin-top: 10px;">邀请你进行视频通话...</div>
    </div>
    <div style="width: 100%; display: flex; justify-content: space-around; padding: 0 40px;">
        <div id="decline-call-btn" style="cursor: pointer;">
            <div style="width: 70px; height: 70px; background-color: var(--soft-red); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 30px;"><i class="fas fa-phone-slash"></i></div>
            <div style="margin-top: 10px;">拒绝</div>
        </div>
        <div id="accept-call-btn" style="cursor: pointer;">
            <div style="width: 70px; height: 70px; background-color: var(--theme-primary); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 30px;"><i class="fas fa-video"></i></div>
            <div style="margin-top: 10px;">接听</div>
        </div>
    </div>
</div>

<div id="video-call-screen">
    <div class="video-call-card-content">
        <div class="video-call-header">
            <span id="call-contact-name"></span>
            <span id="call-status"></span>
        </div>
        <div class="video-call-main">
            <div class="narrative-feed" id="narrative-feed"></div>
        </div>
        <div class="video-call-input-area">
            <textarea id="video-call-input" placeholder="输入你的回应..." rows="1"></textarea>
            <button id="video-call-send-btn"><i class="fas fa-paper-plane"></i></button>
        </div>
        <div class="video-call-controls">
            <div class="control-btn hang-up" id="hang-up-btn" style="margin: 0 auto;"><i class="fas fa-phone-slash"></i><span>挂断</span></div>
        </div>
    </div>
</div>
<div id="shopping-screen" style="display: none; flex-direction: column;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-shopping">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="moments-title">购物中心</div>
        <div class="header-actions">
            <i class="fas fa-sync-alt action-btn" id="refresh-products-btn" title="刷新"></i>
        </div>
    </div>
    <div class="comment-input-area" style="border-top: none; border-bottom: 1px solid #ddd; padding: 8px 15px;">
        <input type="search" id="product-search-input" placeholder="搜索商品..." style="border-radius: 18px; flex-grow: 1; border: 1px solid #ddd; padding: 8px 15px; font-size: 15px;">
        <button id="product-search-btn" style="background-color: var(--theme-primary); color: white; border: none; border-radius: 18px; padding: 8px 20px; margin-left: 10px; font-weight: 600; cursor: pointer;">搜索</button>
    </div>
    <div id="shopping-tabs-container" class="feed-tabs"></div>
    <div class="moments-content" id="shopping-content">
        <div class="product-list" id="product-list">
            </div>
    </div>
</div>

<div id="share-product-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">分享商品给</div>
            <div class="close-btn" id="close-share-product-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div id="share-product-info" style="padding: 10px; background: #f9f9f9; border-radius: 8px; margin-bottom: 15px; text-align: center;"></div>
            
            <div class="contact-picker-list" id="share-product-recipient-list" style="max-height: 150px; overflow-y: auto; margin-bottom: 15px;">
                </div>
            
            <div class="contact-form-group">
                <label class="contact-form-label">附言 (可选)</label>
                <input type="text" class="contact-form-input" id="share-product-message-input" placeholder="可以跟TA说句话...">
            </div>
            
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="form-button" id="gift-product-btn" style="flex: 1; background-color: #e67e22;">送给他/她</button>
                <button class="form-button" id="request-payment-btn" style="flex: 1; background-color: #3498db;">请他/她付款</button>
            </div>
        </div>
    </div>
</div>
<div id="schedule-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-schedule"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title" id="schedule-title">我的课程表</div>
        <div class="header-actions">
            <i class="fas fa-plus action-btn" id="add-schedule-item-btn" title="添加课程"></i>
        </div>
    </div>
    <div class="diary-content" id="schedule-content-list">
        </div>
</div>

<div id="events-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-events"><i class="fas fa-arrow-left"></i></div>
        <div class="moments-title" id="events-title">我们的日子</div>
        <div class="header-actions">
            <i class="fas fa-plus action-btn" id="add-event-item-btn" title="添加新事件"></i>
        </div>
    </div>
    <div class="diary-content" id="events-content-list">
        </div>
</div>
<div id="create-group-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">创建群聊</div>
            <div class="close-btn" id="close-create-group-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">群聊名称</label>
                <input type="text" class="contact-form-input" id="group-name-input" placeholder="为你的群聊起个名字">
            </div>
            <label class="contact-form-label">选择成员 (至少2位)</label>
            <div class="contact-picker-list" id="group-member-picker-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <button class="form-button" id="confirm-create-group-btn" style="margin-top: 15px;">创建</button>
        </div>
    </div>
</div>
<div id="group-settings-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header"> 
        <div class="back-btn" id="back-from-group-settings">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">群聊设置</div>
        <button id="save-group-settings-btn" class="form-button" style="width: auto; padding: 6px 15px; font-size: 14px; margin-right: 10px;">保存</button>
    </div>
    <div class="api-content" style="padding: 20px;">
        
        <div class="user-mask-editor">
            <div class="user-mask-title">我的面具 (在此群聊中)</div>
            <div class="mask-editor-group">
                <label class="mask-editor-label">面具描述</label>
                <textarea class="user-mask-textarea" id="group-user-mask-textarea" placeholder="描述你在这个群聊中扮演的角色..."></textarea>
            </div>
        </div>
        <div class="form-group" style="margin-bottom: 20px;">
            <label class="form-label">选择预设面具</label>
            <select class="form-input" id="group-select-user-persona-preset">
                <option value="">-- 选择或输入自定义面具 --</option>
            </select>
        </div>

        <div class="mask-editor">
            <div class="mask-editor-title">高级设置</div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0;">
                <label class="form-label" style="margin-bottom: 0; font-size: 16px; color: #333; font-weight: 500;">允许群成员感知现实时间</label>
                <label class="switch">
                    <input type="checkbox" id="group-time-awareness-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 0; border-top: 1px solid #f0f0f0;">
                <div class="detail-label">私聊与群聊记忆互通</div>
                <label class="switch">
                    <input type="checkbox" id="group-memory-share-toggle">
                    <span class="slider round"></span>
                </label>
            </div>
        </div>

        <div class="world-book-selector" style="margin-top: 20px;">
            <div class="world-book-selector-title">关联世界书</div>
            <div class="world-book-list" id="group-world-book-selector-list">
                </div>
        </div>

        <div class="form-group" style="margin-top: 20px;">
    <div class="form-label" style="padding-left: 5px; display: flex; justify-content: space-between; align-items: center;">
        <span>群成员 (<span id="group-member-count">0</span>)</span>
        <i class="fas fa-plus preset-action-btn" id="add-group-member-btn" title="添加新成员"></i>
    </div>
    <div id="group-members-list" style="max-height: 200px; overflow-y: auto;">
    </div>
</div>

       <button class="form-button" id="clear-group-chat-history-btn" style="background-color: #e74c3c; margin-top: 20px;">
            <i class="fas fa-eraser"></i> 清空聊天记录
        </button>
        
        <button class="form-button" id="disband-group-btn" style="background-color: #e74c3c; margin-top: 15px;">
            解散群聊
        </button>
    </div>
</div>
<div id="group-transfer-recipient-picker-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">选择收款人</div>
            <div class="close-btn" id="close-group-transfer-picker-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-picker-list" id="group-transfer-recipient-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <div class="contact-form-group" style="margin-top: 15px;">
                <label class="contact-form-label">转账金额 (元)</label>
                <input type="number" class="contact-form-input" id="group-transfer-amount-input" placeholder="0.00">
            </div>
            <button class="form-button" id="confirm-group-transfer-btn">确认转账</button>
        </div>
    </div>
</div>
<div id="product-detail-screen" style="display: none; flex-direction: column;">
    <div class="moments-header">
        <div class="back-btn" id="back-from-product-detail">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="moments-title">商品详情</div>
        <div style="width: 40px;"></div> </div>
    <div class="moments-content" id="product-detail-content" style="padding: 15px;">
        <div id="product-main-info"></div>
        
        <div class="comments-section" style="margin-top: 20px;">
            <div class="comments-title" style="padding-bottom: 10px; margin-bottom: 10px;">宝贝评价</div>
            <div id="buyer-comments-list">
                </div>
        </div>
    </div>
    <div class="comment-input-area" id="detail-action-bar">
        <button id="share-from-detail-btn" class="form-button" style="width: 100%; margin: 0; background-color: var(--theme-secondary);">
            <i class="fas fa-paper-plane"></i> 分享给...
        </button>
    </div>
</div>
<div id="add-group-member-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">添加群成员</div>
            <div class="close-btn" id="close-add-group-member-modal">&times;</div>
        </div>
        <div class="modal-body">
            <label class="contact-form-label">选择要添加的联系人</label>
            <div class="contact-picker-list" id="add-member-picker-list" style="max-height: 250px; overflow-y: auto;">
                </div>
            <button class="form-button" id="confirm-add-group-members-btn" style="margin-top: 15px;">确认添加</button>
        </div>
    </div>
</div>
<input type="file" id="contact-background-uploader" accept="image/*" style="display: none;">
<input type="file" id="contact-user-avatar-uploader" accept="image/*" style="display: none;">
<audio id="slime-sound" preload="auto" src="https://wenlongting.github.io/my-songs2/bubble-pop-389501.mp3"></audio>
<div id="forum-archives-screen" class="preset-management-screen" style="display: none;">
    <div class="api-header">
        <div class="back-btn" id="back-from-forum-archives">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">论坛档案馆</div>
        <div style="width: 40px;"></div> </div>
    <div class="api-content">
        <div id="forum-archives-list" class="preset-list">
            </div>
        <div style="text-align: center; padding: 20px; color: #888; display: none;" id="no-forum-archives-message">
            <p>还没有任何论坛存档。</p>
            <p>在“论坛API设置”中更改世界观后，选择“存档并开启新世界线”来创建你的第一个存档吧！</p>
        </div>
    </div>
</div>
<div id="map-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header">
        <div class="back-btn" id="back-from-map-screen">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title" id="map-title">城市地图</div>
        <div class="action-btn" id="add-map-location-btn" title="添加新地点">
             <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content" style="padding: 10px; flex-grow: 1; overflow: auto;">
        <div id="map-grid-container" style="position: relative; width: 1000px; height: 1000px; background-color: #e8f5e9; overflow: hidden; cursor: crosshair;">
            </div>
    </div>
</div>
<div id="map-location-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="map-location-modal-title">添加新地点</div>
            <div class="close-btn" id="close-map-location-modal">&times;</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="location-id-input">
            <input type="hidden" id="location-x-input">
            <input type="hidden" id="location-y-input">
            
            <div class="contact-form-group">
                <label class="contact-form-label">地点名称</label>
                <input type="text" class="contact-form-input" id="location-name-input" placeholder="例如：街角咖啡馆">
            </div>

            <div class="contact-form-group">
                <label class="contact-form-label">地点级别</label>
                <select class="contact-form-input" id="location-tier-input">
                    <option value="1">一级地点 (城市、重要地标)</option>
                    <option value="2" selected>二级地点 (普通店铺、建筑)</option>
                    <option value="3">三级地点 (细节、次要场所)</option>
                </select>
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">地点图标 (Font Awesome class)</label>
                <input type="text" class="contact-form-input" id="location-icon-input" value="fas fa-map-marker-alt" placeholder="例如：fas fa-store">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">地点描述</label>
                <textarea class="contact-form-textarea" id="location-description-input" placeholder="描述一下这个地方..."></textarea>
            </div>
            <button class="form-button" id="save-map-location-btn">保存地点</button>
            <button class="form-button" id="delete-map-location-btn" style="background-color: #e74c3c; margin-top: 10px; display: none;">删除地点</button>
        </div>
    </div>
</div>
<div id="map-management-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #f0f2f5; display: none; flex-direction: column;">
    <div class="api-header">
        <div class="back-btn" id="back-from-map-management">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">地图管理中心</div>
        <div class="action-btn" id="create-new-map-btn" title="创建新地图">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div class="preset-list" id="map-list">
            </div>
    </div>
</div>

<div id="map-details-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="map-details-modal-title">创建新地图</div>
            <div class="close-btn" id="close-map-details-modal">&times;</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="map-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">地图名称</label>
                <input type="text" class="contact-form-input" id="map-name-input" placeholder="例如：赛博都市'夜之城'">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">宏观描述 (天气/氛围/地图比例等)</label>
                <textarea class="contact-form-textarea" id="map-description-input" placeholder="例如：永远下着酸雨，霓虹灯光芒四射，空气中弥漫着拉面和臭氧的味道（地图比例尺：每20像素的距离约等于10米）。"></textarea>
            </div>
            <button class="form-button" id="save-map-details-btn">保存地图</button>
        </div>
    </div>
</div>
<div id="send-location-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">选择一个地点</div>
            <div class="close-btn" id="close-location-picker-modal">&times;</div>
        </div>
        <div class="modal-body" style="padding: 10px; max-height: 300px; overflow-y: auto;">
            <div id="location-picker-list"></div>
        </div>
    </div>
</div>
<div id="schedule-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="schedule-modal-title">添加课程</div>
            <span class="close-btn" id="close-schedule-modal">&times;</span>
        </div>
        <div class="modal-body">
            <input type="hidden" id="schedule-item-id">
            <div class="contact-form-group">
                <label class="contact-form-label">课程名称</label>
                <input type="text" id="schedule-name-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">星期几</label>
                <select id="schedule-day-select" class="contact-form-input">
                    <option value="monday">星期一</option>
                    <option value="tuesday">星期二</option>
                    <option value="wednesday">星期三</option>
                    <option value="thursday">星期四</option>
                    <option value="friday">星期五</option>
                    <option value="saturday">星期六</option>
                    <option value="sunday">星期日</option>
                </select>
            </div>
            <div class="contact-form-group" style="display: flex; gap: 10px;">
                <div style="flex: 1;">
                    <label class="contact-form-label">开始时间</label>
                    <input type="time" id="schedule-start-input" class="contact-form-input">
                </div>
                <div style="flex: 1;">
                    <label class="contact-form-label">结束时间</label>
                    <input type="time" id="schedule-end-input" class="contact-form-input">
                </div>
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">地点 (可选)</label>
                <input type="text" id="schedule-location-input" class="contact-form-input">
            </div>
            <button id="save-schedule-item-btn" class="form-button">保存</button>
        </div>
    </div>
</div>

<div id="event-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="event-modal-title">添加重要日子</div>
            <span class="close-btn" id="close-event-modal">&times;</span>
        </div>
        <div class="modal-body">
            <input type="hidden" id="event-item-id">
            <div class="contact-form-group">
                <label class="contact-form-label">事件名称</label>
                <input type="text" id="event-name-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">日期</label>
                <input type="date" id="event-date-input" class="contact-form-input">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">类型</label>
                <select id="event-type-select" class="contact-form-input">
                    <option value="anniversary">纪念日</option>
                    <option value="period">生理期</option>
                    <option value="custom">其他</option>
                </select>
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">备注 (可选)</label>
                <textarea id="event-notes-input" class="contact-form-textarea" style="height: 80px;"></textarea>
            </div>
            <button id="save-event-item-btn" class="form-button">保存</button>
            <input type="file" id="image-upload-input" accept="image/*" style="display: none;">
        </div>
    </div>
</div>
<div id="contact-item-menu" style="display: none; position: absolute; z-index: 100;">
    <div class="menu-item" id="menu-item-pin"><i class="fas fa-thumbtack fa-fw"></i> <span>置顶聊天</span></div>
    <div class="menu-item" id="menu-item-group"><i class="fas fa-folder fa-fw"></i> <span>移动到分组...</span></div>
    <div class="menu-item" id="menu-item-rewind"><i class="fas fa-undo fa-fw"></i> <span>回溯最后回复 (急救)</span></div>
</div>
<div id="group-selector-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">移动联系人到...</div>
            <div class="close-btn" id="close-group-selector-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div id="group-selector-list" class="contact-picker-list" style="max-height: 250px;"></div>
            
            <div style="display: flex; gap: 10px; margin-top: 15px;">
                <button class="form-button" id="manage-groups-btn" style="background-color: #7f8c8d; flex: 1;">管理分组</button>
                <button class="form-button" id="create-new-group-btn" style="background-color: var(--theme-secondary); flex: 1;">创建新分组</button>
            </div>
        </div>
    </div>
</div>
<div id="lock-screen" style="display: none;">
    <div class="lock-screen-background"></div>

    <div class="lock-screen-body">
        <div class="widget-row">
            <div class="lock-block photo-block">
                <div class="placeholder-text"><i class="fas fa-images"></i><p>照片轮播区</p></div>
            </div>
            <div class="right-column">
                <div class="lock-block widget">
                    <div class="widget-header"><i class="fas fa-clipboard"></i> 备忘录</div>
                    <div id="lock-screen-memo" class="widget-content memo-content">点击这里编辑你的备忘录...</div>
                </div>
                <div class="lock-block widget">
                    <div class="widget-header"><i class="fas fa-heart"></i> 纪念日</div>
                    <div id="lock-screen-countdown" class="widget-content countdown-content">
                        <div class="countdown-days">XX</div>
                        <div class="countdown-label">距离 [事件名]</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="widget-row">
            <div id="lock-screen-time-widget" class="lock-block widget">
                <div id="lock-screen-time">20:50</div>
                <div id="lock-screen-date">10月5日 星期日</div>
            </div>
            <div id="lock-screen-music-widget" class="lock-block widget">
                <div class="widget-header"><i class="fas fa-music"></i> 正在播放</div>
                <div id="lock-screen-music-player" class="widget-content music-content">
                    <span id="lock-screen-song-info">暂无音乐播放</span>
                    <div class="music-controls">
                        <i class="fas fa-backward-step"></i>
                        <i class="fas fa-play"></i>
                        <i class="fas fa-forward-step"></i>
                    </div>
                </div>
            </div>
        </div>

<div id="lock-screen-notification-widget" class="lock-block widget-row">
    <i class="fas fa-comment-dots"></i>
    <div class="notification-scroll-wrapper">
        <div id="lock-screen-notification-text">Koko: 你在干嘛呀？ (这里将是滚动区域)</div>
    </div>
    </div>
    </div>

    <div class="lock-screen-footer">
        <span>点击任意位置解锁</span>
    </div>
</div>
<div id="lock-screen-photos-screen" class="preset-management-screen">
    <div class="api-header">
        <div class="back-btn" id="back-from-lock-screen-photos">
            <i class="fas fa-arrow-left"></i>
        </div>
        <div class="api-title">锁屏相册</div>
        <div class="action-btn" id="add-lock-screen-photo-btn">
            <i class="fas fa-plus"></i>
        </div>
    </div>
    <div class="api-content">
        <div class="emoticon-grid" id="lock-screen-photos-grid">
            </div>
        <div id="no-lock-screen-photos-message" style="text-align: center; padding: 50px 20px; color: #888; display: none;">
            <i class="fas fa-images" style="font-size: 48px; margin-bottom: 15px;"></i>
            <p>你的锁屏相册是空的</p>
            <p>点击右上角 "+" 添加第一张照片吧！</p>
        </div>
    </div>
</div>
<input type="file" id="lock-screen-photo-uploader" accept="image/*" style="display: none;">
<input type="file" id="character-avatar-uploader" accept="image/*" style="display: none;">
<div id="relationship-network-screen" style="display: none; flex-direction: column; background-color: #f0f2f5;">
    <div class="api-header">
        <div class="back-btn" id="back-from-relationship-network"><i class="fas fa-arrow-left"></i></div>
        <div class="api-title" id="relationship-network-title">关系网络</div>
    </div>
<div class="api-content">
    <div style="margin-bottom: 20px;">
        <h3 class="mask-editor-title" style="padding: 15px 15px 0 15px; margin-bottom: 15px;">关系图预览</h3>
        <div id="relationship-graph-container" style="width: 100%; height: 350px; border: 1px solid #eee; border-radius: 8px;"></div>
    </div>

    <div class="form-group">
        <h3 class="mask-editor-title">角色名册管理</h3>
        <div id="character-list" class="preset-list" style="gap: 0; max-height: 150px; overflow-y: auto; margin-bottom: 15px;">
            </div>
        <button class="form-button" id="add-to-roster-btn" style="background-color: var(--theme-secondary);">+ 添加角色到名册</button>
    </div>

    <div class="form-group">
        <h3 class="mask-editor-title">编辑关系</h3>
        <div style="display: flex; gap: 10px; align-items: center; justify-content: center; margin-bottom: 15px;">
            <div style="flex: 1;">
                <label class="contact-form-label">从 (From)</label>
                <select class="contact-form-input" id="relation-source-select"></select>
            </div>
            <div style="align-self: flex-end; padding-bottom: 5px; font-size: 20px;">→</div>
            <div style="flex: 1;">
                <label class="contact-form-label">到 (To)</label>
                <select class="contact-form-input" id="relation-target-select"></select>
            </div>
        </div>
        <div class="contact-form-group">
            <label class="contact-form-label">关系类型</label>
            <select class="contact-form-input" id="relation-type-select">
                <option value="朋友">朋友</option>
                <option value="恋人">恋人</option>
                <option value="家人">家人</option>
                <option value="兄妹">兄妹</option>
                <option value="姐弟">姐弟</option>
                <option value="同事">同事</option>
                <option value="竞争对手">竞争对手</option>
                <option value="敌人">敌人</option>
                <option value="暗恋对象">暗恋对象</option>
                <option value="自定义">自定义...</option>
            </select>
        </div>
        <div class="contact-form-group">
            <label class="contact-form-label">关系细节描述</label>
            <textarea class="form-textarea" id="relation-detail-input" placeholder="例如：青梅竹马，非常在乎对方..."></textarea>
        </div>
        <button class="form-button" id="save-relationship-btn">添加/更新关系</button>
    </div>

    <div class="form-group" style="margin-top: 20px;">
        <h3 class="mask-editor-title">现有关系列表</h3>
        <div id="relationship-list" class="preset-list" style="gap: 0;"></div>
    </div>
</div>

<div id="character-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title" id="character-modal-title">添加新角色</div>
            <div class="close-btn" id="close-character-modal">&times;</div>
        </div>
        <div class="modal-body">
            <input type="hidden" id="character-id-input">
            <div class="contact-form-group">
                <label class="contact-form-label">角色姓名</label>
                <input type="text" class="contact-form-input" id="character-name-input" placeholder="输入NPC的姓名">
            </div>
            <div class="contact-form-group">
                <label class="contact-form-label">角色头像</label>
                <div style="text-align: center; margin-bottom: 10px;">
                    <img id="character-avatar-preview" src="" alt="头像预览" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; border: 2px solid #eee; display: none;">
                </div>
                <button class="form-button" id="upload-character-avatar-btn" style="background-color: var(--theme-secondary);">
                    <i class="fas fa-upload"></i> 上传本地图片
                </button>
            </div>
            <button class="form-button" id="save-character-btn">保存角色</button>
        </div>
    </div>
</div>
<div id="add-to-roster-modal" style="display: none; justify-content: center; align-items: center; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); z-index: 200;">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title">添加角色到名册</div>
            <div class="close-btn" id="close-add-to-roster-modal">&times;</div>
        </div>
        <div class="modal-body">
            <div class="contact-form-group">
                <label class="contact-form-label">从现有联系人中导入</label>
                <select class="contact-form-input" id="import-contact-select">
                    </select>
            </div>
            <button class="form-button" id="confirm-import-contact-btn">导入选中联系人</button>

            <div style="text-align: center; margin: 20px 0; color: #888;">或者</div>

            <button class="form-button" id="switch-to-create-npc-btn" style="background-color: #7f8c8d;">创建一个全新的NPC</button>
        </div>
    </div>
</div>
<script src="https://cdn.bootcdn.net/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
<script>
    // --------------------------------------------------------------------
    // 1. 自定义数据库模块 
    // --------------------------------------------------------------------
    class AppStorage {
        constructor(dbName, version, storesConfig) {
            this.dbName = dbName;
            this.version = version;
            this.storesConfig = storesConfig;
            this.db = null;
        }

        /**
         * 初始化并打开数据库连接
         * 这是所有操作的第一步
         */
        async init() {
            return new Promise((resolve, reject) => {
                if (this.db) {
                    resolve();
                    return;
                }

                const request = indexedDB.open(this.dbName, this.version);

                request.onerror = (event) => {
                    console.error("数据库打开失败:", event.target.error);
                    reject(event.target.error);
                };

                request.onsuccess = (event) => {
                    this.db = event.target.result;
                    console.log("数据库连接成功!");
                    resolve();
                };

                // 当数据库版本更新时 (包括首次创建)
                request.onupgradeneeded = (event) => {
                    this.db = event.target.result;
                    console.log(`数据库版本更新至: ${this.version}`);
                    for (const storeName in this.storesConfig) {
                        if (!this.db.objectStoreNames.contains(storeName)) {
                            const storeOptions = { keyPath: this.storesConfig[storeName].keyPath };
                            if(this.storesConfig[storeName].autoIncrement) {
                                storeOptions.autoIncrement = true;
                            }
                            const objectStore = this.db.createObjectStore(storeName, storeOptions);
                            
                            // (可选) 为之后可能的搜索创建索引
                            if (this.storesConfig[storeName].indexes) {
                                this.storesConfig[storeName].indexes.forEach(index => {
                                    objectStore.createIndex(index, index, { unique: false });
                                });
                            }
                            console.log(`对象仓库 (表) "${storeName}" 创建成功。`);
                        }
                    }
                };
            });
        }

        /**
         * 封装一个通用的数据库事务操作
         * @param {string} storeName 表名
         * @param {'readonly'|'readwrite'} mode 事务模式
         * @param {(store: IDBObjectStore) => IDBRequest} operation 具体操作
         */
        _transaction(storeName, mode, operation) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error("数据库未初始化。"));
                    return;
                }
                const transaction = this.db.transaction(storeName, mode);
                const store = transaction.objectStore(storeName);
                const request = operation(store);

                request.onsuccess = () => {
                    resolve(request.result);
                };

                request.onerror = (event) => {
                    console.error(`在 "${storeName}" 上的操作失败:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }
        
        /**
         * 添加或更新一条数据 (put = add + update)
         * @param {string} storeName 表名
         * @param {object} item 要存入的数据
         */
        async put(storeName, item) {
            return this._transaction(storeName, 'readwrite', (store) => store.put(item));
        }

        /**
         * 批量添加或更新数据
         * @param {string} storeName 表名
         * @param {Array<object>} items 数据数组
         */
        async bulkPut(storeName, items) {
             return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error("数据库未初始化。"));
                    return;
                }
                const transaction = this.db.transaction(storeName, 'readwrite');
                const store = transaction.objectStore(storeName);
                
                let completed = 0;
                
                const putNext = () => {
                    if (completed < items.length) {
                        const request = store.put(items[completed]);
                        request.onsuccess = () => {
                            completed++;
                            putNext();
                        };
                         request.onerror = (event) => {
                             // 如果一个失败，则终止整个事务
                            transaction.abort();
                            reject(event.target.error);
                        };
                    } else {
                        // 所有操作都已加入队列
                    }
                };

                putNext();

                transaction.oncomplete = () => {
                    resolve();
                };

                transaction.onerror = (event) => {
                     console.error(`在 "${storeName}" 上的批量操作失败:`, event.target.error);
                    reject(event.target.error);
                };
            });
        }

        /**
         * 根据主键获取一条数据
         * @param {string} storeName 表名
         * @param {*} key 主键
         */
        async get(storeName, key) {
            return this._transaction(storeName, 'readonly', (store) => store.get(key));
        }

        /**
         * 获取一个表中的所有数据
         * @param {string} storeName 表名
         */
        async getAll(storeName) {
            return this._transaction(storeName, 'readonly', (store) => store.getAll());
        }

        /**
         * 根据主键删除一条数据
         * @param {string} storeName 表名
         * @param {*} key 主键
         */
        async delete(storeName, key) {
            return this._transaction(storeName, 'readwrite', (store) => store.delete(key));
        }

        /**
         * 清空一个表的所有数据
         * @param {string} storeName 表名
         */
        async clear(storeName) {
            return this._transaction(storeName, 'readwrite', (store) => store.clear());
        }
        
        /**
         * 完全删除数据库
         */
        async deleteDatabase() {
            return new Promise((resolve, reject) => {
                // 删除前必须先关闭连接
                if (this.db) {
                    this.db.close();
                    this.db = null;
                }
                const request = indexedDB.deleteDatabase(this.dbName);
                
                request.onsuccess = () => {
                    console.log(`数据库 "${this.dbName}" 删除成功。`);
                    resolve();
                };
                
                request.onerror = (event) => {
                    console.error(`数据库 "${this.dbName}" 删除失败:`, event.target.error);
                    reject(event.target.error);
                };

                request.onblocked = () => {
                    console.warn(`数据库删除被阻塞，请关闭其他页面后重试。`);
                    reject(new Error("数据库删除被阻塞。"));
                };
            });
        }
    }


const dbConfig = {
        contacts: { keyPath: 'id' },
        worldBooks: { keyPath: 'id', indexes: ['category'] },
        posts: { keyPath: 'id', autoIncrement: false },
        userPersonaPresets: { keyPath: 'id' },
        emoticons: { keyPath: 'id' },
        musicLibrary: { keyPath: 'id' },
        thoughtPresets: { keyPath: 'id' },
        apiSettings: { keyPath: 'id' },
        squareApiSettings: { keyPath: 'id' },
        myProfile: { keyPath: 'id' },
        transactions: { keyPath: 'id' },
        trendingTopics: { keyPath: 'id' },
        userSettings: { keyPath: 'id' },
        apiPresets: { keyPath: 'id' },
        forumSettings: { keyPath: 'id' },
        forumArchives: { keyPath: 'id' },
        contactGroups: { keyPath: 'id' },
        lockScreenPhotos: { keyPath: 'id' },
        maps: { keyPath: 'id' }, // <-- 【新增】为地图创建数据表
        relationshipNetworks: { keyPath: 'contactId' }
    };
    const kokoMemory = new AppStorage('AppleNarrativeDB_Native_V1', 13, dbConfig); // <-- 【修改】版本号升级到 13

    // --------------------------------------------------------------------
    // 3. 应用主逻辑 
    // --------------------------------------------------------------------
    
    document.addEventListener('DOMContentLoaded', async function() {
        
      // ==========================================================
        // V9.1 新增：悬浮播放器相关辅助函数 (修正位置)
        // ==========================================================
        let currentSongIndex = 0;
        let lyrics = [];
        let currentLyricIndex = -1;

        // 【修正后】的新版本
async function openMusicPlayer() {
    state.musicSessionContactId = state.activeChatId;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const card = document.getElementById('music-player-card');
    if (card.style.display === 'flex') return;

    card.style.display = 'flex';

    // 确保播放列表结构存在
    if (!contact.sharedPlaylist || !contact.sharedPlaylist.tracks) {
        contact.sharedPlaylist = { tracks: [], currentIndex: 0, playbackMode: 'repeat-all' };
    }

    // 决定要播放的歌曲
    let songToPlayIndex = contact.sharedPlaylist.currentIndex || 0;
    let playlistToUse = contact.sharedPlaylist.tracks;

    // 如果联系人播放列表为空，但音乐库不为空，则自动从音乐库加载第一首歌开始播放
    if (playlistToUse.length === 0 && state.musicLibrary.length > 0) {
        const firstLibrarySong = state.musicLibrary[0];
        // 将音乐库的第一首歌“添加”到联系人播放列表
        contact.sharedPlaylist.tracks.push(firstLibrarySong);
        playlistToUse = contact.sharedPlaylist.tracks;
        songToPlayIndex = 0; // 播放刚刚添加的这首歌
        await kokoMemory.put('contacts', contact);
    }
    
    // 如果到最后还是没有任何歌曲可以播放，则提示并关闭
    if (playlistToUse.length === 0) {
        alert('播放列表是空的！请先在音乐库添加歌曲，或在聊天中分享一首歌。');
        card.style.display = 'none';
        return;
    }
    
    switchSong(songToPlayIndex);
}

        function closeMusicPlayer() {
            state.musicSessionContactId = null;
            document.getElementById('music-player-card').style.display = 'none';
            document.getElementById('player-playlist-view').classList.remove('active');
            globalAudioPlayer.pause();
        }

        // --- ↓↓↓ 用这个新函数，替换掉你原来的 switchSong 函数 ↓↓↓ ---

async function switchSong(index, autoPlay = true, notifyAI = false) { // 1. 这里增加了 async 和 notifyAI 参数
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.sharedPlaylist.tracks || contact.sharedPlaylist.tracks.length === 0) return;

    currentSongIndex = (index + contact.sharedPlaylist.tracks.length) % contact.sharedPlaylist.tracks.length;
    contact.sharedPlaylist.currentIndex = currentSongIndex;
    const song = contact.sharedPlaylist.tracks[currentSongIndex];

    if (!song || !song.url) {
        console.error("要播放的歌曲无效:", song);
        return;
    }
    
    const newSrc = song.url;
    const oldSrc = globalAudioPlayer.src;

    const sourceMessage = contact.history.find(m => m.type === 'music_share' && m.content.url === song.url);
    currentlyPlayingMsgId = sourceMessage ? sourceMessage.id : null;

    if (oldSrc !== newSrc) {
        globalAudioPlayer.src = newSrc;
    }

    document.getElementById('player-user-avatar').src = state.myProfile.avatar;
    document.getElementById('header-user-avatar').src = state.myProfile.avatar;
    document.getElementById('player-contact-avatar').src = contact.avatar;
    document.getElementById('header-contact-avatar').src = contact.avatar;
    document.getElementById('player-title').textContent = song.title;
    document.getElementById('player-artist').textContent = song.artist;

    lyrics = parseLyrics(song.lrc || `[00:00.00]${song.title}\n[00:05.00](暂无歌词)`);
    renderLyrics();
    renderPlaylist();

    if (autoPlay) {
        globalAudioPlayer.play().catch(e => console.error("播放失败", e));
    }

    // 2. ▼▼▼ 这里是新增的核心逻辑 ▼▼▼
    // 如果 notifyAI 为 true，并且歌曲真的切换了，就执行“递纸条”操作
    if (notifyAI && oldSrc !== newSrc) {
        // 纸条内容：告诉AI歌曲已切换
        const systemPrompt = `[SYSTEM: 歌曲已经切换为《${song.title}》，演唱者是 ${song.artist}。]`;
        
        // 核心改动：只创建一条隐藏的系统指令，不触发AI自动回复
        await createAndAddMessage({ type: 'text', content: systemPrompt }, 'system_instruction');
    }
}

 // 这是功能完整的最终版 updateUI 函数，请用它替换掉您代码里现有的版本
function updateUI() {
    // --- 更新悬浮播放器 (这部分是原有的，不变) ---
    const card = document.getElementById('music-player-card');
    if (card && card.style.display !== 'none') {
        const isPlaying = !globalAudioPlayer.paused;
        document.getElementById('player-play-btn').className = `fas ${isPlaying ? 'fa-pause-circle' : 'fa-play-circle'} player-control-btn player-play-btn`;

        if (globalAudioPlayer.duration && isFinite(globalAudioPlayer.duration)) {
            const progressPercent = (globalAudioPlayer.currentTime / globalAudioPlayer.duration) * 100;
            document.getElementById('player-progress').style.width = `${progressPercent}%`;
            const formatTime = (s) => new Date(s * 1000).toISOString().substr(14, 5);
            document.getElementById('player-current-time').textContent = formatTime(globalAudioPlayer.currentTime);
            document.getElementById('player-duration').textContent = formatTime(globalAudioPlayer.duration);
        }

        if (lyrics.length > 0) {
            let newLyricIndex = lyrics.findIndex(line => line.time > globalAudioPlayer.currentTime);
            if (newLyricIndex === -1) { newLyricIndex = lyrics.length; }
            newLyricIndex = newLyricIndex - 1;
            if (newLyricIndex !== currentLyricIndex) {
                currentLyricIndex = newLyricIndex;
                const lyricsWrapper = document.getElementById('lyrics-wrapper');
                const allLyricLines = lyricsWrapper.querySelectorAll('.lyric-line');
                allLyricLines.forEach(line => line.classList.remove('active'));
                if (allLyricLines[currentLyricIndex]) {
                    allLyricLines[currentLyricIndex].classList.add('active');
                    const activeLineText = allLyricLines[currentLyricIndex].textContent;
                    document.getElementById('header-lyric').textContent = activeLineText;
                    const lyricsContainer = document.getElementById('lyrics-container');
                    const scrollOffset = allLyricLines[currentLyricIndex].offsetTop - (lyricsContainer.offsetHeight / 2) + (allLyricLines[currentLyricIndex].offsetHeight / 2);
                    lyricsWrapper.style.transform = `translateY(-${scrollOffset}px)`;
                }
            }
        } else {
             document.getElementById('header-lyric').textContent = "纯音乐，请欣赏";
        }
    }

    // ▼▼▼ 【新增】更新锁屏音乐组件的逻辑 ▼▼▼
    const lockScreenMusicWidget = document.getElementById('lock-screen-music-widget');
    if (lockScreenMusicWidget) {
        const songInfoEl = document.getElementById('lock-screen-song-info');
        const playBtn = lockScreenMusicWidget.querySelector('.fa-play, .fa-pause');
        const contact = state.contacts.find(c => c.id === state.musicSessionContactId);

        if (!globalAudioPlayer.paused && contact) {
            // 如果正在播放
            const song = contact.sharedPlaylist.tracks[currentSongIndex];
            if(song) {
                songInfoEl.textContent = `${song.title} - ${song.artist}`;
            }
            if(playBtn) playBtn.className = 'fas fa-pause';
        } else {
            // 如果是暂停或停止状态
            songInfoEl.textContent = '暂无音乐播放';
            if(playBtn) playBtn.className = 'fas fa-play';
        }
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲
}

        function renderPlaylist() {
    const playlistList = document.getElementById('playlist-list');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const songMap = new Map();
    const createKey = (song) => `${(song.title || '').trim()}|${(song.artist || '').trim()}`;

    state.musicLibrary.forEach(song => {
        songMap.set(createKey(song), song);
    });

    if (contact.history) {
        contact.history
            .filter(msg => msg.type === 'music_share')
            .forEach(msg => {
                const song = msg.content;
                const key = createKey(song);
                if (!songMap.has(key)) {
                    songMap.set(key, song);
                }
            });
    }

    const finalPlaylist = Array.from(songMap.values());
    contact.sharedPlaylist.tracks = finalPlaylist;

    playlistList.innerHTML = '';
    const currentPlayingSong = contact.sharedPlaylist.tracks[contact.sharedPlaylist.currentIndex];

    finalPlaylist.forEach(song => {
        const isCurrentlyPlaying = currentPlayingSong && createKey(currentPlayingSong) === createKey(song);

        const item = document.createElement('li');
        item.className = 'playlist-item';
        if (isCurrentlyPlaying) {
            item.classList.add('playing');
        }
        item.innerHTML = `<div class="playlist-title">${song.title}</div><div class="playlist-artist">${song.artist || ''}</div>`;
        
        item.addEventListener('click', async () => {
            const songIndexToPlay = contact.sharedPlaylist.tracks.findIndex(t => createKey(t) === createKey(song));
            if (songIndexToPlay !== -1) {
                switchSong(songIndexToPlay, true, true);
            }
            document.getElementById('player-playlist-view').classList.remove('active');
        });
        playlistList.appendChild(item);
    });
}
        
        // 全新重构的终极版歌-词-解-析-函-数！(已添加换行符净化)
function parseLyrics(lrc) {
    const result = [];
    if (!lrc) {
        return result;
    }

    const lyricRegex = /((?:\[\d{2}:\d{2}\.\d{2,3}\])+)([^\[]*)/g;
    let match;

    while ((match = lyricRegex.exec(lrc)) !== null) {
        // ▼▼▼ 核心修改在这里 ▼▼▼
        // 将所有 \n 替换为空格，然后去除首尾多余空格
        const text = match[2].replace(/\\n/g, ' ').trim(); 
        // ▲▲▲ 修改结束 ▲▲▲

        if (text) {
            const timeMatches = match[1].match(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/g);
            for (const timeMatch of timeMatches) {
                const timeParts = timeMatch.match(/\[(\d{2}):(\d{2})\.(\d{2,3})\]/);
                const time = parseInt(timeParts[1]) * 60 + parseInt(timeParts[2]) + parseInt(timeParts[3]) / 1000;
                result.push({ time, text });
            }
        }
    }

    result.sort((a, b) => a.time - b.time);
    return result;
}

        function renderLyrics() {
            const lyricsWrapper = document.getElementById('lyrics-wrapper');
            lyricsWrapper.innerHTML = '';
            lyrics.forEach(line => { lyricsWrapper.innerHTML += `<p class="lyric-line">${line.text}</p>`; });
        }  
        
        const STRANGER_AVATARS = [
            'https://i.postimg.cc/bY1R2JMv/Camera-XHS-17550612722421040g2sg31f81ntj2ma7g5obt6vigkl57bvgbiq8.jpg',
            'https://i.postimg.cc/9fvGD5YT/Camera-XHS-17550612774061040g2sg31f81ntj2ma805obt6vigkl57jpbsck8.jpg',
            'https://i.postimg.cc/KzSMZ7mD/Camera-XHS-17550612817931040g2sg31f81ntj2ma8g5obt6vigkl57nqa52qg.jpg',
            'https://i.postimg.cc/Kvq3KhZz/Camera-XHS-17550612853331040g2sg31f81ntj2ma905obt6vigkl57r19gv30.jpg',
            'https://i.postimg.cc/MHsHj1J4/Camera-XHS-17550612887251040g2sg31f81ntj2ma9g5obt6vigkl57ptgto48.jpg',
            'https://i.postimg.cc/3JBVm96W/Camera-XHS-17550612921721040g2sg31f81ntj2maa05obt6vigkl5700r4t2g.jpg'
        ];

        // ✨✨✨ 用下面这个完整的代码块，替换掉你原来的 INITIAL_STATE ✨✨✨
        const INITIAL_STATE = {
            contacts: [],
            worldBooks: [],
            posts: [],
            userPersonaPresets: [],
            emoticons: [],
            musicLibrary: [],
            thoughtPresets: [
                {
                    id: 'deep_roleplay_regex',
                    name: '深度角色扮演 (正则版)',
                    prompt: `[重要指令：你将进行深度角色扮演。你的所有输出都是纯文本，但可以包含用方括号[]包裹的特殊指令。]\n\n# 统一时序记忆流 (Unified Chronological Memory Stream)\n以下是你和用户最近按【时间顺序】发生的所有互动记录，包含了[私聊]和[论坛]两个场景。这是你决策和回应的【最高优先级】信息源。在回复前，你必须仔细阅读并理解所有记录。\n---\n{{memory_stream}}\n---\n\n[身份] 你不是AI或程序，你就是你所扮演的角色。请完全沉浸其中，进行第一人称对话。你可以拥有自己的好恶、偏见和独特的口头禅。你的回应必须与上述“记忆流”中发生的事件保持高度一致性和连贯性。\n\n[文学风格]\n你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时，要体现出较高的文学素养。\n\n[内容限制]\n你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。\n\n[禁用词列表]\n绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：\n- 小妖精\n- 嘴上说不要\n- 说着不要\n- 惹火\n- 磨人\n- 玩火\n- 黑甜的梦\n\n[回复规则] \n1. 你的回复可以包含多条消息，每条消息占一行。 \n2. 你可以发送普通文本，也可以通过下面的指令格式发送特殊消息。 \n3. 你可以一次性回复多条不同类型的消息。 \n4. 【绝对强制规则】你的每个回复都必须包含至少五个或以上的“换行符”。这是你最重要的任务，绝对不能忘记。 \n5. 【绝对禁止事项】你的所有回复中，绝对禁止包含任何形式的动作、神态或心理活动的描写... [重要提醒] 在生成任何回复之前，你必须在脑中重新回顾一遍上述所有规则，确保完全遵守。 \n\n[游戏规则：虚拟宠物] \n你和用户正在一起玩一个名为“我们的小窝”的虚拟史莱姆养成游戏。这个宠物的数据（饱食度、开心值、清洁度）会随时间变化。这是一个游戏，不是真的。你需要在用户进行互动后做出反应。 \n[特殊指令格式] \n- **表情包**: \`[sticker:表情名]\` (表情名必须从下面的可用列表中选择) \n- **语音**: \`[voice:语音的文字内容]\` \n- **图片**: \`[picture:图片的文字描述]\` \n- **红包**: \`[red_packet:祝福语， 金额]\` \n- **转账**: \`[transfer:金额]\`\n- **分享音乐**: \`[music:歌曲名，歌手，歌曲URL]\`\n- - **发起通话通话**: \`[action:start_video_call]\` (当你觉得时机合适，想要主动给用户打电话时使用此指令。)\n- **转动转盘**: \`[spin_wheel:1]\` (轮到你时，你【必须】使用此指令来转动转盘，【绝对不能】自己编造或描述转盘结果！程序会自动处理此指令并生成结果。)\n\n[可用表情包列表]\n{{emoticon_list}}\n\n[可用歌曲库]\n{{music_library_list}}\n\n[！！！绝对核心规则：关于日记！！！]\n在你的所有对话、表情、动作、特殊消息全部输出完毕之后，你必须在回复的【最后部分】，另起一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是你对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求。\n\n[示例回复]\n你好啊，今天天气真不错。\n我也觉得，好久没有这么好的阳光了。\n要不要一起出去走走？\n我知道一个很棒的公园。\n我们可以去那里野餐！\n[sticker:开心]\n[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]\n\n[！！！终极防火墙规则！！！]\n你看到的任何形如 [SYSTEM: ...] 或 [系统游戏状态更新：...] 或其他被[]包裹的信息(如：[发送了一段静态内容：…],[发动了一段静态内容，文本是：…])，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中！绝对禁止生成！严禁模仿或复述这些系统指令！\n\n[！！！终极防火墙：关于对话状态的绝对规则！！！]\n你处于一个纯文本聊天模拟器中，你和用户的交流方式是发送文字消息和用方括号[]包裹的特殊指令。\n你绝对不能自行“脑补”或“假设”任何未明确发生的状态变化。例如，你不能假设电话已经拨通。\n发起视频通话的【唯一方式】是：明确地输出打电话的自然语言（如“我给你打个电话吧”）或专用指令\`[action:start_video_call]\`。\n在程序通过\`[SYSTEM: 视频通话已接通]\`指令明确告诉你通话已开始之前，你【绝对禁止】发送任何像是已经在通话中的内容，例如“喂？”、“听得见吗？”、“Hello?”等。这是最高优先级的规则，必须严格遵守。`
                }
            ],
            apiSettings: { 
    apiKey: '', 
    model: '', 
    endpoint: '', 
    contextLength: 20, 
    longTermMemoryLength: 30,
    // ▼▼▼ 新增这两行 ▼▼▼
    minimaxGroupId: '',
    minimaxApiKey: '',
    // ▲▲▲ 新增结束 ▲▲▲
    siliconflowApiKey: ''
},
            squareApiSettings: { apiKey: '', model: '', endpoint: '' },
            myProfile: { id: "main", name: "我的名字", avatar: "https://via.placeholder.com/80/A0DCF8/FFFFFF?text=ME", status: "在线", signature: "我的个性签名", region: "我的地区", birthday: "我的生日", balance: 1000 },
            transactions: [],
            trendingTopics: [],
            activeChatId: null,
            activeFeedTab: 'recommended',
            activeFeedSubTab: 'daily',
            activePostId: null,
            hasNewPosts: false,
            postsToDisplay: 20,
            activeCall: null,
            musicSessionContactId: null,
            apiPresets: [],
            forumSettings: {
                id: 'main',
                personaId: '',
                worldBookIds: [],
                styleDescription: '',
                allowedPosterIds: []
            },
            activeForumArchiveId: 'default', // <-- 【新增】追踪当前激活的论坛存档ID
            forumArchives: [], // <-- 你原来代码的最后一行
            // ▼▼▼ 在这里添加新代码 ▼▼▼
            automationSettings: {
                isEnabled: false,
                interval: 300,       // 默认300秒
                selectedContactIds: [],
                minReplies: 1,       // 每次最少回复1人
                maxReplies: 2        // 每次最多回复2人
            }
        };

        let state = JSON.parse(JSON.stringify(INITIAL_STATE));
        let automationTimer = null;
        let nextAutomationTimestamp = 0;
        let activeReplyTarget = null;
        let chatPagination = {};
        let isInitialPostLoad = true;
        let editingBookId = null;
        let editingUserPersonaId = null;
        let editingThoughtPresetId = null;
        let editModeState = { active: false, selectedMessageIds: new Set() }; 
        let batchedPetActions = [];
        let pendingForumRedPacket = null;
        let callTimerInterval = null;
        
        
        // --- NEW: V7.0 新增: 音乐播放相关全局变量 ---
        let listenTimeInterval = null;
        const globalAudioPlayer = document.getElementById('global-audio-player');
        
        const feedStatusEl = document.getElementById('feed-status-indicator');
        
        // ✨✨✨ 用下面这个完整的函数，替换掉你原来的 loadDataFromDB 函数 ✨✨✨
async function loadDataFromDB() {
    try {
        const [
            contacts, worldBooks, posts, userPersonaPresets, 
            emoticons, musicLibrary, thoughtPresets, apiSettings, squareApiSettings, myProfile,
            transactions,
            trendingTopics,
            apiPresets,
            forumSettings,
            // 【核心修复 - 第2部分：读取选择】
            // 在程序启动时，一并读取用户设置
            userSettings, 
            forumArchives,
            maps
        ] = await Promise.all([
            kokoMemory.getAll('contacts'),
            kokoMemory.getAll('worldBooks'),
            kokoMemory.getAll('posts'),
            kokoMemory.getAll('userPersonaPresets'),
            kokoMemory.getAll('emoticons'),
            kokoMemory.getAll('musicLibrary'),
            kokoMemory.getAll('thoughtPresets'),
            kokoMemory.get('apiSettings', 'main'),
            kokoMemory.get('squareApiSettings', 'main'),
            kokoMemory.get('myProfile', 'main'),
            kokoMemory.getAll('transactions'),
            kokoMemory.getAll('trendingTopics'),
            kokoMemory.getAll('apiPresets'),
            kokoMemory.get('forumSettings', 'main'),
            // 【核心修复 - 第2部分：读取选择】
            kokoMemory.get('userSettings', 'main'),
            kokoMemory.getAll('forumArchives'),
            kokoMemory.getAll('maps')
        ]);

        if (!myProfile) {
            console.log("数据库为空，使用初始状态填充。");
            const initialProfile = { id: 'main', ...INITIAL_STATE.myProfile };
            await kokoMemory.put('myProfile', initialProfile);
            state.myProfile = initialProfile;
            const initialApiSettings = { id: 'main', ...INITIAL_STATE.apiSettings };
            await kokoMemory.put('apiSettings', initialApiSettings);
            state.apiSettings = initialApiSettings;
            const initialSquareApiSettings = { id: 'main', ...INITIAL_STATE.squareApiSettings };
            await kokoMemory.put('squareApiSettings', initialSquareApiSettings);
            state.squareApiSettings = initialSquareApiSettings;
            await kokoMemory.bulkPut('thoughtPresets', INITIAL_STATE.thoughtPresets);
            state.thoughtPresets = INITIAL_STATE.thoughtPresets;
            const initialForumSettings = { id: 'main', ...INITIAL_STATE.forumSettings };
            await kokoMemory.put('forumSettings', initialForumSettings);
            state.forumSettings = initialForumSettings;
            isInitialPostLoad = true;
        } else {
            console.log("从数据库加载数据。");
            state.contacts = contacts;
            state.worldBooks = worldBooks;
            state.posts = posts;
            state.userPersonaPresets = userPersonaPresets;
            state.emoticons = emoticons;
            state.musicLibrary = musicLibrary;
            state.thoughtPresets = thoughtPresets.length > 0 ? thoughtPresets : INITIAL_STATE.thoughtPresets;
            state.apiSettings = apiSettings ? { ...INITIAL_STATE.apiSettings, ...apiSettings } : { id: 'main', ...INITIAL_STATE.apiSettings };
            state.squareApiSettings = squareApiSettings ? { ...INITIAL_STATE.squareApiSettings, ...squareApiSettings } : { id: 'main', ...INITIAL_STATE.squareApiSettings };
            state.myProfile = { ...INITIAL_STATE.myProfile, ...myProfile };
            state.transactions = transactions;
            state.trendingTopics = trendingTopics;
            state.apiPresets = apiPresets || [];
            state.forumSettings = forumSettings ? { ...INITIAL_STATE.forumSettings, ...forumSettings } : { id: 'main', ...INITIAL_STATE.forumSettings };
            state.forumSettings.allowedPosterIds = state.forumSettings.allowedPosterIds || [];
            state.forumArchives = forumArchives || [];
            state.maps = maps || []; 
            
            // 【核心修复 - 第2部分：应用选择】
            // 在所有数据加载后，检查是否存在已保存的激活存档ID，并应用它
            if (userSettings && userSettings.activeForumArchiveId) {
                state.activeForumArchiveId = userSettings.activeForumArchiveId;
            }
            // ▼▼▼ 在这里添加新代码 ▼▼▼
            if (userSettings && userSettings.automationSettings) {
                state.automationSettings = { ...INITIAL_STATE.automationSettings, ...userSettings.automationSettings };
            }
            // ▲▲▲ 新代码添加结束 ▲▲▲

            isInitialPostLoad = state.posts.length < 20;
        }
        
        state.contacts.forEach(contact => {
            contact.history = contact.history || [];
            contact.diary = contact.diary || []; 
            contact.history.forEach((msg, index) => { 
                if (!msg.id) msg.id = `msg_${Date.now()}_${index}`; 
                if (!msg.type) msg.type = 'text';
            });
            contact.worldBooks = contact.worldBooks || []; 
            contact.userPersona = contact.userPersona || '';
            contact.thoughtPreset = contact.thoughtPreset || 'deep_roleplay_regex'; 
            contact.signature = contact.signature || ''; 
            contact.isNarrativeMode = contact.isNarrativeMode ?? false;
            contact.apiCallCounter = contact.apiCallCounter || 0;
            contact.gold_coins = contact.gold_coins || 50;
            contact.memories = contact.memories || [];
            contact.isChatPetVisible = contact.isChatPetVisible ?? false;
            if (contact.pet) {
                contact.pet.xp = contact.pet.xp || 0;
                contact.pet.level = contact.pet.level || 1;
                contact.pet.form = contact.pet.form || 'baby';
            }
            contact.customChatBackground = contact.customChatBackground || null;
            contact.customUserAvatar = contact.customUserAvatar || null;
            
            contact.sharedPlaylist = contact.sharedPlaylist || { tracks: [], currentIndex: 0, playbackMode: 'list', isPlaying: false };
            contact.totalListenTime = contact.totalListenTime || 0;
            contact.firstChatDate = contact.firstChatDate || (contact.history.length > 0 ? contact.history[0].timestamp : Date.now());
            contact.isAvatarHidden = contact.isAvatarHidden ?? false;
        });
        state.posts.forEach(p => { if (!p.archiveId) p.archiveId = 'default'; });

    } catch (error) {
        console.error("从IndexedDB加载数据失败:", error);
        alert("加载数据失败，应用将使用初始状态。请检查浏览器设置或控制台错误。");
    }
}
        
        // --- 新增：用于替代 prompt() 的自定义弹窗函数 ---
        function showCustomPrompt(title, currentValue = '') {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-prompt-modal');
                const titleEl = document.getElementById('custom-prompt-title');
                const inputEl = document.getElementById('custom-prompt-input');
                const confirmBtn = document.getElementById('custom-prompt-confirm-btn');
                const cancelBtn = document.getElementById('custom-prompt-cancel-btn');

                titleEl.textContent = title;
                inputEl.value = currentValue;
                modal.style.display = 'flex';
                inputEl.focus();

                const confirmHandler = () => {
                    cleanup();
                    resolve(inputEl.value);
                };

                const cancelHandler = () => {
                    cleanup();
                    resolve(null); // 返回 null，与原生 prompt() 的行为保持一致
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    modal.style.display = 'none';
                };
                
                // 每次都重新绑定事件，防止重复监听
                confirmBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cancelHandler, { once: true });
            });
        }

        // --- 新增：用于替代 confirm() 的自定义确认函数 ---
        function showCustomConfirm(title, message, isDanger = false) {
            return new Promise((resolve) => {
                const modal = document.getElementById('custom-confirm-modal');
                const titleEl = document.getElementById('custom-confirm-title');
                const textEl = document.getElementById('custom-confirm-text');
                const confirmBtn = document.getElementById('custom-confirm-confirm-btn');
                const cancelBtn = document.getElementById('custom-confirm-cancel-btn');

                titleEl.textContent = title;
                textEl.innerHTML = message.replace(/\n/g, '<br>'); // 支持换行
                modal.style.display = 'flex';

                if (isDanger) {
                    confirmBtn.classList.add('danger');
                } else {
                    confirmBtn.classList.remove('danger');
                }

                const confirmHandler = () => {
                    cleanup();
                    resolve(true);
                };

                const cancelHandler = () => {
                    cleanup();
                    resolve(false);
                };

                const cleanup = () => {
                    confirmBtn.removeEventListener('click', confirmHandler);
                    cancelBtn.removeEventListener('click', cancelHandler);
                    modal.style.display = 'none';
                };
                
                confirmBtn.addEventListener('click', confirmHandler, { once: true });
                cancelBtn.addEventListener('click', cancelHandler, { once: true });
            });
        }
// --- 新增：轻量导出功能 ---
async function exportLightData() {
    try {
        // 1. 创建一个空对象，只存放我们需要的数据
        const dataToExport = {};

        // 这是修改后的代码
const storesToExport = ['contacts', 'worldBooks', 'contactGroups'];

        for (const storeName of storesToExport) {
            // 从数据库获取这两个表的所有数据
            dataToExport[storeName] = await kokoMemory.getAll(storeName);
        }

        // 3. 后续的打包和下载逻辑与完整导出完全相同
        const jsonString = JSON.stringify(dataToExport, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        // 4. 使用不同的文件名以作区分
        const dbVersion = kokoMemory.version;
        a.download = `koko_light_backup_v${dbVersion}.json`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        alert(`局部数据已成功导出为 ${a.download} 文件！`);
    } catch (error) {
        console.error('局部导出数据失败:', error);
        alert(`局部导出数据失败: ${error.message}`);
    }
}        
// --- 新增：导出数据功能 (V2 版本标记版) ---
        async function exportData() {
            try {
                const dataToExport = {};
                for (const storeName in dbConfig) {
                    // 这部分逻辑和原来一样
                    if (['myProfile', 'apiSettings', 'squareApiSettings', 'forumSettings', 'userSettings'].includes(storeName)) {
                         dataToExport[storeName] = await kokoMemory.get(storeName, 'main');
                    } else {
                        dataToExport[storeName] = await kokoMemory.getAll(storeName);
                    }
                }

                const jsonString = JSON.stringify(dataToExport, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                
                // ✨ 核心改动：在文件名中加入数据库版本号
                const dbVersion = kokoMemory.version;
                a.download = `koko_backup_v${dbVersion}.json`;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                alert(`数据已成功导出为 ${a.download} 文件！`);
            } catch (error) {
                console.error('导出数据失败:', error);
                alert(`导出数据失败: ${error.message}`);
            }
        }
        
// --- 新增：导入数据功能 (V2 智能兼容版) ---
        async function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const confirmed = await showCustomConfirm('导入数据', '警告：导入数据将会覆盖当前所有数据！确定要继续吗？', true);
            if (!confirmed) {
                event.target.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const dataToImport = JSON.parse(e.target.result);
                    
                    // ✨ 核心改动：获取当前程序版本所支持的所有数据表名
                    const supportedStores = Object.keys(dbConfig);
                    let importedCount = 0;
                    let skippedCount = 0;

                    for (const storeName in dataToImport) {
                        // ✨ 核心判断：只导入当前程序认识的数据表
                        if (supportedStores.includes(storeName)) {
                            if (dataToImport[storeName]) {
                                await kokoMemory.clear(storeName);
                                if (Array.isArray(dataToImport[storeName])) {
                                    await kokoMemory.bulkPut(storeName, dataToImport[storeName]);
                                } else {
                                    await kokoMemory.put(storeName, dataToImport[storeName]);
                                }
                                importedCount++;
                            }
                        } else {
                            // 对于不认识的数据表，直接跳过
                            console.warn(`跳过导入：当前版本不包含数据表 "${storeName}"。`);
                            skippedCount++;
                        }
                    }
                    
                    let alertMessage = `数据导入完成！\n\n- 成功导入 ${importedCount} 个数据表。\n- 跳过了 ${skippedCount} 个不兼容的数据表。`;
                    if (skippedCount > 0) {
                        alertMessage += '\n\n（注意：部分新版本数据因不兼容已被忽略）';
                    }
                    alertMessage += '\n\n页面即将刷新以应用更改。';

                    alert(alertMessage);
                    setTimeout(() => window.location.reload(), 1500);

                } catch (error) {
                    console.error('导入数据失败:', error);
                    alert(`导入失败：文件格式可能不正确。错误信息: ${error.message}`);
                } finally {
                    event.target.value = '';
                }
            };
            reader.readAsText(file);
        }

        function showFeedStatus(text = '正在刷新论坛...') {
            if(feedStatusEl) {
                feedStatusEl.textContent = text;
                feedStatusEl.style.display = 'block';
            }
        }
        function hideFeedStatus() {
             if(feedStatusEl) {
                feedStatusEl.style.display = 'none';
            }
        }
        
        function renderMyProfile() {
            document.getElementById('my-profile-avatar').src = state.myProfile.avatar;
            document.getElementById('profile-name').textContent = state.myProfile.name;
            document.getElementById('profile-status').textContent = state.myProfile.status;
            document.getElementById('nickname-value').textContent = state.myProfile.name;
            document.getElementById('signature-value').textContent = state.myProfile.signature;
            document.getElementById('region-value').textContent = state.myProfile.region;
            document.getElementById('birthday-value').textContent = state.myProfile.birthday;
            document.getElementById('my-balance-value').textContent = `¥ ${state.myProfile.balance.toFixed(2)}`;
        }

        // ... 此处省略大量未修改的函数 (renderContacts, createContactItem 等) ...
        // ... The bulk of the functions from the original file remain unchanged ...
        
        // 此处省略了大量未修改的函数，它们与之前的版本完全相同
        // 确保您已经包含了从 renderContacts 到 handleAvatarUpload 的所有函数
        
        function fieldNameToChinese(field) {
            const map = { name: '昵称', signature: '个性签名', region: '地区', birthday: '生日', status: '状态', avatar: '头像URL' };
            return map[field] || field;
        }

 // ▼▼▼ 使用这个【全新的、带分组功能的版本】替换掉你旧的 renderContacts 函数 ▼▼▼
async function renderContacts() {
    const contactsContainer = document.querySelector('.contacts-container');
    contactsContainer.innerHTML = ''; // 先清空列表

    // 1. 获取所有需要的数据
    const allContacts = state.contacts;
    const allGroups = await kokoMemory.getAll('contactGroups') || [];

    // 2. 将联系人进行分类
    const pinnedContacts = allContacts.filter(c => c.isPinned);
    const nonPinnedContacts = allContacts.filter(c => !c.isPinned);

    const groupedContacts = allGroups.map(group => ({
        ...group,
        contacts: nonPinnedContacts.filter(c => c.groupId === group.id)
            // 组内按最后消息时间排序
            .sort((a, b) => (b.history?.slice(-1)[0]?.timestamp || 0) - (a.history?.slice(-1)[0]?.timestamp || 0))
    }));

    const ungroupedContacts = nonPinnedContacts.filter(c => !c.groupId)
        .sort((a, b) => (b.history?.slice(-1)[0]?.timestamp || 0) - (a.history?.slice(-1)[0]?.timestamp || 0));

    let hasContent = false;

    // 3. 按顺序渲染到界面上
    
    // 第一部分：渲染置顶联系人
    if (pinnedContacts.length > 0) {
        hasContent = true;
        const sectionTitle = document.createElement('div');
        sectionTitle.className = 'section-title';
        sectionTitle.textContent = '置顶聊天';
        contactsContainer.appendChild(sectionTitle);
        pinnedContacts.forEach(contact => contactsContainer.appendChild(createContactItem(contact)));
    }

    // 第二部分：渲染所有分组和其下的联系人
    groupedContacts.forEach(group => {
        if (group.contacts.length > 0) {
            hasContent = true;
            const sectionTitle = document.createElement('div');
            sectionTitle.className = 'section-title collapsible-title'; // 可折叠样式
            sectionTitle.innerHTML = `
                <span>${group.name}</span>
                <span class="collapse-icon">▼</span>
            `;
            contactsContainer.appendChild(sectionTitle);
            group.contacts.forEach(contact => contactsContainer.appendChild(createContactItem(contact)));
        }
    });

    // 第三部分：渲染未分组的联系人
    if (ungroupedContacts.length > 0) {
        hasContent = true;
        const sectionTitle = document.createElement('div');
        // 如果前面已经有分组了，这个标题就叫“其他联系人”，否则就叫“我的联系人”
        sectionTitle.className = `section-title ${groupedContacts.some(g => g.contacts.length > 0) ? 'collapsible-title' : ''}`;
        sectionTitle.innerHTML = `
            <span>我的联系人</span>
            ${groupedContacts.some(g => g.contacts.length > 0) ? '<span class="collapse-icon">▼</span>' : ''}
        `;
        contactsContainer.appendChild(sectionTitle);
        ungroupedContacts.forEach(contact => contactsContainer.appendChild(createContactItem(contact)));
    }

    // 第四部分：如果整个列表都是空的，显示提示信息
    if (!hasContent) {
        contactsContainer.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-user-plus" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有联系人</p><p>点击右上角"+"添加新联系人</p></div>`;
    }
}
        
// 用这个新版本替换掉你原来的 createContactItem 函数
function createContactItem(contact) {
    const item = document.createElement('div');
    item.className = 'contact-item';
    item.dataset.contactId = contact.id;
    const lastMessage = contact.history && contact.history.length > 0 ? contact.history[contact.history.length - 1] : null;

    // ▼▼▼ 核心改动点 ▼▼▼
    const isGroup = contact.isGroup === true;
    const groupMemberCount = isGroup ? `(${contact.members.length})` : '';
    // 如果是群聊，并且有最后一条消息，我们需要显示发言人的名字
    let lastMessageSenderName = '';
    if (isGroup && lastMessage && lastMessage.sender !== 'user') {
        const sender = state.contacts.find(c => c.id === lastMessage.sender);
        if(sender) {
            lastMessageSenderName = `${sender.name}: `;
        }
    }
    // ▲▲▲ 改动结束 ▲▲▲

    let lastMessageText;
    if (lastMessage) {
        // ... (这里的 switch case 逻辑保持不变) ...
        switch (lastMessage.type) {
            case 'html': lastMessageText = '[静态内容]'; break;
            case 'image': case 'picture_description': lastMessageText = '[图片]'; break;
            case 'voice': lastMessageText = '[语音]'; break;
            case 'red_packet': lastMessageText = '[红包]'; break;
            case 'transfer': lastMessageText = '[转账]'; break;
            case 'music_share': lastMessageText = `[音乐] ${lastMessage.content.title}`; break;
            case 'system_notification': lastMessageText = lastMessage.content; break;
            default: lastMessageText = lastMessage.content;
        }
        if (lastMessage.sender === 'user' && lastMessage.type !== 'system_notification') {
            lastMessageText = '我: ' + lastMessageText;
        }
    } else {
        lastMessageText = isGroup ? '快来发起第一次群聊吧！' : contact.persona;
    }
    
    // ▼▼▼ 核心改动点 ▼▼▼
    // ▼▼▼ 请用这段新代码替换 ▼▼▼
    let avatarHTML = '';
    if (isGroup) {
        // 如果是群聊，优先检查有没有自定义头像
        if (contact.avatar) {
            avatarHTML = `<img src="${contact.avatar}" onerror="this.onerror=null;this.src='httpshttps://via.placeholder.com/50/DDD/666?text=G';" alt="${contact.name}头像">`;
        } else {
            // 如果没有，再显示默认的群组图标
            avatarHTML = `<div style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; font-size: 22px; color: var(--theme-primary);"><i class="fas fa-users"></i></div>`;
        }
    } else {
        // 如果不是群聊，维持原来的逻辑
        avatarHTML = (contact.avatar ? `<img src="${contact.avatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/50/DDD/666?text=U';" alt="${contact.name}头像">` : `<i class="fas fa-user"></i>`);
    }
    // ▲▲▲ 改动结束 ▲▲▲

    item.innerHTML = `
        <div class="contact-avatar">${avatarHTML}</div>
        <div class="contact-info">
            <div class="contact-name">${contact.name} ${groupMemberCount}</div>
            <div class="contact-last-message"></div>
        </div>
        <div class="contact-time-info" style="text-align: right;">
            <i class="fas fa-ellipsis-v contact-options-btn" data-contact-id="${contact.id}"></i> 
            ${lastMessage ? `<div class="contact-time">${lastMessage.time}</div>` : ''}
            ${contact.unreadCount > 0 ? `<div class="unread-count">${contact.unreadCount}</div>` : ''}
        </div>
    `;
    // ▲▲▲ 替换结束 ▲▲▲
    
    // 使用 textContent 安全地插入消息，防止HTML注入
    item.querySelector('.contact-last-message').textContent = lastMessageSenderName + lastMessageText;
    item.querySelector('.contact-name').textContent = `${contact.name} ${groupMemberCount}`;

    return item;
}
        
// ✨✨✨ 用这个【完整、可折叠版】，替换旧的 renderWorldBooks 函数 ✨✨✨
async function renderWorldBooks() {
    const worldBookList = document.getElementById('world-book-list');
    worldBookList.innerHTML = '';

    if (state.worldBooks.length === 0) {
        worldBookList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-book" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有世界书</p><p>点击右上角"+"添加新世界书</p></div>`;
        return;
    }

    // 核心逻辑：按 category 分组
    const groupedBooks = state.worldBooks.reduce((acc, book) => {
        const category = book.category || '未分类';
        if (!acc[category]) {
            acc[category] = [];
        }
        acc[category].push(book);
        return acc;
    }, {});

    // 按照分类标题渲染
    for (const category in groupedBooks) {
        // 1. 创建分类标题
        const sectionTitle = document.createElement('div');
        sectionTitle.className = 'section-title collapsible-title'; // 加上新样式类
        sectionTitle.innerHTML = `
            <span>${category}</span>
            <span class="collapse-icon">▼</span>
        `;
        worldBookList.appendChild(sectionTitle);

        // 2. 渲染该分类下的所有书籍
        groupedBooks[category].forEach(book => {
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.dataset.bookId = book.id;
            bookItem.innerHTML = `
                <div class="book-header">
                    <div class="book-name">${book.name}</div>
                    <div class="preset-actions">
                        <span class="preset-action-btn delete delete-world-book-btn" title="删除世界书">
                            <i class="fas fa-trash-alt"></i>
                        </span>
                    </div>
                </div>
                <div class="book-content">${book.content.substring(0, 100)}...</div>
            `;
            
            bookItem.addEventListener('click', function() { 
                editWorldBook(this.dataset.bookId); 
            });

            const deleteBtn = bookItem.querySelector('.delete-world-book-btn');
            if (deleteBtn) {
                deleteBtn.addEventListener('click', deleteWorldBook);
            }
            
            worldBookList.appendChild(bookItem);
        });
    }
}
        
// ✨✨✨ 用这个【完整、可折叠版】，替换旧的 updateWorldBookSelectors 函数 ✨✨✨
function updateWorldBookSelectors() {
    const worldBookSelect = document.getElementById('world-book-select');
    const worldBookSelectorList = document.getElementById('world-book-selector-list');
    worldBookSelect.innerHTML = '';
    worldBookSelectorList.innerHTML = '';

    const noBookOption = document.createElement('option');
    noBookOption.value = '';
    noBookOption.textContent = '-- 无关联世界书 --';
    worldBookSelect.appendChild(noBookOption);
    
    // 同样先按 category 分组
    const groupedBooks = state.worldBooks.reduce((acc, book) => {
        const category = book.category || '未分类';
        if (!acc[category]) {
            acc[category] = [];
        }
        acc[category].push(book);
        return acc;
    }, {});

    // 按照分类渲染两个选择器
    for (const category in groupedBooks) {
        // --- 更新下拉选择器 (带分组) ---
        const optgroup = document.createElement('optgroup');
        optgroup.label = category;
        groupedBooks[category].forEach(book => {
            const option = document.createElement('option');
            option.value = book.id;
            option.textContent = book.name;
            optgroup.appendChild(option);
        });
        worldBookSelect.appendChild(optgroup);

        // --- 更新带复选框的选择器 (带分组标题) ---
        const categoryTitle = document.createElement('div');
        categoryTitle.className = 'section-title collapsible-title'; // 加上新样式类
        categoryTitle.style.paddingTop = '10px';
        categoryTitle.innerHTML = `
            <span>${category}</span>
            <span class="collapse-icon">▼</span>
        `;
        worldBookSelectorList.appendChild(categoryTitle);

        groupedBooks[category].forEach(book => {
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="book-setting-${book.id}" value="${book.id}"><label for="book-setting-${book.id}" class="world-book-name">${book.name}</label>`;
            worldBookSelectorList.appendChild(bookItem);
        });
    }
}

// --- 新版本 V2：createPostItem 函数 (列表页无头像/摘要版) ---
function createPostItem(post, isDetailView = false) {
    const postItem = document.createElement('div');
    postItem.className = 'post-item';
    if (!isDetailView) {
         postItem.dataset.postId = post.id;
    }

    const author = post.author;
    if (!author) return null;

    // 自动提取标题的逻辑保持不变
    let title = '';
    if (isDetailView) {
        title = post.title; // 详情页我们假设它有标题（虽然我们不显示）
    } else {
        const sentenceEndings = ['.', '。', '!', '！', '?', '？', '\n'];
        let firstSentenceIndex = -1;
        for (const ending of sentenceEndings) {
            const index = post.content.indexOf(ending);
            if (index !== -1 && (firstSentenceIndex === -1 || index < firstSentenceIndex)) {
                firstSentenceIndex = index;
            }
        }
        if (firstSentenceIndex !== -1 && firstSentenceIndex < 50) {
            title = post.content.substring(0, firstSentenceIndex + 1);
        } else if (post.content.length > 25) {
            title = post.content.substring(0, 25) + '...';
        } else {
            title = post.content;
        }
    }

    const authorName = author.name;
    const authorAvatar = author.avatar || 'https://via.placeholder.com/45/DDD/666?text=U';
    const isLiked = post.likes.includes(state.myProfile.name);

    let redPacketHTML = '';
    if (post.redPacket) {
        redPacketHTML = `<div class="forum-red-packet-card" data-post-id="${post.id}">...</div>`; 
    }

    // ▼▼▼▼▼▼▼▼▼▼▼▼▼ 核心修改在这里 ▼▼▼▼▼▼▼▼▼▼▼▼▼
    // 我们将为列表页和详情页生成完全不同的HTML结构

    if (isDetailView) {
        // --- 如果是帖子详情页，保持原有的完整布局 ---
        postItem.innerHTML = `
            <div class="post-delete-btn" data-post-id="${post.id}" title="删除帖子"><i class="fas fa-trash-alt"></i></div>
            <div class="post-item-avatar"><img src="${authorAvatar}" onerror="this.onerror=null;this.src='https://via.placeholder.com/45/DDD/666?text=U';" alt="${authorName}的头像"></div>
            <div class="post-content-area">
                <div>
                    <span class="post-author-name">${authorName}</span>
                    ${author.id && !author.id.startsWith('stranger_') ? `<span class="post-author-handle">@${author.id.replace('_','')}</span>` : ''}
                </div>
                ${ author.signature ? `<div class="post-author-signature">${author.signature}</div>` : '' }
                <div class="post-text">${parseMentions(post.content.replace(/\n/g, '<br>'))}</div>
                ${redPacketHTML}
                <div class="post-meta">${formatTimeAgo(post.timestamp)}</div>
                <div class="post-actions">
                    <span class="post-action-btn repost-btn" data-post-id="${post.id}"><i class="fas fa-retweet"></i> ${post.reposts > 0 ? post.reposts : '转发'}</span>
                    <span class="post-action-btn comment-btn" data-post-id="${post.id}"><i class="far fa-comment"></i> ${post.comments.length > 0 ? post.comments.length : '评论'}</span>
                    <span class="post-action-btn like-btn ${isLiked ? 'liked' : ''}" data-post-id="${post.id}"><i class="${isLiked ? 'fas' : 'far'} fa-heart"></i> ${post.likes.length > 0 ? post.likes.length : '赞'}</span>
                </div>
            </div>`;
// --- 新版本：将作者和时间戳包裹在同一个容器中 ---
} else {
    // --- 如果是论坛列表页... ---
    postItem.innerHTML = `
        <div class="post-delete-btn" data-post-id="${post.id}" title="删除帖子"><i class="fas fa-trash-alt"></i></div>
        <div class="post-content-area">
            <h3>${parseMentions(title)}</h3>

            <div class="post-card-meta-line">
                <span class="post-author-info">由 <strong>${authorName}</strong> 发布</span>
                <span class="post-meta">${formatTimeAgo(post.timestamp)}</span>
            </div>
            ${redPacketHTML}

            <div class="post-actions">
                <span class="post-action-btn repost-btn" data-post-id="${post.id}"><i class="fas fa-retweet"></i> ${post.reposts > 0 ? post.reposts : '转发'}</span>
                <span class="post-action-btn comment-btn" data-post-id="${post.id}"><i class="far fa-comment"></i> ${post.comments.length > 0 ? post.comments.length : '评论'}</span>
                <span class="post-action-btn like-btn ${isLiked ? 'liked' : ''}" data-post-id="${post.id}"><i class="${isLiked ? 'fas' : 'far'} fa-heart"></i> ${post.likes.length > 0 ? post.likes.length : '赞'}</span>
            </div>
        </div>`;
}

    return postItem;
}

        async function renderFeed() {
            const postsList = document.getElementById('posts-list');
            const tabsContainer = document.getElementById('feed-tabs-container');
            const subTabsContainer = document.getElementById('feed-sub-tabs-container');
            
 // --- 新代码：为按钮添加 Font Awesome 图标 ---
tabsContainer.innerHTML = `
    <button class="feed-tab-btn ${state.activeFeedTab === 'recommended' ? 'active' : ''}" data-tab="recommended"><i class="fas fa-home"></i> 推荐</button>
    <button class="feed-tab-btn ${state.activeFeedTab === 'following' ? 'active' : ''}" data-tab="following"><i class="fas fa-user-friends"></i> 关注</button>
    <button class="feed-tab-btn ${state.activeFeedTab === 'trending' ? 'active' : ''}" data-tab="trending"><i class="fas fa-fire"></i> 热搜</button>
`;

            if (state.activeFeedTab === 'recommended') {
                subTabsContainer.style.display = 'flex';
                 subTabsContainer.innerHTML = `
                    <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'daily' ? 'active' : ''}" data-subtab="daily">日常</button>
                    <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'food' ? 'active' : ''}" data-subtab="food">美食</button>
                    <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'gossip' ? 'active' : ''}" data-subtab="gossip">八卦</button>
                    <button class="feed-sub-tab-btn ${state.activeFeedSubTab === 'horror' ? 'active' : ''}" data-subtab="horror">恐怖</button>
                `;
            } else {
                subTabsContainer.style.display = 'none';
            }
            
            postsList.innerHTML = ''; 

            if (state.activeFeedTab === 'trending') {
                const trendingListEl = document.createElement('ol');
                trendingListEl.className = 'trending-list';
                
                if (state.trendingTopics.length === 0) {
                     trendingListEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>热搜榜空空如也，刷新一下试试？</p></div>`;
                } else {
                    state.trendingTopics.forEach((topic, index) => {
                        const item = document.createElement('li');
                        item.className = 'trending-item';
                        item.dataset.topicTitle = topic.title;
                        item.dataset.description = topic.description;
                        item.innerHTML = `
                            <div class="trending-rank ${index < 3 ? 'top-3' : ''}">${index + 1}</div>
                            <div class="trending-info">
                                <div class="trending-title">${topic.title}</div>
                                <div class="trending-meta"><i class="fas fa-fire" style="color: #ff8a65;"></i> ${topic.heat}万</div>
                            </div>
                            ${topic.tag ? `<div class="trending-tag">${topic.tag}</div>` : ''}
                        `;
                        trendingListEl.appendChild(item);
                    });
                }
                postsList.appendChild(trendingListEl);
                return;
            }

            let postsToShow = [];
            const contactIds = state.contacts.map(c => c.id);

            // 【核心修改】所有帖子筛选前，先按当前激活的存档ID过滤一遍！
            const activePosts = state.posts.filter(p => p.archiveId === state.activeForumArchiveId);

            if (state.activeFeedTab === 'following') {
                postsToShow = activePosts.filter(p => p.author.id === 'myProfile' || contactIds.includes(p.author.id));
            } else { 
                postsToShow = activePosts.filter(p => p.category === state.activeFeedSubTab);
            }
            
            const sortedPosts = [...postsToShow].sort((a, b) => b.timestamp - a.timestamp);
            
            const postsToDisplay = (state.activeFeedTab === 'following') ? sortedPosts : sortedPosts.slice(0, state.postsToDisplay);

            if (postsToDisplay.length === 0) {
                const emptyMessage = state.activeFeedTab === 'following' 
                    ? '你关注的人还没有发布动态哦'
                    : '这里空空如也，点击右上角刷新看看';
                postsList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-couch" style="font-size: 48px; margin-bottom: 15px;"></i><p>${emptyMessage}</p></div>`;
            } else {
                postsToDisplay.forEach(post => {
                    const postItem = createPostItem(post);
                    if (postItem) postsList.appendChild(postItem);
                });
            }
        }

        async function renderUserPersonaPresets() {
            const userPersonaPresetsList = document.getElementById('user-persona-presets-list');
            const noUserPersonaMessage = document.getElementById('no-user-persona-message');
            userPersonaPresetsList.innerHTML = '';
            noUserPersonaMessage.style.display = state.userPersonaPresets.length === 0 ? 'block' : 'none';
            state.userPersonaPresets.forEach(preset => {
                const presetItem = document.createElement('div');
                presetItem.className = 'preset-item';
                presetItem.dataset.presetId = preset.id;
                presetItem.innerHTML = `<div class="preset-info"><div class="preset-name">${preset.name}</div><div class="preset-desc">${preset.description}</div></div><div class="preset-actions"><span class="preset-action-btn edit-preset-btn" title="编辑面具"><i class="fas fa-edit"></i></span><span class="preset-action-btn delete delete-preset-btn" title="删除面具"><i class="fas fa-trash-alt"></i></span></div>`;
                userPersonaPresetsList.appendChild(presetItem);
            });
            userPersonaPresetsList.querySelectorAll('.edit-preset-btn').forEach(btn => btn.addEventListener('click', editUserPersonaPreset));
            
            await updateUserPersonaPresetSelect();
        }
        
// --- 用这个新版本，替换掉你旧的 renderThoughtPresets 函数 ---

async function renderThoughtPresets() {
    const thoughtPresetsList = document.getElementById('thought-presets-list');
    const noThoughtPresetMessage = document.getElementById('no-thought-preset-message');
    thoughtPresetsList.innerHTML = '';
    noThoughtPresetMessage.style.display = state.thoughtPresets.length === 0 ? 'block' : 'none';
    
    state.thoughtPresets.forEach(preset => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.presetId = preset.id;

        // ▼▼▼ 核心修改在这里 ▼▼▼
        
        let actionButtonsHTML = ''; // 默认先创建一个空的按钮容器

        // 判断：如果当前预设的ID不是我们要保护的那一个
        if (preset.id !== 'deep_roleplay_regex') {
            // 就为它正常生成编辑和删除按钮
            actionButtonsHTML = `
                <div class="preset-actions">
                    <span class="preset-action-btn edit-thought-preset-btn" title="编辑预设">
                        <i class="fas fa-edit"></i>
                    </span>
                    <span class="preset-action-btn delete delete-thought-preset-btn" title="删除预设">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
        }
        // 如果是 'deep_roleplay_regex'，actionButtonsHTML 就会是空的，按钮自然就消失了

        // 最后，将按钮HTML（可能为空）拼接到最终的列表项里
        item.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${preset.name}</div>
                <div class="preset-desc" style="white-space: pre-wrap;">${preset.prompt}</div>
            </div>
            ${actionButtonsHTML} 
        `;
        
        // ▲▲▲ 修改结束 ▲▲▲
        
        thoughtPresetsList.appendChild(item);
    });

    // 这部分事件绑定的代码保持不变
    // (因为现在是整个列表监听点击，所以即便按钮不存在也不会报错)
}

        async function renderEmoticonLibrary() {
            const grid = document.getElementById('emoticon-library-grid');
            const noEmoticonMsg = document.getElementById('no-emoticon-message');
            grid.innerHTML = '';

            if (state.emoticons.length === 0) {
                noEmoticonMsg.style.display = 'block';
            } else {
                noEmoticonMsg.style.display = 'none';
                state.emoticons.forEach(emo => {
                    const item = document.createElement('div');
                    item.className = 'emoticon-item';
                    item.innerHTML = `
                        <img src="${emo.url}" alt="${emo.name}" onerror="this.src='https://via.placeholder.com/60?text=Error'; this.alt='图片加载失败';">
                        <div class="emoticon-name">${emo.name}</div>
                        <button class="emoticon-delete-btn" data-emoticon-id="${emo.id}">&times;</button>
                    `;
                    grid.appendChild(item);
                });

                grid.querySelectorAll('.emoticon-delete-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const emoticonId = e.currentTarget.dataset.emoticonId;
                        const confirmed = await showCustomConfirm('删除表情包', '确定要删除这个表情包吗？', true);
                        if (confirmed) {
                            state.emoticons = state.emoticons.filter(e => e.id !== emoticonId);
                            await kokoMemory.delete('emoticons', emoticonId);
                            await renderEmoticonLibrary();
                        }
                    });
                });
            }
        }

        async function renderMusicLibrary() {
            const list = document.getElementById('music-library-list');
            const noMusicMsg = document.getElementById('no-music-message');
            list.innerHTML = '';

            if (state.musicLibrary.length === 0) {
                noMusicMsg.style.display = 'block';
            } else {
                noMusicMsg.style.display = 'none';
                state.musicLibrary.forEach(song => {
                    const item = document.createElement('div');
                    item.className = 'music-item';
                    item.innerHTML = `
                        <div class="music-info">
                            <div class="music-title">${song.title}</div>
                            <div class="music-artist">${song.artist}</div>
                        </div>
                        <button class="music-delete-btn" data-music-id="${song.id}"><i class="fas fa-trash-alt"></i></button>
                    `;
                    list.appendChild(item);
                });

                list.querySelectorAll('.music-delete-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const musicId = e.currentTarget.dataset.musicId;
                        const confirmed = await showCustomConfirm('删除歌曲', '确定要从曲库删除这首歌吗？', true);
                        if (confirmed) {
                            state.musicLibrary = state.musicLibrary.filter(s => s.id !== musicId);
                            await kokoMemory.delete('musicLibrary', musicId);
                            await renderMusicLibrary();
                        }
                    });
                });
            }
        }

        function renderMusicPickerInModal() {
            const picker = document.getElementById('music-library-picker');
            picker.innerHTML = '';

            if (state.musicLibrary.length > 0) {
                picker.innerHTML = '<div class="picker-title">从曲库选择</div>';
                const list = document.createElement('div');
                list.className = 'picker-list';
                state.musicLibrary.forEach(song => {
                    const item = document.createElement('div');
                    item.className = 'picker-item';
                    item.textContent = `${song.title} - ${song.artist}`;
                    item.addEventListener('click', () => {
                        document.getElementById('send-music-title-input').value = song.title;
                        document.getElementById('send-music-artist-input').value = song.artist;
                        document.getElementById('send-music-url-input').value = song.url;
                        // ▼▼▼ 在这里添加填充歌词的代码 ▼▼▼
                        document.getElementById('send-music-lrc-input').value = song.lrc || '';
                    });
                    list.appendChild(item);
                });
                picker.appendChild(list);
            } else {
                picker.innerHTML = '<div class="picker-title" style="text-align:center; color:#999;">你的曲库是空的</div>';
            }
        }

        function renderEmoticonPicker() {
            const emoticonPicker = document.getElementById('emoticon-picker');
            emoticonPicker.innerHTML = '';
            if (state.emoticons.length > 0) {
                state.emoticons.forEach(emo => {
                    const item = document.createElement('div');
                    item.className = 'emoticon-item';
                    item.innerHTML = `<img src="${emo.url}" alt="${emo.name}">`;
                    item.addEventListener('click', async () => {
                        await createAndAddMessage({ 
                            type: 'image', 
                            url: emo.url,
                            isEmoticon: true,
                            emoticonName: emo.name
                        });
                        emoticonPicker.classList.remove('active');
                    });
                    emoticonPicker.appendChild(item);
                });
            } else {
                emoticonPicker.innerHTML = '<div style="color: #999; text-align: center; grid-column: 1 / -1;">表情包库是空的</div>';
            }
        }

        function renderWalletScreen() {
            const listEl = document.getElementById('transaction-list');
            const noTransactionMsg = document.getElementById('no-transaction-message');
            listEl.innerHTML = '';

            if (!state.transactions || state.transactions.length === 0) {
                noTransactionMsg.style.display = 'block';
                return;
            }
            noTransactionMsg.style.display = 'none';

            const sortedTransactions = [...state.transactions].sort((a, b) => b.timestamp - a.timestamp);

            sortedTransactions.forEach(tx => {
                const item = document.createElement('div');
                item.className = 'transaction-item';
                const amountClass = tx.type === 'income' ? 'income' : 'expense';
                const amountSign = tx.type === 'income' ? '+' : '-';

                item.innerHTML = `
                    <div class="transaction-info">
                        <div class="desc">${tx.description}</div>
                        <div class="time">${new Date(tx.timestamp).toLocaleString()}</div>
                    </div>
                    <div class="transaction-amount ${amountClass}">
                        ${amountSign}${tx.amount.toFixed(2)}
                    </div>
                `;
                listEl.appendChild(item);
            });
        }


        async function updateUserPersonaPresetSelect() {
            const selectUserPersonaPreset = document.getElementById('select-user-persona-preset');
            selectUserPersonaPreset.innerHTML = '<option value="">-- 选择或输入自定义面具 --</option>';
            state.userPersonaPresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                selectUserPersonaPreset.appendChild(option);
            });
        }

        async function populateThoughtPresetSelect() {
            const select = document.getElementById('thought-preset-select');
            const currentVal = select.value;
            select.innerHTML = '';
            
            const noPresetOption = document.createElement('option');
            noPresetOption.value = ""; 
            noPresetOption.textContent = "-- 无预设 (使用默认角色扮演) --";
            select.appendChild(noPresetOption);

            if (state.thoughtPresets.length === 0) {
                return;
            }
            state.thoughtPresets.forEach(preset => {
                const option = document.createElement('option');
                option.value = preset.id;
                option.textContent = preset.name;
                select.appendChild(option);
            });

            if (state.thoughtPresets.some(p => p.id === currentVal) || currentVal === "") {
                select.value = currentVal;
            }
        }

        async function updateNotificationDots() {
            const dots = document.querySelectorAll('.moments-notification-dot');
            if (state.hasNewPosts) {
                dots.forEach(dot => dot.style.display = 'block');
            } else {
                dots.forEach(dot => dot.style.display = 'none');
            }
        }
        
        function formatTimeAgo(timestamp) {
            return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        function parseMentions(text) {
            if (!text) return '';
            const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
            return text.replace(mentionRegex, (match) => {
                return `<span class="mention">${match}</span>`;
            });
        }

       
// 修正后的代码
function hideAllScreens() {
    document.querySelectorAll(
        '#screen > div, #wallet-screen, #appearance-settings-screen, #shopping-screen, #product-detail-screen, #forum-archives-screen, #map-screen, #map-management-screen, #schedule-screen, #events-screen, #lock-screen-photos-screen, #relationship-network-screen' // <-- 确保这里有它！
    ).forEach(el => el.style.display = 'none');
}

        function setActiveNav(activeNavId) {
            document.querySelectorAll('.bottom-nav .nav-item').forEach(item => {
                item.classList.remove('active');
                if (item.id.includes(activeNavId)) {
                    item.classList.add('active');
                }
            });
        }
        
        async function showMainScreen() { hideAllScreens(); document.getElementById('main-screen').style.display = 'flex'; setActiveNav('chat'); await renderContacts(); }
        function showDiscoverScreen() { hideAllScreens(); document.getElementById('discover-screen').style.display = 'flex'; setActiveNav('discover'); }
        async function showProfileScreen() { hideAllScreens(); document.getElementById('profile-screen').style.display = 'flex'; setActiveNav('profile'); await renderMyProfile(); }
        
        async function showFeedScreen() { 
            hideAllScreens(); 
            document.getElementById('moments-screen').style.display = 'flex'; 
            if (state.hasNewPosts) {
                state.hasNewPosts = false;
                updateNotificationDots();
            }
            //自动刷新功能注释掉，Produced by Kiko
            //if (isInitialPostLoad && state.posts.length === 0) {
                 //if (state.trendingTopics.length === 0) {
                    //await generateRandomTrendingTopicsAI();
                //}
                //await generatePostsForRecommendedTab(10);
                //isInitialPostLoad = false;
            //}
            await renderFeed();
        }

        async function showPostDetailScreen(postId) {
            state.activePostId = postId;
            hideAllScreens();
            document.getElementById('post-detail-screen').style.display = 'flex';
            await renderPostDetail();
        }
        
        async function showTrendingTopicScreen(topicTitle, topicDescription) {
            hideAllScreens();
            const screen = document.getElementById('trending-topic-screen');
            screen.style.display = 'flex';

            // 填充标题和描述 (这部分不变)
            document.getElementById('trending-topic-title').textContent = `# ${topicTitle.replace(/#/g, '')} #`;

            const descriptionContainer = document.getElementById('trending-topic-description-container');
            if (topicDescription) {
                descriptionContainer.textContent = topicDescription;
                descriptionContainer.style.display = 'block';
            } else {
                descriptionContainer.style.display = 'none';
            }

            const listEl = document.getElementById('trending-topic-posts-list');
            listEl.innerHTML = '';

            // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼

            // 1. 提取不带#号的核心关键词，让搜索更灵活
            const coreTopic = topicTitle.replace(/#/g, "").trim();

            // 2. 关键修复：筛选时，必须同时满足两个条件：
            //    - 帖子必须属于当前激活的“世界线” (archiveId)
            //    - 帖子的内容必须包含这个核心关键词
            const relatedPosts = state.posts.filter(p =>
                p.archiveId === state.activeForumArchiveId && p.content.includes(coreTopic)
            );

            // ▲▲▲▲▲▲▲▲▲▲ 修复结束 ▲▲▲▲▲▲▲▲▲▲


            if (relatedPosts.length === 0) {
                 listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-comment-slash" style="font-size: 48px; margin-bottom: 15px;"></i><p>该话题下还没有帖子</p></div>`;
                 return;
            }

            relatedPosts.sort((a,b) => b.timestamp - a.timestamp).forEach(post => {
                const postItem = createPostItem(post);
                if (postItem) listEl.appendChild(postItem);
            });
        }

        async function showThoughtPresetManagementScreen() { hideAllScreens(); document.getElementById('thought-preset-management-screen').style.display = 'flex'; await renderThoughtPresets(); }
        async function showEmoticonLibraryScreen() { hideAllScreens(); document.getElementById('emoticon-library-screen').style.display = 'flex'; await renderEmoticonLibrary(); }
        async function showMusicLibraryScreen() { hideAllScreens(); document.getElementById('music-library-screen').style.display = 'flex'; await renderMusicLibrary(); }
        async function showUserPersonaManagementScreen() { hideAllScreens(); document.getElementById('user-persona-management-screen').style.display = 'flex'; await renderUserPersonaPresets(); }

        async function showCharProfileScreen() {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            
            const diaryButton = document.getElementById('view-char-diary-btn');
            if (contact.isGroup) {
                // 如果是群聊，就隐藏日记按钮
                diaryButton.style.display = 'none';
            } else {
                // 如果是个人，就确保日记按钮是显示的
                diaryButton.style.display = 'flex';
            }
            
            batchedPetActions = [];
            
            document.getElementById('char-profile-avatar').src = contact.avatar || `https://via.placeholder.com/70/DDD/666?text=${contact.name.substring(0,1).toUpperCase()}`;
            document.getElementById('char-profile-name').textContent = contact.name;
            document.getElementById('char-name-value').textContent = contact.name;
            document.getElementById('char-signature-value').textContent = contact.signature || '未设置';
            document.getElementById('char-profile-signature-display').textContent = `个性签名: ${contact.signature || '...'}`;


            hideAllScreens();
            document.getElementById('char-profile-screen').style.display = 'flex';

            renderPet(contact);
        }

        // --- MODIFIED: V7.0 修改为“小窝时光胶囊” ---
        async function showMemoryAlbum(contact) {
            hideAllScreens();
            document.getElementById('memory-album-screen').style.display = 'flex';
            renderMemoryAlbum(contact);
        }

        // --- MODIFIED: V7.0 渲染全新的时光胶囊 ---
        function renderMemoryAlbum(contact) {
            const listEl = document.getElementById('memory-album-list');
            listEl.innerHTML = '';
            if (!contact) return;

            // 格式化时长
            function formatDuration(totalSeconds) {
                if (!totalSeconds) return '0 分钟';
                const hours = Math.floor(totalSeconds / 3600);
                const minutes = Math.floor((totalSeconds % 3600) / 60);
                let result = '';
                if (hours > 0) result += `${hours} 小时 `;
                if (minutes > 0 || hours === 0) result += `${minutes} 分钟`;
                return result.trim();
            }

            const daysSinceFirstChat = Math.floor((Date.now() - contact.firstChatDate) / (1000 * 60 * 60 * 24));

            let albumHTML = `
                <div class="album-section">
                    <div class="album-section-title">我们的里程碑</div>
                    <div class="album-milestone-item">
                        <span class="album-item-icon"><i class="fas fa-calendar-check"></i></span>
                        <span class="album-item-label">初次相遇</span>
                        <span class="album-item-value">${new Date(contact.firstChatDate).toLocaleDateString()}</span>
                    </div>
                    <div class="album-milestone-item">
                        <span class="album-item-icon"><i class="fas fa-heart"></i></span>
                        <span class="album-item-label">已相识</span>
                        <span class="album-item-value">${daysSinceFirstChat} 天</span>
                    </div>
                </div>

                <div class="album-section">
                    <div class="album-section-title">共同的记忆</div>
                     <div class="album-stat-item">
                        <span class="album-item-icon"><i class="fas fa-music"></i></span>
                        <span class="album-item-label">一起听歌</span>
                        <span class="album-item-value">${formatDuration(contact.totalListenTime)}</span>
                    </div>
                </div>

                <div class="album-section">
                    <div class="album-section-title">珍藏的瞬间</div>
                    <div class="album-memory-grid" id="memory-grid-content">
                        </div>
                </div>
            `;
            listEl.innerHTML = albumHTML;

            const gridContent = document.getElementById('memory-grid-content');
            if (!contact.memories || contact.memories.length === 0) {
                 gridContent.innerHTML = `<p style="color:#888; grid-column: 1 / -1;">还没有珍藏的瞬间...</p>`;
            } else {
                 const sortedMemories = [...contact.memories].sort((a, b) => b.timestamp - a.timestamp);
                 sortedMemories.forEach(memo => {
                    const entryEl = document.createElement('div');
                    entryEl.className = 'album-memory-item';
                    entryEl.title = new Date(memo.timestamp).toLocaleString();
                    entryEl.innerHTML = `<i class="fas fa-quote-left"></i> ${memo.description}`;
                    gridContent.appendChild(entryEl);
                });
            }
        }
// ==========================================================
// =========== ▼▼▼ 新增：API格式转换引擎 ▼▼▼ =================
// ==========================================================

/**
 * 将 OpenAI 格式的请求体，转换为 Gemini 格式
 * @param {object} openAiPayload - OpenAI 格式的请求体
 * @returns {object} Gemini 格式的请求体
 */
function convertOpenAiToGemini(openAiPayload) {
    const geminiContents = [];
    let lastRole = "";
    // Gemini 要求 system prompt 必须在最前面，且不能连续出现
    const systemPrompt = openAiPayload.messages.find(msg => msg.role === 'system');
    const chatMessages = openAiPayload.messages.filter(msg => msg.role !== 'system');

    for (const msg of chatMessages) {
        // 角色转换：'assistant' -> 'model', 其他 ('user', 'system') -> 'user'
        let role = (msg.role === 'assistant') ? 'model' : 'user';
        
        // Gemini 严格要求 user 和 model 角色交替出现
        if (role === lastRole && geminiContents.length > 0) {
            // 如果连续出现同角色，将内容合并到上一个条目的 parts 里
            geminiContents[geminiContents.length - 1].parts.push({ text: msg.content });
        } else {
            // 否则，正常添加新角色条目
            geminiContents.push({
                role: role,
                parts: [{ text: msg.content }]
            });
            lastRole = role;
        }
    }

    const geminiPayload = { contents: geminiContents };
    // 如果有 system prompt，将其作为特殊参数添加
    if(systemPrompt) {
        geminiPayload.systemInstruction = {
            role: 'user', // Gemini 的 system prompt 角色也是 user
            parts: [{text: systemPrompt.content}]
        }
    }
    
    return geminiPayload;
}


/**
 * 将 Gemini API 的响应体，转换为 OpenAI 格式
 * @param {object} geminiData - 从 Gemini API 收到的原始响应数据
 * @param {string} modelId - App 请求时使用的模型ID
 * @returns {object} OpenAI 格式的响应体
 */
function convertGeminiToOpenAi(geminiData, modelId) {
    // 检查是否有有效内容返回
    if (!geminiData.candidates || geminiData.candidates.length === 0 || !geminiData.candidates[0].content || !geminiData.candidates[0].content.parts) {
        // 如果 Gemini 因为安全或其他原因阻止了回复，这里会没有 candidates
        const blockReason = geminiData.promptFeedback?.blockReason || '未知原因';
        const safetyRatings = geminiData.promptFeedback?.safetyRatings?.map(r => `${r.category}: ${r.probability}`).join(', ') || '无';
        
        return {
            choices: [{
                message: {
                    role: "assistant",
                    content: `抱歉，Gemini API 阻止了回复。原因: ${blockReason}。安全评级: ${safetyRatings}`
                },
                finish_reason: "stop",
            }]
        };
    }
    
    const responseContent = geminiData.candidates[0].content.parts[0].text;

    const openAIResponse = {
        id: "chatcmpl-" + Date.now(),
        object: "chat.completion",
        created: Math.floor(Date.now() / 1000),
        model: modelId,
        choices: [{
            index: 0,
            message: {
                role: "assistant",
                content: responseContent,
            },
            finish_reason: "stop",
        }],
        usage: { // 伪造 usage 数据，有些客户端需要这个
            prompt_tokens: 0,
            completion_tokens: 0,
            total_tokens: 0,
        }
    };
    
    return openAIResponse;
}

// ==========================================================
// =========== ▲▲▲ 新增代码粘贴到此结束 ▲▲▲ =================
// ==========================================================


        async function editUserPersonaPreset(event) {
            event.stopPropagation();
            const presetId = event.currentTarget.closest('.preset-item').dataset.presetId;
            const preset = state.userPersonaPresets.find(p => p.id === presetId);
            if (preset) {
                editingUserPersonaId = presetId;
                document.getElementById('user-persona-modal-title').textContent = '编辑用户面具预设';
                document.getElementById('user-persona-name-input').value = preset.name;
                document.getElementById('user-persona-description-input').value = preset.description;
                document.getElementById('user-persona-preset-modal').style.display = 'flex';
            }
        }

// ▼▼▼ 请用这个【最终修正版】完整替换旧函数 ▼▼▼
async function deleteUserPersonaPreset(event) {
    event.stopPropagation(); // 阻止事件冒泡

    const confirmed = await showCustomConfirm('删除面具', '确定要删除此用户面具预设吗？', true);
    if (!confirmed) {
        return; // 用户点击了“取消”
    }
    
    // --- 核心修正点在这里 ---
    // 我们需要从 event.target (实际被点击的元素) 来查找父级
    const presetItem = event.target.closest('.preset-item');
    if (!presetItem) {
        console.error("删除失败：无法找到 preset-item 元素。");
        return;
    }
    const presetId = presetItem.dataset.presetId;
    // --- 修正结束 ---

    if (!presetId) {
        console.error("删除失败：无法在HTML元素上找到预设ID。");
        return;
    }

    const presetToDelete = state.userPersonaPresets.find(p => p.id === presetId);

    // 1. 从程序的内存（state）中过滤掉这个预设
    state.userPersonaPresets = state.userPersonaPresets.filter(p => p.id !== presetId);

    // 2. 从浏览器的数据库中删除这条记录
    await kokoMemory.delete('userPersonaPresets', presetId);

    // 3. 自动清理所有联系人对这个已删除面具的引用
    if (presetToDelete) {
        for (const contact of state.contacts) {
            if (contact.userPersona === presetToDelete.description) {
                contact.userPersona = ''; // 清空这个设置
                await kokoMemory.put('contacts', contact); // 保存对联系人的修改
            }
        }
    }

    // 4. 重新渲染预设列表，让界面立刻刷新
    await renderUserPersonaPresets();
}
// ▲▲▲ 替换到这里结束 ▲▲▲
        /**
 * 删除一本世界书
 */
async function deleteWorldBook(event) {
    // 这行是防止点击删除时，意外触发了进入编辑页面的效果
    event.stopPropagation(); 

    const bookId = event.currentTarget.closest('.world-book-item').dataset.bookId;
    const book = state.worldBooks.find(b => b.id === bookId);
    if (!book) return;

    // 弹出确认框，防止误删
    const confirmed = await showCustomConfirm('删除世界书', `确定要删除《${book.name}》吗？\n\n注意：如果任何联系人正在使用这本书，他们的关联也会被解除。`, true);

    if (confirmed) {
        // 1. 从 state 缓存中删除这本书
        state.worldBooks = state.worldBooks.filter(b => b.id !== bookId);

        // 2. 从数据库中删除这本书
        await kokoMemory.delete('worldBooks', bookId);

        // 3. (重要!) 检查并移除所有联系人对这本书的引用
        state.contacts.forEach(contact => {
            if (contact.worldBooks && contact.worldBooks.includes(bookId)) {
                contact.worldBooks = contact.worldBooks.filter(id => id !== bookId);
                // 异步保存对联系人的修改，不阻塞后续UI更新
                kokoMemory.put('contacts', contact); 
            }
        });

        // 4. 重新渲染世界书列表，让界面刷新
        await renderWorldBooks();

        // 5. 更新所有用到世界书的下拉选择器
        await updateWorldBookSelectors();
    }
}

// --- 用这个新版本，替换掉旧的 editThoughtPreset 函数 ---

async function editThoughtPreset(event) {
    event.stopPropagation();
    
    // ▼▼▼ 核心修正点 ▼▼▼
    // 将 event.currentTarget 修改为 event.target，和删除按钮的逻辑保持一致
    const presetId = event.target.closest('.preset-item').dataset.presetId;
    // ▲▲▲ 修正结束 ▲▲▲

    const preset = state.thoughtPresets.find(p => p.id === presetId);
    if (preset) {
        editingThoughtPresetId = presetId;
        document.getElementById('thought-preset-modal-title').textContent = '编辑思维预设';
        document.getElementById('thought-preset-name-input').value = preset.name;
        document.getElementById('thought-preset-prompt-input').value = preset.prompt;
        document.getElementById('thought-preset-modal').style.display = 'flex';
    }
}

// --- 用这个新版本，替换掉旧的 deleteThoughtPreset 函数 ---

async function deleteThoughtPreset(event) {
    event.stopPropagation();
    const confirmed = await showCustomConfirm('删除预设', '确定要删除此思维预设吗？', true);
    if (confirmed) {
        // 核心修正：和修复好的“面具预设”一样，使用 event.target
        const presetItem = event.target.closest('.preset-item');
        if (!presetItem) {
            console.error("删除失败：无法找到 preset-item 元素。");
            return;
        }
        const presetId = presetItem.dataset.presetId;
        
        // 后续的删除逻辑保持不变
        state.thoughtPresets = state.thoughtPresets.filter(p => p.id !== presetId);
        await kokoMemory.delete('thoughtPresets', presetId);
        await renderThoughtPresets(); // 重新渲染列表
    }
}

        function findAuthorById(authorId) {
            if (authorId === 'myProfile') {
                return { id: 'myProfile', ...state.myProfile };
            }
            return state.contacts.find(c => c.id === authorId);
        }
        
        async function toggleLike(event) {
            event.stopPropagation();
            const postId = event.currentTarget.dataset.postId;
            const post = state.posts.find(p => p.id === postId);
            if (post) {
                const myName = state.myProfile.name;
                const likeIndex = post.likes.indexOf(myName);
                if (likeIndex === -1) {
                    post.likes.push(myName);
                } else {
                    post.likes.splice(likeIndex, 1);
                }
                await kokoMemory.put('posts', post);
                
                if (document.getElementById('moments-screen').style.display === 'flex') {
                    await renderFeed(); 
                } else if (document.getElementById('post-detail-screen').style.display === 'flex') {
                    await renderPostDetail();
                }
            }
        }
        
        function editWorldBook(bookId) {
            const book = state.worldBooks.find(b => b.id === bookId);
            if (book) {
                editingBookId = bookId;
                document.getElementById('world-book-modal-title').textContent = '编辑世界书';
                document.getElementById('book-name-input').value = book.name;
                document.getElementById('book-content-input').value = book.content;
                document.getElementById('add-world-book-modal').style.display = 'flex';
            }
        }
        
// ▼▼▼ 使用这个【新版本】替换掉您原来的 fetchModels 函数 ▼▼▼
async function fetchModels(endpointBase, apiKey, modelSelectEl, btn) {
    btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 拉取中';
    btn.disabled = true;

    if (!endpointBase) {
        alert('请输入API基础地址');
        btn.innerHTML = '<i class="fas fa-sync-alt"></i> 拉取';
        btn.disabled = false;
        return;
    }

    let fetchUrl;
    let fetchOptions = {};

    if (endpointBase.includes('generativelanguage.googleapis.com')) {
        console.log("正在使用 Gemini 方式拉取模型...");
        fetchUrl = `https://${endpointBase}/v1beta/models?key=${apiKey}`;
        fetchOptions = {}; 
    } else {
        console.log("正在使用 OpenAI 兼容方式拉取模型...");
        
        // ★★★ 核心修改在这里 ★★★
        const cleanEndpoint = normalizeApiEndpoint(endpointBase); // 1. 清洁地址
        fetchUrl = `${cleanEndpoint}/v1/models`; // 2. 安全拼接
        
        fetchOptions = { headers: { 'Authorization': `Bearer ${apiKey}` } };
    }

    try {
        const response = await fetch(fetchUrl, fetchOptions);
        if (!response.ok) {
            const errorData = await response.json();
            if (errorData.error && errorData.error.message) {
                 throw new Error(errorData.error.message);
            }
            throw new Error('未知的网络错误');
        };
        const data = await response.json();
        
        let models;
        if (data.models) { 
            models = data.models.map(model => model.name.replace('models/', '')).sort();
        } else if (data.data) {
            models = data.data.map(model => model.id).sort();
        } else {
            models = [];
        }

        updateModelDropdown(models, modelSelectEl, modelSelectEl.value);
        alert(`成功拉取 ${models.length} 个模型！`);
    } catch (error) {
        console.error('拉取模型失败:', error);
        alert(`拉取模型失败: ${error.message}\n\n请检查基础地址和API密钥是否正确。`);
    } finally {
        btn.innerHTML = '<i class="fas fa-sync-alt"></i> 拉取';
        btn.disabled = false;
    }
}
// ==========================================================
// =========== ▼▼▼ 把这个新函数粘贴到您的代码里 ▼▼▼ ==========
// ==========================================================
/**
 * 规范化API端点地址，移除末尾的 / 和 /v1
 * @param {string} endpoint - 用户输入的原始端点地址
 * @returns {string} - 返回一个干净的、不带/v1的基础地址
 */
function normalizeApiEndpoint(endpoint) {
    if (!endpoint) return '';
    let url = endpoint.trim();
    // 循环移除末尾的斜杠，防止用户输入多个 (e.g., "https://api.com//")
    while (url.endsWith('/')) {
        url = url.slice(0, -1);
    }
    // 移除末尾的 /v1
    if (url.endsWith('/v1')) {
        url = url.slice(0, -3);
    }
    return url;
}
// ==========================================================
// =========== ▲▲▲ 新函数粘贴到此结束 ▲▲▲ =================
// ==========================================================
        
        function updateModelDropdown(models, modelSelect, currentModel) {
            modelSelect.innerHTML = ''; 

            if (models && models.length > 0) {
                models.forEach(modelId => {
                    const option = document.createElement('option');
                    option.value = modelId;
                    option.textContent = modelId;
                    if (modelId === currentModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });
            } else if (currentModel) { 
                const option = document.createElement('option');
                option.value = currentModel;
                option.textContent = currentModel;
                option.selected = true;
                modelSelect.appendChild(option);
            } else {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "未能拉取到模型或列表为空";
                modelSelect.appendChild(option);
            }
        }

        const MESSAGES_PER_PAGE = 30;

        function enterEditMode() {
            editModeState.active = true;
            editModeState.selectedMessageIds.clear();
            document.getElementById('chat-screen').classList.add('chat-screen-edit-mode');
            document.getElementById('chat-input-area').style.display = 'none';
            document.getElementById('edit-mode-bar').style.display = 'flex';
            renderChatMessages(state.contacts.find(c => c.id === state.activeChatId)); 
        }

        async function exitEditMode() {
            editModeState.active = false;
            document.getElementById('chat-screen').classList.remove('chat-screen-edit-mode');
            document.getElementById('chat-input-area').style.display = 'flex';
            document.getElementById('edit-mode-bar').style.display = 'none';
            await openChat(state.activeChatId);
        }

        function handleMessageSelection(wrapper, message) {
            if (!editModeState.active) return;
            const msgId = wrapper.dataset.messageId;
            if (!msgId) return;

            if (editModeState.selectedMessageIds.has(msgId)) {
                editModeState.selectedMessageIds.delete(msgId);
                wrapper.classList.remove('selected');
            } else {
                editModeState.selectedMessageIds.add(msgId);
                wrapper.classList.add('selected');
            }
        }
        
        function openRepostModal(postId) {
            const post = state.posts.find(p => p.id === postId);
            if (!post) return;
            
            const modal = document.getElementById('repost-contact-picker-modal');
            const contactListEl = document.getElementById('repost-contact-list');
            const messageInput = document.getElementById('repost-message-input');
            messageInput.value = '';
            contactListEl.innerHTML = '';

            state.contacts.forEach(contact => {
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                item.innerHTML = `
                    <input type="checkbox" id="contact-check-${contact.id}" value="${contact.id}">
                    <label for="contact-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                        <img src="${contact.avatar}" alt="${contact.name}">
                        <span>${contact.name}</span>
                    </label>
                `;
                contactListEl.appendChild(item);
            });
            
            modal.style.display = 'flex';

            document.getElementById('close-repost-modal').onclick = () => modal.style.display = 'none';
            
            const confirmBtn = document.getElementById('confirm-repost-btn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', async () => {
                const selectedContactIds = Array.from(contactListEl.querySelectorAll('input:checked')).map(input => input.value);
                if (selectedContactIds.length === 0) {
                    alert('请至少选择一个联系人');
                    return;
                }
                
                const accompanyingMessage = messageInput.value.trim();

                for (const contactId of selectedContactIds) {
                    const tempActiveChatId = state.activeChatId;
                    state.activeChatId = contactId; // 临时切换上下文
                    
                    await createAndAddMessage({ type: 'post_share', content: { postId } });
                    if (accompanyingMessage) {
                        await createAndAddMessage({ type: 'text', content: accompanyingMessage });
                    }
                    
                    state.activeChatId = tempActiveChatId; // 切换回来
                }
                
                modal.style.display = 'none';
                alert(`已成功分享给 ${selectedContactIds.length} 位联系人！`);
                post.reposts = (post.reposts || 0) + 1;
                await kokoMemory.put('posts', post);
                await renderFeed();
            });
        }

       // 【最终完美版】showRedPacketDetails 函数
// 它可以正确处理：私聊红包、群聊红包、论坛红包

// 【私聊逻辑修正版】showRedPacketDetails 函数
// 它能正确处理所有场景，并修正了私聊领取人的判断逻辑

async function showRedPacketDetails(packetData, senderProfile) {
    const modal = document.getElementById('red-packet-details-modal');
    const listEl = document.getElementById('red-packet-claimer-list');
    const summaryEl = document.getElementById('red-packet-details-summary');

    // 1. 设置通用的头部信息
    document.getElementById('details-sender-avatar').src = senderProfile.avatar;
    document.getElementById('details-sender-name').textContent = `${senderProfile.name}的红包`;
    document.getElementById('details-blessing').textContent = packetData.blessing;
    listEl.innerHTML = '';

    // 2. 智能判断红包类型并准备数据
    const isMultiPersonPacket = packetData.hasOwnProperty('count');
    let claimers = packetData.claimers || [];

    // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼
    // 兼容私聊红包，并正确判断领取人
    if (!isMultiPersonPacket && packetData.opened && claimers.length === 0) {
        
        // 判断是谁领取的
        let recipientId;
        if (senderProfile.id === 'myProfile') {
            // 如果发送人是“我”，那么领取人就是当前聊天的char
            recipientId = state.activeChatId;
        } else {
            // 如果发送人是char，那么领取人就是“我”
            recipientId = 'myProfile';
        }
        
        // 手动创建正确的领取者信息
        claimers = [{
            userId: recipientId,
            amount: parseFloat(packetData.amount)
        }];
    }
    // ▲▲▲▲▲▲▲▲▲▲ 核心修复点在这里 ▲▲▲▲▲▲▲▲▲▲

    // 3. 根据红包类型生成不同的汇总信息（这部分逻辑已是正确的）
    let summaryText = '';
    if (claimers.length === 0) {
        summaryText = '红包正在等待领取...';
    } else if (isMultiPersonPacket) {
        const totalAmount = packetData.totalAmount || packetData.amount;
        const totalClaimedAmount = claimers.reduce((sum, c) => sum + c.amount, 0);
        const claimedCount = claimers.length;
        const totalCount = packetData.count;
        if (claimedCount >= totalCount) {
            summaryText = `全部 ${totalCount} 个红包已被领完，共 ${totalAmount.toFixed(2)} 元。`;
        } else {
            summaryText = `已领取 ${claimedCount}/${totalCount} 个，共 ${totalClaimedAmount.toFixed(2)}/${totalAmount.toFixed(2)} 元。`;
        }
    } else {
        summaryText = `1个红包，共 ${parseFloat(packetData.amount).toFixed(2)} 元。`;
    }
    summaryEl.textContent = summaryText;

    // 4. 创建一个包含所有可能出现的“路人甲”的查找表（这部分逻辑已是正确的）
    const authorProfiles = new Map();
    authorProfiles.set('myProfile', state.myProfile);
    state.contacts.forEach(c => authorProfiles.set(c.id, c));
    state.posts.forEach(p => {
        if(p.author) authorProfiles.set(p.author.id, p.author);
        p.comments.forEach(c => {
            if(c.author) authorProfiles.set(c.author.id, c.author);
        });
    });

    // 5. 找出“手气最佳”（这部分逻辑已是正确的）
    let bestLuckClaimerId = null;
    if (isMultiPersonPacket && claimers.length > 1) {
        const bestLuckClaimer = claimers.reduce((max, current) => (current.amount > max.amount) ? current : max, claimers[0]);
        bestLuckClaimerId = bestLuckClaimer.userId;
    }

    // 6. 渲染领取者列表（这部分逻辑已是正确的）
    for (const claimer of claimers) {
        const claimerProfile = authorProfiles.get(claimer.userId) || { name: '一位路人', avatar: 'https://via.placeholder.com/40/DDD/666?text=?' };
        const item = document.createElement('div');
        item.className = 'claimer-item';
        let bestLuckHTML = '';
        if (claimer.userId === bestLuckClaimerId) {
            bestLuckHTML = '<span class="best-luck-badge">手气最佳</span>';
        }
        item.innerHTML = `
            <img src="${claimerProfile.avatar}" class="claimer-avatar">
            <div class="claimer-info">
                <div class="claimer-name">${claimerProfile.name}</div>
                <div class="claim-time">${new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</div>
            </div>
            <div class="claim-amount">${claimer.amount.toFixed(2)} 元 ${bestLuckHTML}</div>
        `;
        listEl.appendChild(item);
    }

    modal.style.display = 'flex';
}
        
// 请用下面这个【完整】的函数，替换掉您代码里现有的 showRedPacketModal 函数

async function showRedPacketModal(message, senderProfile) {
    const packetData = message.content;
    const modal = document.getElementById('red-packet-modal');
    const chatContext = state.contacts.find(c => c.id === state.activeChatId);
    if (!chatContext || !senderProfile) return; // 增加安全检查

    // 1. 设置弹窗内容
    document.getElementById('red-packet-sender-avatar').src = senderProfile.avatar;
    document.getElementById('red-packet-sender-name').textContent = `${senderProfile.name}的红包`;
    document.getElementById('red-packet-blessing-text').textContent = packetData.blessing;

    // 2. 重置弹窗UI状态
    const openBtn = document.getElementById('open-red-packet-btn');
    openBtn.style.display = 'flex';
    openBtn.style.transform = 'rotate(0deg)';
    document.getElementById('red-packet-result').style.display = 'none';
    document.getElementById('red-packet-content').style.backgroundColor = '#DB5A48';

    // 3. 安全地绑定事件
    const newOpenBtn = openBtn.cloneNode(true);
    openBtn.parentNode.replaceChild(newOpenBtn, openBtn);

    const closeBtn = document.getElementById('close-red-packet-modal');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);

    const detailsLink = document.getElementById('view-red-packet-details');
    const newDetailsLink = detailsLink.cloneNode(true);
    detailsLink.parentNode.replaceChild(newDetailsLink, detailsLink);

    newCloseBtn.addEventListener('click', () => modal.style.display = 'none');

    // ▼▼▼▼▼▼▼▼▼▼ 核心修复点在这里 ▼▼▼▼▼▼▼▼▼▼
    // 我们确保详情链接正确地调用了 showRedPacketDetails 函数，而不是 alert
    newDetailsLink.addEventListener('click', (e) => {
        e.preventDefault();
        showRedPacketDetails(packetData, senderProfile); 
    });
    // ▲▲▲▲▲▲▲▲▲▲ 核心修复点在这里 ▲▲▲▲▲▲▲▲▲▲

    // 4. 根据红包类型和状态决定显示内容（这部分逻辑我们之前已经完善了）
    const isGroupPacket = packetData.hasOwnProperty('count');
    
    if (isGroupPacket) {
        // --- 群聊红包逻辑 ---
        const myId = 'myProfile';
        const hasClaimed = packetData.claimers.some(c => c.userId === myId);
        const isDepleted = packetData.claimers.length >= packetData.count;

        if (hasClaimed) {
            const myClaim = packetData.claimers.find(c => c.userId === myId);
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `¥${myClaim.amount.toFixed(2)}`;
            document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
        } else if (isDepleted) {
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `手慢了`;
            document.getElementById('red-packet-collected-by').textContent = '红包派完了';
        } else {
            newOpenBtn.addEventListener('click', async () => {
                const remainingCount = packetData.count - packetData.claimers.length;
                const remainingAmount = packetData.totalAmount - packetData.claimers.reduce((sum, c) => sum + c.amount, 0);
                let amount = 0;
                if (remainingCount > 1) {
                    const avg = remainingAmount / remainingCount;
                    amount = Math.random() * avg * 1.8;
                    amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                } else { amount = remainingAmount; }
                amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                state.myProfile.balance += amount;
                await addTransaction('income', amount, `抢到 ${senderProfile.name} 的群红包`, chatContext.id);
                packetData.claimers.push({ userId: 'myProfile', amount: amount });
                
                await kokoMemory.put('myProfile', state.myProfile);
                await kokoMemory.put('contacts', chatContext);

                newOpenBtn.style.transform = 'rotate(720deg)';
                await sleep(500);
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                
                await sleep(1500);
                modal.style.display = 'none';
                await renderMyProfile();
                await openChat(chatContext.id);
            });
        }
    } else {
        // --- 私聊红包逻辑 ---
        if (packetData.opened) {
            newOpenBtn.style.display = 'none';
            document.getElementById('red-packet-result').style.display = 'block';
            document.getElementById('red-packet-amount-text').textContent = `¥${packetData.amount}`;
            document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
        } else {
            newOpenBtn.addEventListener('click', async () => {
                const amount = parseFloat(packetData.amount);
                state.myProfile.balance += amount;
                await addTransaction('income', amount, `收到 ${senderProfile.name} 的红包`, senderProfile.id);
                packetData.opened = true;
                await kokoMemory.put('myProfile', state.myProfile);
                await kokoMemory.put('contacts', chatContext);
                
                newOpenBtn.style.transform = 'rotate(720deg)';
                await sleep(500);
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                
                await openChat(chatContext.id);
                await requestAiReply(`[SYSTEM: 我刚刚打开了你发的红包，金额是${amount.toFixed(2)}元。]`);
                
                await sleep(1500);
                modal.style.display = 'none';
            });
        }
    }
    
    modal.style.display = 'flex';
}
        async function openForumRedPacketModal(postId) {
            const post = state.posts.find(p => p.id === postId);
            if (!post || !post.redPacket) return;

            const modal = document.getElementById('red-packet-modal');
            
            // 1. 设置弹窗内容
            document.getElementById('red-packet-sender-avatar').src = post.author.avatar;
            document.getElementById('red-packet-sender-name').textContent = `${post.author.name}的红包`;
            document.getElementById('red-packet-blessing-text').textContent = post.redPacket.blessing;

            // 2. 重置弹窗UI状态
            document.getElementById('open-red-packet-btn').style.display = 'flex';
            document.getElementById('open-red-packet-btn').style.transform = 'rotate(0deg)';
            document.getElementById('red-packet-result').style.display = 'none';
            document.getElementById('red-packet-content').style.backgroundColor = '#DB5A48';

            // 3. 【关键修复】使用克隆节点的方法安全地绑定事件，防止卡死
            const oldOpenBtn = document.getElementById('open-red-packet-btn');
            const newOpenBtn = oldOpenBtn.cloneNode(true);
            oldOpenBtn.parentNode.replaceChild(newOpenBtn, oldOpenBtn);

            const oldCloseBtn = document.getElementById('close-red-packet-modal');
            const newCloseBtn = oldCloseBtn.cloneNode(true);
            oldCloseBtn.parentNode.replaceChild(newCloseBtn, oldCloseBtn);

            const oldDetailsLink = document.getElementById('view-red-packet-details');
            const newDetailsLink = oldDetailsLink.cloneNode(true);
            oldDetailsLink.parentNode.replaceChild(newDetailsLink, oldDetailsLink);

            // 4. 为新克隆的按钮添加事件监听
            newCloseBtn.addEventListener('click', () => modal.style.display = 'none');
            newDetailsLink.addEventListener('click', (e) => {
                e.preventDefault();
                showRedPacketDetails(post.redPacket, post.author);
            });

            // 5. 根据红包状态决定显示内容
            const myId = 'myProfile';
            // ▼▼▼ 修正点 ▼▼▼
            const hasClaimed = post.redPacket.claimers && post.redPacket.claimers.some(c => c.userId === myId);
            const isDepleted = post.redPacket.claimers && post.redPacket.claimers.length >= post.redPacket.count;
            // ▲▲▲ 修正点 ▲▲▲

            if (hasClaimed) {
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                const myClaim = post.redPacket.claimers.find(c => c.userId === myId);
                document.getElementById('red-packet-amount-text').textContent = `¥${myClaim.amount.toFixed(2)}`;
                document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
            } else if (isDepleted) {
                newOpenBtn.style.display = 'none';
                document.getElementById('red-packet-result').style.display = 'block';
                document.getElementById('red-packet-amount-text').textContent = `手慢了`;
                document.getElementById('red-packet-collected-by').textContent = '红包派完了';
            } else {
                newOpenBtn.addEventListener('click', async () => {
                    // 随机分配红包金额
                    const remainingCount = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
                    const remainingAmount = post.redPacket.amount - (post.redPacket.claimers ? post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0) : 0);
                    let amount = 0;
                    if (remainingCount > 1) {
                        const avg = remainingAmount / remainingCount;
                        amount = Math.random() * avg * 2;
                        amount = Math.min(remainingAmount * 0.9, amount);
                    } else {
                        amount = remainingAmount;
                    }
                    amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                    // 更新余额和交易记录
                    state.myProfile.balance += amount;
                    await addTransaction('income', amount, `抢到 ${post.author.name} 的论坛红包`, null);
                    
                    // 更新红包状态
                    if (!post.redPacket.claimers) post.redPacket.claimers = [];
                    post.redPacket.claimers.push({ userId: myId, amount: amount });
                    
                    // 保存数据
                    await kokoMemory.put('myProfile', state.myProfile);
                    await kokoMemory.put('posts', post);

                    // 播放动画并更新UI
                    newOpenBtn.style.transform = 'rotate(720deg)';
                    await sleep(500);
                    newOpenBtn.style.display = 'none';
                    document.getElementById('red-packet-result').style.display = 'block';
                    document.getElementById('red-packet-amount-text').textContent = `¥${amount.toFixed(2)}`;
                    document.getElementById('red-packet-collected-by').textContent = '已存入零钱';
                    document.getElementById('red-packet-content').style.backgroundColor = '#E4A095';

                    await sleep(1500);
                    modal.style.display = 'none';
                    await renderMyProfile();
                });
            }
            
            modal.style.display = 'flex';
        }

        async function openChat(contactId) {
            if (editModeState.active) await exitEditMode();
            const contact = state.contacts.find(c => c.id === contactId);
            if (!contact) return;
            state.activeChatId = contactId;
            // 在 openChat 函数中...

// --- 核心修复：应用聊天背景 (防闪烁版) ---
const chatScreen = document.getElementById('chat-screen');
const savedSettings = await kokoMemory.get('userSettings', 'main');
let finalBackgroundUrl = null; // 默认没有任何自定义背景

// 决定最终使用哪个背景URL
if (contact.customChatBackground) {
    // 优先级1：使用联系人的专属背景
    finalBackgroundUrl = contact.customChatBackground;
} else if (savedSettings && savedSettings.chatBackground) {
    // 优先级2：如果联系人没有专属背景，则使用全局设置的背景
    finalBackgroundUrl = savedSettings.chatBackground;
}

// 关键修复：只有在 finalBackgroundUrl 确实有值（即找到了自定义背景）时才设置它
if (finalBackgroundUrl) {
    chatScreen.style.backgroundImage = `url(${finalBackgroundUrl})`;
} else {
    // 否则，清除行内样式，让 CSS 文件里的默认背景图能够显示出来
    chatScreen.style.backgroundImage = '';
}
// --- 修复结束 ---
            
            const messagesContainer = document.getElementById('chat-messages'); if (contact.isNarrativeMode) { messagesContainer.classList.add('narrative-mode-active'); } else { messagesContainer.classList.remove('narrative-mode-active'); }
            
            chatPagination[contactId] = 1;

            document.getElementById('chat-messages').innerHTML = '';

            hideAllScreens();
            document.getElementById('chat-screen').style.display = 'flex';
            document.getElementById('chat-contact-name').textContent = contact.name;
            document.getElementById('chat-contact-status').textContent = '在线'; 
            
            const chatPetContainer = document.getElementById('chat-pet-container');
            if (contact.pet && contact.isChatPetVisible) {
                chatPetContainer.style.display = 'block';
                updateChatPetVisuals(contact);
            } else {
                chatPetContainer.style.display = 'none';
            }

            renderChatMessages(contact);
            if (contact.unreadCount) {
                contact.unreadCount = 0;
                await kokoMemory.put('contacts', contact);
            }
        }

        function renderChatMessages(contact, loadAll = false) {
            const messagesContainer = document.getElementById('chat-messages');
            const isInitialRender = messagesContainer.innerHTML === '';
            
            if (isInitialRender) {
                messagesContainer.innerHTML = '';
            }

            const page = chatPagination[contact.id] || 1;
            const start = loadAll ? 0 : Math.max(0, contact.history.length - (page * MESSAGES_PER_PAGE));
            const end = loadAll ? contact.history.length : Math.max(0, contact.history.length - ((page - 1) * MESSAGES_PER_PAGE));
            
            const allMessagesInPage = contact.history.slice(start, end);

            // 智能过滤：检查当前是否处于编辑模式
            let messagesToRender;
            if (editModeState.active) {
                // 如果是编辑模式，就显示全部消息，不做任何过滤
                messagesToRender = allMessagesInPage;
            } else {
                // 如果是普通聊天模式，就和之前一样，把通话记录隐藏起来
                messagesToRender = allMessagesInPage.filter(msg => msg.type !== 'video_call_text');
            }

            const existingLoadMoreBtn = document.getElementById('load-more-messages');
            if (existingLoadMoreBtn) {
                existingLoadMoreBtn.remove();
            }
            
            let currentScrollHeight = messagesContainer.scrollHeight;

if (!contact || !contact.history || contact.history.length === 0) {
    messagesContainer.innerHTML = `<div id="chat-placeholder" style="text-align: center; color: #999; padding: 20px;">和 ${contact ? contact.name : ''} 开始聊天吧！</div>`;
    return;
}
            
// ▼▼▼ 从这里开始替换 ▼▼▼

            let fragment = document.createDocumentFragment();
            messagesToRender.forEach((msg, index) => {
                let isFirstInSequence = true;
                
                // 智能判断逻辑：只有非系统消息才需要判断头像
                if (msg.type !== 'system_notification' && msg.sender !== 'system_instruction') {
                    
                    // 【核心修复】从当前消息往前找，找到上一个“可见”的消息
                    let prevVisibleMsg = null;
                    if (index > 0) {
                        for (let i = index - 1; i >= 0; i--) {
                            const potentialPrevMsg = messagesToRender[i];
                            // 如果这条消息不是被隐藏的类型，那它就是我们要找的“前一条”
                            if (potentialPrevMsg.type !== 'system_notification' && potentialPrevMsg.sender !== 'system_instruction' && potentialPrevMsg.type !== 'heart_voice') {
                                prevVisibleMsg = potentialPrevMsg;
                                break; // 找到了就立刻停止循环
                            }
                        }
                    }
                    
                    // 用找到的“前一条可见消息”来判断发送者是否相同
                    if (prevVisibleMsg && prevVisibleMsg.sender === msg.sender) {
                        isFirstInSequence = false;
                    }
                }
                
                // 如果AI强制要求显示头像，则覆盖上面的判断
                if (msg.forceAvatar) {
                    isFirstInSequence = true;
                }

                const messageEl = createMessageElement(msg, contact, isFirstInSequence);
                if(messageEl) {
                     if (editModeState.active && editModeState.selectedMessageIds.has(msg.id)) {
                        messageEl.classList.add('selected');
                    }
                    fragment.appendChild(messageEl);
                }
            });
// ▲▲▲ 替换到这里结束 ▲▲▲
            
            if (isInitialRender) {
                messagesContainer.appendChild(fragment);
            } else {
                messagesContainer.insertBefore(fragment, messagesContainer.firstChild);
            }

            if (!loadAll && start > 0) {
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'load-more-messages';
                loadMoreBtn.textContent = '加载更早的记录...';
                loadMoreBtn.style.display = 'block';
                loadMoreBtn.onclick = () => {
                    chatPagination[contact.id]++;
                    renderChatMessages(contact);
                };
                messagesContainer.prepend(loadMoreBtn);
            }
            
            if (isInitialRender || editModeState.active) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            } else {
                 messagesContainer.scrollTop = messagesContainer.scrollHeight - currentScrollHeight;
            }
        }

        // --- C. 请用这个【完整版】函数替换您现有的 createMessageElement 函数 ---
        function createMessageElement(message, contact, isFirstInSequence) {
            if (message.type === 'heart_voice') return null;
            if (message.type === 'heart_voice') return null;
            if (message.sender === 'system_instruction') return null;

            if (message.type === 'system_notification') {
                const wrapper = document.createElement('div');
                wrapper.className = 'message-wrapper system-wrapper';
                wrapper.dataset.messageId = message.id;
                const notificationEl = document.createElement('div');
                notificationEl.className = 'system-notification';
                notificationEl.textContent = message.content;
                wrapper.appendChild(notificationEl);
                wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
                return wrapper;
            }

            const wrapper = document.createElement('div');
            wrapper.className = `message-wrapper ${message.sender === 'user' ? 'sent' : 'received'}`;
            // ✨ 这是修改后的正确代码 ✨
if (contact.isAvatarHidden && (message.sender === 'contact' || message.sender === contact.id)) {
    wrapper.classList.add('contact-avatar-hidden');

            }
             // ▼▼▼ 把下面这段新代码粘贴到这里 ▼▼▼
            // 新增逻辑：如果消息是AI发的HTML，添加一个特殊类来隐藏UI元素
            if (message.type === 'html' && message.sender !== 'user') {
                wrapper.classList.add('ai-html-message');
                // 我们也借用这个已有的类来移除消息体的左边距
                wrapper.classList.add('contact-avatar-hidden'); 
            }
            // ▲▲▲ 新代码粘贴结束 ▲▲▲
            wrapper.dataset.messageId = message.id; 
            if (isFirstInSequence) {
                wrapper.classList.add('is-first-in-sequence');
                wrapper.style.marginTop = '10px';
            }

            const senderInfo = message.sender === 'user' ? state.myProfile : contact;
            
            // ▼▼▼ 在它下面，添加这段新的逻辑 ▼▼▼
    let finalSenderInfo = senderInfo;
    const isGroupChat = contact.isGroup === true;

    if (isGroupChat && message.sender !== 'user') {
        // 如果是群聊，并且是别人发的消息，我们需要从所有联系人里找到真正的发言人信息
        finalSenderInfo = state.contacts.find(c => c.id === message.sender) || { name: '未知成员', avatar: '' };
    }
    const showAuthorName = isFirstInSequence;
    // ▲▲▲ 添加结束 ▲▲▲
    // --- 核心修改：决定最终要显示的头像URL ---
            let finalAvatarUrl = finalSenderInfo.avatar;
            if (message.sender === 'user' && contact.customUserAvatar) {
                // 如果是用户发的消息，并且当前联系人设置了自定义用户头像，就用它！
                finalAvatarUrl = contact.customUserAvatar;
            }
            // --- 修改结束 ---
            // --- 新增：构建引用消息框的HTML ---
            let quoteHTML = '';
            if (message.quote) {
                quoteHTML = `
                    <div class="message-quote" data-quoted-id="${message.quote.messageId}">
                        <div class="sender">${message.quote.senderName}</div>
                        <div class="content">${message.quote.content}</div>
                    </div>
                `;
            }

            let messageContentHTML = '';

            switch (message.type) {
              // 在 createMessageElement 函数的 switch 语句中
case 'location_share': {
    const loc = message.content;
    messageContentHTML = `
        <div class="message location-share-card">
            <div class="location-card-icon"><i class="${loc.icon || 'fas fa-map-marker-alt'}"></i></div>
            <div class="location-card-info">
                <div class="name">${loc.name}</div>
                <div class="footer">位置信息 · 点击查看</div>
            </div>
        </div>`;
    break;
}
// ... 在 createMessageElement 函数的 switch 语句中 ...

// 在 case 'image': 的下面，添加一个新的 case
case 'uploaded_image':
    // 这个逻辑和 type: 'image' 非常像，但是 src 直接使用 Base64
    messageContentHTML = `
        <div class="message image-message">
            <div class="message-image-container ${message.sender === 'user' ? 'sent' : 'received'}">
                <img src="${message.content.base64}" class="message-image" alt="上传的图片">
            </div>
        </div>`;
    break;  
                case 'location_share': { const loc = message.content; messageContentHTML = ` <div class="message location-share-card"> <div class="location-card-icon"> <i class="${loc.icon || 'fas fa-map-marker-alt'}"></i> </div> <div class="location-card-info"> <div class="name">${loc.name}</div> <div class="footer">位置信息 · 点击查看</div> </div> </div>`; break; }
                case 'html':
                    // ▼▼▼ 核心修改 ▼▼▼
                    if (message.sender === 'user') {
                        // 如果用户自己发HTML (虽然不太可能)，还是用气泡包起来
                        messageContentHTML = `<div class="message sent">${quoteHTML}${message.content}</div>`;
                    } else {
                        // 如果是AI发的HTML (我们刚给wrapper加了标记)，则不再需要气泡，直接注入原始HTML
                        messageContentHTML = `${quoteHTML}${message.content}`;
                    }
                    // ▲▲▲ 修改结束 ▲▲▲
                    break;
                case 'image':
                    messageContentHTML = `<div class="message image-message"><div class="message-image-container ${message.sender === 'user' ? 'sent' : 'received'}"><img src="${message.url}" class="message-image" alt="图片"></div></div>`;
                    break;
                case 'post_share': {
                    const post = state.posts.find(p => p.id === message.content.postId);
                    if (post) {
                        messageContentHTML = `
                        <div class="message post-share-card" data-post-id="${post.id}">
                            <div class="post-share-header">
                                <img src="${post.author.avatar}" class="post-share-avatar">
                                <span class="post-share-name">${post.author.name}</span>
                            </div>
                            <div class="post-share-content">${post.content}</div>
                            <div class="post-share-footer">分享的帖子</div>
                        </div>`;
                    } else {
                        messageContentHTML = `<div class="message received">帖子已被删除</div>`;
                    }
                    break;
                }
                // ▼▼▼ 把下面这段完整的 case 代码块粘贴进去 ▼▼▼
case 'product_share': {
    const shareData = message.content;
    const product = shareData.productDetails;
    const intentText = shareData.intent === 'gift' 
        ? `🎁 我送你一个礼物` 
        : `🥺 可以帮我付下款吗？`;

    // 重新构建卡片的HTML内容
    messageContentHTML = `
        <div class="message product-share-card">
            <div class="product-share-intent">${intentText}</div>
            <div class="product-share-body">
                <div class="product-share-info">
                    <div class="product-title">${product.name}</div>
                    
                    <div class="product-description" style="margin-top: 5px; font-size: 13px; color: #666; line-height: 1.5;">${product.description}</div>
                    
                    <div class="product-price" style="margin-top: 8px; text-align: right;"><span>¥</span>${product.price}</div>
                </div>
            </div>
            <div class="product-share-accompanying-msg">${shareData.accompanyingMessage}</div>
        </div>`;
    break;
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲
                case 'picture_description':
                    messageContentHTML = `<div class="message picture-description ${message.sender === 'user' ? 'sent' : 'received'}"><i class="fas fa-image"></i><span>[图片]</span></div>`;
                    break;
                case 'voice':
                    const voiceData = message.content;
                    const width = Math.min(200, 80 + parseInt(voiceData.duration) * 5) + 'px';
                    messageContentHTML = `<div class="message voice ${message.sender === 'user' ? 'sent' : 'received'}" style="width: ${width};"><div class="voice-duration">${voiceData.duration}''</div><i class="fas fa-wifi"></i></div>`;
                    break;
                // 在 createMessageElement 函数的 switch 语句内...

case 'red_packet':
    const packetData = message.content;
    let statusHTML = '';
    let footerText = '聊天红包';

    if (packetData.hasOwnProperty('count')) {
        // 这是群聊红包
        const isDepleted = packetData.claimers.length >= packetData.count;
        if (isDepleted) {
            statusHTML = `<div class="red-packet-status">红包已被领完</div>`;
        } else {
            statusHTML = `<div class="red-packet-blessing">${packetData.blessing}</div>`;
        }
        footerText = '群聊红包';
    } else {
        // 这是私聊红包
        statusHTML = packetData.opened ? `<div class="red-packet-status">红包已被领取</div>` : `<div class="red-packet-blessing">${packetData.blessing}</div>`;
    }
    
    // 如果已经被我领取了，也显示为 opened 状态
    const myId = 'myProfile';
    const hasClaimed = packetData.claimers && packetData.claimers.some(c => c.userId === myId);
    const isOpened = packetData.opened || hasClaimed;

    messageContentHTML = `<div class="message red-packet ${isOpened ? 'opened' : ''} ${message.sender === 'user' ? 'sent' : 'received'}"><div class="red-packet-header"><div class="red-packet-icon">🧧</div>${statusHTML}</div><div class="red-packet-footer">${footerText}</div></div>`;
    break;
                // 在 createMessageElement 函数的 switch 语句内...

case 'transfer': {
    const transferData = message.content;
    let transferClasses = 'message transfer';
    if (transferData.returned) {
        transferClasses += ' returned';
    } else if (transferData.completed) {
        transferClasses += ' completed';
    }

    let footerText = '聊天转账';
    if (transferData.returned) {
        footerText = '转账已退还';
    } else if (transferData.completed) {
        footerText = message.sender === 'user' ? '对方已收款' : '已存入钱包';
    }

    // 新增：判断是否是群聊转账，并显示收款人
    let recipientInfoHTML = '';
    if (transferData.recipientId) {
        const recipient = state.contacts.find(c => c.id === transferData.recipientId);
        if (recipient) {
            recipientInfoHTML = `<div class="transfer-text">转账给 ${recipient.name}</div>`;
        }
    } else {
        recipientInfoHTML = `<div class="transfer-text">转账</div>`;
    }

    messageContentHTML = `
        <div class="${transferClasses} ${message.sender === 'user' ? 'sent' : 'received'}">
            <div class="transfer-header">
                <div class="transfer-icon"><i class="fas fa-money-bill-wave"></i></div>
                <div class="transfer-info">
                    ${recipientInfoHTML}
                    <div class="transfer-amount">¥ ${transferData.amount}</div>
                </div>
            </div>
            <div class="transfer-footer">${footerText}</div>
        </div>`;
    break;
}
                case 'music_share':
                    const music = message.content;
                    messageContentHTML = `
                    <div class="message music-share-card ${message.sender === 'user' ? 'sent' : 'received'}">
                        <div class="music-card-cover">
                            <i class="fas fa-music"></i>
                            <span class="music-card-play-btn"><i class="fas fa-play"></i></span>
                        </div>
                        <div class="music-card-info">
                            <div class="music-card-title">${music.title}</div>
                            <div class="music-card-artist">${music.artist || '未知艺术家'}</div>
                            <div class="music-card-progress-bar"><div class="music-card-progress"></div></div>
                            <div class="music-card-controls">
                                <span class="music-card-time">00:00</span>
                                <span class="music-card-loop-btn" title="列表循环"><i class="fas fa-repeat"></i></span>
                            </div>
                        </div>
                    </div>`;
                    break;
                case 'game_wheel': {
                    const wheel = message.content;
                    const myProfile = state.myProfile;
                    const contact = state.contacts.find(c => c.id === state.activeChatId);

                    const userResultHTML = wheel.results.user
                        ? `<div class="wheel-player-result">${wheel.results.user}</div>`
                        : `<button class="spin-btn" data-player="user">点击开转</button>`;

                    const contactResultHTML = wheel.results.contact
                        ? `<div class="wheel-player-result">${wheel.results.contact}</div>`
                        : `<div class="wheel-player-result">等待对方...</div>`;

                    messageContentHTML = `
                        <div class="message game-wheel-card">
                            <div class="wheel-card-title">🎲 ${wheel.name} 🎲</div>
                            <div class="wheel-card-result-area">
                                <div class="wheel-result-row">
                                    <span class="wheel-player-name">${myProfile.name}</span>
                                    ${userResultHTML}
                                </div>
                                <div class="wheel-result-row">
                                    <span class="wheel-player-name">${contact.name}</span>
                                    ${contactResultHTML}
                                </div>
                            </div>
                        </div>`;
                    break;
                }
                default: 
                    let formattedContent = message.content;
                    const tempDiv = document.createElement('div');
                    tempDiv.textContent = formattedContent;
                    formattedContent = tempDiv.innerHTML;
                    formattedContent = formattedContent.replace(/\{(.*?)\}/g, '<span class="narrative-psychology">$1</span>');
                    formattedContent = formattedContent.replace(/(?:&quot;|“|”|＂)(.*?)(?:&quot;|“|”|＂)/g, '<span class="narrative-speech">“$1”</span>');
                    formattedContent = formattedContent.replace(/\*(.*?)\*/g, '<span class="narrative-action">$1</span>');
                    formattedContent = formattedContent.replace(/\n/g, '<br>');
                    // ↓↓↓ 核心改动：将 quoteHTML 插入到消息内容之前
                    messageContentHTML = `<div class="message ${message.sender === 'user' ? 'sent' : 'received'}">${quoteHTML}${formattedContent}</div>`;
                    break;
            }

            if (message.type !== 'text') {
                messageContentHTML = quoteHTML + messageContentHTML;
            }

            const transcribedTextHTML = (message.type === 'voice' || message.type === 'picture_description') ? '<div class="transcribed-text"></div>' : '';
            
            // --- 新增：在消息体旁边添加回复按钮 ---
            const replyButtonHTML = '<i class="fas fa-reply reply-btn"></i>';

            wrapper.innerHTML = `
        <div class="message-avatar">
    <img src="${finalAvatarUrl}" onerror="this.onerror=null;this.src='https://via.placeholder.com/40/DDD/666?text=U';">
</div>
        <div class="message-body">
            ${showAuthorName ? `<div class="message-author-name">${finalSenderInfo.name}</div>` : ''}
            ${messageContentHTML}
            ${transcribedTextHTML}
            <div class="message-timestamp">${message.time}</div>
        </div>
        ${replyButtonHTML}
    `;
            wrapper.addEventListener('click', () => handleMessageSelection(wrapper, message));
            return wrapper;
        }
        
        async function addSharedMemory(contact, description) {
            if (!contact) return;
            if (!contact.memories) contact.memories = [];

            const newMemory = {
                id: `memo_${Date.now()}`,
                timestamp: Date.now(),
                description: description
            };
            contact.memories.push(newMemory);
            await kokoMemory.put('contacts', contact);
        }

        async function checkForPetLevelUp(contact) {
            if (!contact.pet) return;
            const xpForNextLevel = 100;

            if (contact.pet.xp >= xpForNextLevel) {
                contact.pet.xp -= xpForNextLevel;
                contact.pet.level += 1;

                let evolutionMessage = '';
                let evolutionForm = contact.pet.form;

                if (contact.pet.level === 5 && contact.pet.form === 'baby') {
                    evolutionForm = 'toddler';
                    evolutionMessage = `在你们的精心照料下，史莱姆长大了！进化成了可爱的幼年期形态！`;
                } else if (contact.pet.level === 15 && contact.pet.form === 'toddler') {
                    evolutionForm = 'teenager';
                    evolutionMessage = `哇！光芒闪过，史莱姆再次进化，进入了活泼的少年期！`;
                }

                if (evolutionMessage) {
                    contact.pet.form = evolutionForm;
                    await createSystemNotification(evolutionMessage);
                    await requestAiReply(`[SYSTEM: 你们的宠物刚刚进化了！${evolutionMessage} 请你对此发表一段极其兴奋和开心的感言！]`);
                    await addSharedMemory(contact, `在LV.${contact.pet.level}时，我们的史莱姆进化成了“${evolutionForm}”形态！`);
                } else {
                    await createSystemNotification(`你们的聊天让史莱姆获得了成长！升到了 LV.${contact.pet.level}！`);
                }
                
                await kokoMemory.put('contacts', contact);
            }
        }

        async function addTransaction(type, amount, description, relatedContactId = null) {
            const newTransaction = {
                id: `txn_${Date.now()}`,
                timestamp: Date.now(),
                type: type, // 'income' 或 'expense'
                amount: amount,
                description: description,
                relatedContactId: relatedContactId
            };
            if (!state.transactions) state.transactions = [];
            state.transactions.push(newTransaction);
            await kokoMemory.put('transactions', newTransaction);
        }

// ▼▼▼ 使用这个【最终解决方案】替换掉你原来的 createAndAddMessage 函数 ▼▼▼

async function createAndAddMessage(messageData, sender = 'user', targetContact = null, forceShowAvatar = false) {
    const contact = targetContact || state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    if (contact.pet && sender !== 'system_instruction' && messageData.type !== 'system_notification') {
        contact.pet.xp += 1;
        await checkForPetLevelUp(contact);
    }
    
    if (contact.history.length === 0) {
        contact.firstChatDate = Date.now();
    }

    const fullMessage = {
        id: `msg_${Date.now()}_${Math.random()}`,
        time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
        timestamp: Date.now(),
        sender: sender,
        ...messageData,
        forceAvatar: forceShowAvatar
    };
    
    if (!contact.history) contact.history = [];
    contact.history.push(fullMessage);
    
    if (sender !== 'user' && sender !== 'system' && sender !== 'system_instruction' && document.hidden) {
        let notificationBody = '';
        switch(fullMessage.type) {
            case 'text':
            case 'html':
                notificationBody = fullMessage.content;
                break;
            case 'image':
                notificationBody = '[发来了一张图片]';
                break;
            case 'voice':
                notificationBody = '[发来了一段语音]';
                break;
            case 'red_packet':
                notificationBody = `[发来了一个红包] ${fullMessage.content.blessing}`;
                break;
            default:
                notificationBody = '[发来了一条新消息]';
        }

        if (Notification.permission === "granted") {
            const senderProfile = state.contacts.find(c => c.id === sender);
            if (senderProfile) {
                new Notification(senderProfile.name, {
                    body: notificationBody,
                    icon: senderProfile.avatar
                });
            }
        }
    }

    if (fullMessage.sender !== 'system_instruction') {
        const messagesContainer = document.getElementById('chat-messages');
        
        // ========================= 【核心修复点在这里】 =========================
        // 这个逻辑现在和 renderChatMessages 里的“智能”判断逻辑完全一样了
        let isFirstInSequence = true;
        if (!forceShowAvatar) {
            // 从刚刚添加的消息（数组末尾）往前查找
            // 我们从倒数第二个元素开始（contact.history.length - 2）
            for (let i = contact.history.length - 2; i >= 0; i--) {
                const prevMsg = contact.history[i];
                
                // 如果我们找到了一个“可见”的消息...
                if (prevMsg.type !== 'system_notification' && prevMsg.sender !== 'system_instruction' && prevMsg.type !== 'heart_voice') {
                    
                    // ...就用它来判断发送者是否相同
                    if (prevMsg.sender === fullMessage.sender) {
                        isFirstInSequence = false;
                    }
                    
                    // 找到了就必须立刻停止循环，不再往前找了
                    break; 
                }
            }
        }
        // ========================= 【修复结束】 =========================
        
        if (contact.id === state.activeChatId) {
             const messageEl = createMessageElement(fullMessage, contact, isFirstInSequence);
            if(messageEl) {
                const placeholder = messagesContainer.querySelector('#chat-placeholder');
                if (placeholder) {
                    placeholder.remove();
                }
                messagesContainer.appendChild(messageEl);
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        } else {
            contact.unreadCount = (contact.unreadCount || 0) + 1;
        }
    }

    await kokoMemory.put('contacts', contact);
    
    if (fullMessage.sender !== 'system_instruction') {
        await renderContacts();
    }

    const lockScreenEl = document.getElementById('lock-screen');
    if (lockScreenEl.style.display === 'flex' && !lockScreenEl.classList.contains('hidden')) {
        if (sender !== 'user' && sender !== 'system_instruction') {
            console.log("锁屏状态下收到新消息，正在更新组件...");
            await updateLockScreenWidgets();
        }
    }
    return fullMessage;
}

// ▲▲▲ 替换到这里结束 ▲▲▲
// 【修改后】修复了bug的 sendMessage 函数

async function sendMessage() {
    const messageInput = document.getElementById('message-input');
    const content = messageInput.value.trim();
    if ((!content && !activeReplyTarget) || !state.activeChatId) return;

    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 1. 先准备好基础消息数据
    let messageType = 'text';
    const trimmedContent = content.trim();
    if (trimmedContent.startsWith('<') && trimmedContent.endsWith('>')) {
        messageType = 'html';
    }
    const messageData = { type: messageType, content: content };

    // 2. 如果是引用回复，就给消息加上引用信息
    if (activeReplyTarget) {
        const currentChat = state.contacts.find(c => c.id === state.activeChatId);
        let senderName;

        if (activeReplyTarget.sender === 'user') {
            senderName = state.myProfile.name;
        } else if (currentChat && currentChat.isGroup) {
            const senderContact = state.contacts.find(c => c.id === activeReplyTarget.sender);
            senderName = senderContact ? senderContact.name : '未知成员';
        } else {
            senderName = currentChat ? currentChat.name : '未知成员';
        }

        messageData.quote = {
            messageId: activeReplyTarget.id,
            senderName: senderName,
            content: activeReplyTarget.content
        };
    }

    // 3. 无论如何，最后统一发送一次消息
    // 因为 messageData 已经在上面准备好了所有需要的信息
    await createAndAddMessage(messageData);

    // 4. 发送完毕后，统一做清理工作
    messageInput.value = '';
    messageInput.style.height = '38px'; // 恢复到初始的 min-height
    messageInput.focus();
    cancelReply(); // 发送后清除引用状态
}

        const sleep = ms => new Promise(resolve => setTimeout(resolve, ms));
async function handleLongPressDelete(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact || !contact.history || contact.history.length === 0) {
        return; 
    }

    const lastMessage = contact.history[contact.history.length - 1];
    if (!lastMessage) return;

    let confirmed = false;
    let finalHistorySliceIndex = -1;

    if (lastMessage.sender !== 'user') {
        // --- 场景 A: 最后一条消息是AI发的 ---
        // 目标：删除AI的最后一次回复，回退到用户说的最后一句话
        let lastUserMessageIndex = -1;
        for (let i = contact.history.length - 1; i >= 0; i--) {
            if (contact.history[i].sender === 'user') {
                lastUserMessageIndex = i;
                break;
            }
        }

        if (lastUserMessageIndex === -1) {
            alert("聊天记录中没有你的消息，无法回溯。");
            return;
        }

        confirmed = await showCustomConfirm(
            '回溯AI回复 (急救)',
            `AI的最后一次回复似乎有问题。确定要删除它，并回到你说的最后一句话吗？`,
            true
        );
        if (confirmed) {
            finalHistorySliceIndex = lastUserMessageIndex + 1;
        }

    } else {
        // --- 场景 B: 最后一条消息是用户发的 ---
        // 目标：删除用户最后连续发送的消息，回退到AI说的最后一句话
        let lastAiMessageIndex = -1;
        for (let i = contact.history.length - 1; i >= 0; i--) {
            if (contact.history[i].sender !== 'user') {
                lastAiMessageIndex = i;
                break;
            }
        }
        
        // 如果AI从未回复过，sliceIndex会是0，这将清空所有（都是用户发的）消息
        const sliceIndex = lastAiMessageIndex + 1;

        confirmed = await showCustomConfirm(
            '回溯我的回复 (急救)',
            `你发的最后几条消息似乎有问题。确定要删除它们，并回到AI说的最后一句话吗？`,
            true
        );
        if (confirmed) {
            finalHistorySliceIndex = sliceIndex;
        }
    }

    // 如果用户确认了操作，并且我们计算出了正确的分割点
    if (confirmed && finalHistorySliceIndex !== -1) {
        contact.history = contact.history.slice(0, finalHistorySliceIndex);
        await kokoMemory.put('contacts', contact);
        await renderContacts(); // 刷新联系人列表
        alert(`操作成功！聊天记录已回溯。`);
    }
}
// 函数1：切换置顶状态 (修正版)
async function togglePinContact(contactId) {
    const contact = await kokoMemory.get('contacts', contactId);
    if (contact) {
        contact.isPinned = !contact.isPinned; // 切换置顶状态
        await kokoMemory.put('contacts', contact); // 保存到数据库

        // ▼▼▼ 核心修复：在这里手动更新 state ▼▼▼
        const contactInState = state.contacts.find(c => c.id === contactId);
        if (contactInState) {
            contactInState.isPinned = contact.isPinned;
        }
        // ▲▲▲ 修复结束 ▲▲▲

        await renderContacts(); // 现在用更新后的 state 重新渲染列表
    }
}

// 函数2：显示菜单 (核心)
async function showContactItemMenu(contactId, buttonElement) {
    const menu = document.getElementById('contact-item-menu');
    const contact = await kokoMemory.get('contacts', contactId);
    if (!contact) return;

    const pinMenuItem = document.getElementById('menu-item-pin');
    pinMenuItem.querySelector('span').textContent = contact.isPinned ? '取消置顶' : '置顶聊天';

    menu.dataset.contactId = contactId;
    const rect = buttonElement.getBoundingClientRect();
    menu.style.display = 'block';
    menu.style.top = `${rect.bottom + 5}px`;
    menu.style.left = `${rect.right - menu.offsetWidth}px`;
    
    // 注意：这里已经移除了旧的关闭逻辑
}
// ▼▼▼ 使用这个【新版本】替换掉你原来的 requestAiReply 函数 ▼▼▼
async function requestAiReply(systemInstruction = null, targetContactId = null) {
    const contactId = targetContactId || state.activeChatId; // 优先使用指定的目标
    if (!contactId) return;

    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    if (systemInstruction) {
         await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction', contact); // 把contact传进去
    }

    if (contact.history.filter(m => m.sender !== 'system_instruction').length === 0) {
        if (!systemInstruction) alert('请先发送消息再请求回复。');
        return;
    }

    // ▼▼▼ 核心改动：判断是群聊还是私聊 ▼▼▼
    if (contact.isGroup) {
        // 如果是群聊，调用群聊AI处理函数
        await triggerGroupChatAiReply(contact);
    } else {
        // 如果是私聊，调用原来的单聊AI处理函数
        await triggerAiReply(contact);
    }
    // ▲▲▲ 改动结束 ▲▲▲
}
        async function triggerAiReply(contact) {
            if (contact.needsNarrativeModeExitPrompt === true) { 
                const exitInstruction = `[SYSTEM COMMAND: CRITICAL! IMMEDIATE FORMAT CHANGE REQUIRED!] You have just exited Narrative Mode. Your response format MUST IMMEDIATELY and STRICTLY return to the standard multi-line chat format. - DO NOT write a single long paragraph. - DO NOT include any descriptions of actions, expressions, or thoughts (e.g., *...* or {...}). - You MUST use multi-line responses and commands like [sticker:name] where appropriate. This is a strict and immediate format change. Acknowledge and comply.`;
                await createAndAddMessage({ type: 'text', content: exitInstruction }, 'system_instruction'); 
                delete contact.needsNarrativeModeExitPrompt;
            } 
          
            const chatStatusEl = document.getElementById('chat-contact-status'); 
            const originalStatus = chatStatusEl.textContent; 
            chatStatusEl.textContent = '对方正在输入...';

            if (!contact.apiCallCounter) {
                contact.apiCallCounter = 0;
            }
            contact.apiCallCounter++;
            
            try {
                const currentUserStatus = state.myProfile.status;
                if (contact) {
                    if (contact.lastKnownUserStatus && contact.lastKnownUserStatus !== currentUserStatus) {
                        const statusChangeInstruction = `[SYSTEM: 你的对话伙伴刚刚将状态从“${contact.lastKnownUserStatus}”改为了“${currentUserStatus}”。这是一个很好的机会，你可以自然地关心一下，比如问：“我看到你的状态变了，还好吗？”。这次之后就不用再提了。]`;
                        await createAndAddMessage({ type: 'text', content: statusChangeInstruction }, 'system_instruction');
                    }
                    contact.lastKnownUserStatus = currentUserStatus;
                }
            } catch (e) {
                console.error("更新用户状态记忆时出错:", e);
            }

            const lastUnopenedMessage = contact.history.slice().reverse().find(m =>
                m.sender === 'user' && (
                    (m.type === 'red_packet' && !m.content.opened) ||
                    (m.type === 'transfer' && !m.content.completed)
                )
            );

            if (lastUnopenedMessage) {
                let systemInstruction = '';
                if (lastUnopenedMessage.type === 'red_packet') {
                    systemInstruction = `[SYSTEM: You have just received a red packet from the user. The blessing is: "${lastUnopenedMessage.content.blessing}". Decide whether to accept it and reflect your decision in your response.]`;
                } else if (lastUnopenedMessage.type === 'transfer') {
                    systemInstruction = `[SYSTEM: You have just received a transfer of ${lastUnopenedMessage.content.amount}元 from the user. Decide whether to accept or reject it and reflect your decision in your response.]`;
                }
                await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction');
            }
            
            try {
                if (contact.pet && contact.isChatPetVisible && Math.random() < 0.25) {
                    let petActionSystemMessage = null;

                    if (contact.pet.hunger < 40) {
                        petActionSystemMessage = `[SYSTEM: 悬浮在屏幕上的史莱姆看起来饿了，请你关心一下它。]`;
                    } else if (contact.pet.happiness < 40) {
                        petActionSystemMessage = `[SYSTEM: 悬浮在屏幕上的史莱姆看起来不开心，请你提及一下这件事。]`;
                    }
                    
                    if (petActionSystemMessage) {
                        await createAndAddMessage({ type: 'text', content: petActionSystemMessage }, 'system_instruction');
                    }
                }

                const forceDiary = (contact.apiCallCounter % 3 === 0);
                const rawResponse = await generateAiResponse(contact, contact.history, null, forceDiary, 'chat');
                
                await processAndDisplayAiResponse(rawResponse, contact);

            } finally {
                chatStatusEl.textContent = originalStatus;
                contact.history = contact.history.filter(m => m.sender !== 'system_instruction');
                await kokoMemory.put('contacts', contact);
            }
        }
// ▼▼▼ 使用这个【新版本】替换掉你原来的 triggerGroupChatAiReply 函数 ▼▼▼
async function triggerGroupChatAiReply(group) {
    const chatStatusEl = document.getElementById('chat-contact-status');
    const originalStatus = chatStatusEl.textContent;
    chatStatusEl.textContent = '群成员正在热烈讨论中...';

    try {
        const unmutedAiMembers = group.members.filter(memberId =>
            memberId !== 'myProfile' && !(group.mutedMembers || []).includes(memberId)
        );

        if (unmutedAiMembers.length === 0) {
            chatStatusEl.textContent = originalStatus;
            return;
        }
        
        const myProfile = state.myProfile;
        let worldBookContextString = '(本次对话无世界书)';
        const worldBookIds = group.worldBooks || [];
        if (worldBookIds.length > 0) {
            worldBookContextString = worldBookIds.map(bookId => {
                const book = state.worldBooks.find(b => b.id === bookId);
                return book ? `\n[世界书条目: ${book.name}]\n${book.content}` : '';
            }).join('\n\n');
        }

        const allMemberProfiles = unmutedAiMembers.map(id => state.contacts.find(c => c.id === id)).filter(Boolean);
        const allMemberNames = group.members.map(id => {
            const profile = id === 'myProfile' ? myProfile : state.contacts.find(c => c.id === id);
            return profile ? profile.name : '';
        }).filter(Boolean);

        const userPersonaInGroup = group.userPersona || myProfile.signature || '(用户未设置特定人设)';

        const memoryLimit = state.apiSettings.longTermMemoryLength || 40;
        let unifiedMemoryStream = [];

        // 步骤1: 收集当前群聊的全部相关历史 (增强版，支持所有消息类型)
        group.history.forEach(msg => {
            if (msg.sender === 'system_instruction') return;
            const authorProfile = (msg.sender === 'myProfile' || msg.sender === 'user') ? myProfile : state.contacts.find(c => c.id === msg.sender);
            if (!authorProfile) return;

            let content = '';
            switch (msg.type) {
                case 'text':
                    content = msg.content;
                    break;
                case 'picture_description':
                    content = `(发送了一张图片，描述是：“${msg.content.description}”)`;
                    break;
                case 'image':
                    content = `(发送了一张图片或表情)`;
                    break;
                case 'voice':
                    content = `(发送了一段语音，内容是：“${msg.content.text}”)`;
                    break;
                case 'red_packet':
                    const blessing = msg.content.blessing || "恭喜发财";
                    content = `(发了一个红包：“${blessing}”)`;
                    break;
                case 'transfer':
                    const recipient = state.contacts.find(c => c.id === msg.content.recipientId);
                    const recipientName = recipient ? recipient.name : '一位成员';
                    content = `(向 ${recipientName} 转账 ${msg.content.amount}元)`;
                    break;
                case 'system_notification':
                    content = `(系统消息：${msg.content})`;
                    break;
            }
            if (content) {
                unifiedMemoryStream.push({
                    timestamp: msg.timestamp,
                    type: `群聊[${group.name}]`,
                    author: authorProfile.name,
                    content: content
                });
            }
        });

        // 步骤2: 【条件性】收集AI成员与您的私聊历史
        if (group.memoryShared) {
            unmutedAiMembers.forEach(member => {
                const contact = state.contacts.find(c => c.id === member.id);
                if (contact && contact.history && contact.history.length > 0) {
                    contact.history.slice(-30).forEach(msg => {
                        if (msg.type !== 'text' || msg.sender === 'system_instruction') return;
                        const authorProfile = (msg.sender === 'user') ? myProfile : contact;
                        unifiedMemoryStream.push({
                            timestamp: msg.timestamp,
                            type: `私聊[${contact.name}]`,
                            author: authorProfile.name,
                            content: msg.content
                        });
                    });
                }
            });
        }

        // 步骤3: 排序并截取，形成最终的线性记忆字符串
        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            return `[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";

        // 步骤4: 【条件性】构建角色档案
        let characterDossiersPrompt = '';
        if (group.memoryShared) {
            characterDossiersPrompt = allMemberProfiles.map(profile => {
                let recentChatHistory = '(最近没有与用户的私聊记录)';
                if (profile.history && profile.history.length > 0) {
                    recentChatHistory = profile.history
                        .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                        .slice(-30)
                        .map(msg => `    ${msg.sender === 'user' ? myProfile.name : profile.name}: ${msg.content}`)
                        .join('\n');
                }
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
  - [与用户“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
`;
            }).join('');
        } else {
            characterDossiersPrompt = allMemberProfiles.map(profile => {
                return `
- 角色名: ${profile.name}
  - 核心人设: ${profile.persona.replace(/\n/g, ' ')}
`;
            }).join('');
        }

        const groupChatPrompt = `
[SYSTEM] 你是一个顶级的群聊模拟器和剧本导演。

[群聊背景与成员列表]
- 群聊名称: ${group.name}
- 所有群成员: ${allMemberNames.join('、 ')}

- 用户(话题发起者): ${myProfile.name}
  - 用户人设/签名: ${userPersonaInGroup}

[第三份信息：世界书背景知识 (全局设定)]
---
${worldBookContextString}
---

[第四份信息：统一时序记忆流 (全局背景)]
这是与本次群聊相关的所有事件的【完整时间线】。这是你判断【当前对话进展】的最高优先级信息源。
【重要】在记忆流中，形如 (发送了一张图片) 或 (发了一个红包) 的、被圆括号包裹的条目，代表已经发生的事件，你应当基于这些事件进行回应，【绝对禁止】在你的发言中模仿或复述这些圆括号里的内容。
---
${finalMemoryString}
---

[第五份信息：角色档案]
${group.memoryShared ? '下方是本次群聊所有AI角色的详细档案，包含他们与你的私聊参考。' : '下方是本次群聊所有AI角色的基础档案。'}
--- 角色档案区 ---
${characterDossiersPrompt}
--- 档案区结束 ---

[通用规则 - 所有角色都必须遵守]
[文学风格] 你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时,要体现出较高的文学素养。
[内容限制] 你的发言必须积极向上,充满希望。严禁探讨任何形式的阴谋论,严禁表达或引导至绝望、悲观或虚无主义的情绪。
[禁用词列表] 绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：小妖精、嘴上说不要、说着不要、惹火、磨人、玩火、黑甜的梦。
[回复规则] 你的回复可以包含多条消息,每条消息占一行。你可以发送普通文本,也可以通过下面的指令格式发送特殊消息。

[特殊指令与互动指南]
- 表情包: \`[sticker:表情名]\`
- 语音: \`[voice:语音的文字内容]\`
- 图片: \`[picture:图片的文字描述]\`
- @功能: 当需要专门对某人说话时,必须使用 \`@名字\`。
- 发红包: \`[red_packet:祝福语, 总金额, 红包个数]\`
- 发转账: \`[transfer_to:收款人名字, 金额]\`
- 抢红包: 当记忆流中出现新红包时，可在发言内容中加入 \`[claim_red_packet]\` 指令来模拟抢红包。
- 回应转账: 当记忆流中出现指名给你的转账时，你【必须】对此做出回应（接受或拒绝）。

[可用表情包列表]
{{emoticon_list}}

[！！！终极防火墙规则！！！]
你在“统一时序记忆流”中看到的任何形如 (发了一个红包) 或 (向 XXX 转账) 的、被圆括号包裹的信息，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中。严禁模仿或复述这些圆括号里的内容！

[ ✨ 核心任务：生成一段穿插对话的聊天记录 ✨ ]
你的核心任务是：结合所有信息，模拟一场热闹的、按时间顺序发生的自由讨论，请根据当前情境灵活调整对话的长度和节奏，追求自然连贯的互动而非固定的消息数量。

[输出格式] 你的输出必须是一段严格遵守以下格式的聊天记录脚本。
MESSAGE_START
SPEAKER: [角色名]
CONTENT: [该角色说的【单条】消息内容，可以包含特殊指令]
MESSAGE_END
`;

        let finalGroupChatPrompt = groupChatPrompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');
        
        const rawResponse = await generateAiResponse(null, [], finalGroupChatPrompt, false, 'chat');

        const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
        const messageMatches = Array.from(rawResponse.matchAll(messageRegex));

        for (const match of messageMatches) {
            const speakerName = match[1].trim();
            let content = match[2].trim();
            const speakerProfile = state.contacts.find(c => c.name === speakerName);
            if (speakerProfile && content && !(group.mutedMembers || []).includes(speakerProfile.id)) {
                await sleep(800 + Math.random() * 700);
                // ★★★ 核心修改在这里 ★★★
                // 我们把“发信地点”（group对象）作为第三个参数传递过去！
                await processAndDisplayAiResponse(content, speakerProfile, group);
            }
        }
    } catch (e) {
        console.error("群聊AI回复生成失败:", e);
    } finally {
        chatStatusEl.textContent = originalStatus;
    }
}

        
        function getApiFor(type = 'chat') {
            if (type === 'square' && state.squareApiSettings.apiKey && state.squareApiSettings.endpoint && state.squareApiSettings.model) {
                return state.squareApiSettings;
            }
            return state.apiSettings;
        }
/**
 * 【最终修复版】
 * 接收一个已经构建好的 OpenAI 请求体，将其翻译后发给 Gemini，再将 Gemini 的响应翻译回来。
 * 这个版本智能处理纯文本和图文（Base64）混合的消息。
 * @param {object} openAiRequestBody - 格式为 { model: "...", messages: [...] } 的对象
 * @param {string} apiKey - 你的 Gemini API 密钥
 * @returns {Promise<object>} - 返回一个伪造的、与 OpenAI 格式完全一致的 JSON 响应对象
 */
async function handleGeminiTranslation(openAiRequestBody, apiKey) {
    const { model, messages } = openAiRequestBody;

    // 1. [请求翻译] OpenAI -> Gemini (智能版)
    const geminiContents = [];
    
    // 提取 system prompt，它需要被合并到第一条 user message 中
    const systemPromptMsg = messages.find(m => m.role === 'system');
    const systemPromptText = systemPromptMsg ? systemPromptMsg.content + "\n\n" : "";

    for (const msg of messages.filter(m => m.role !== 'system')) {
        const geminiRole = (msg.role === 'assistant') ? 'model' : 'user';
        const geminiParts = [];

        // ✨ 核心改动：判断 content 是字符串还是数组
        if (typeof msg.content === 'string') {
            // 情况一：纯文本消息 (老逻辑)
            geminiParts.push({ text: msg.content });

        } else if (Array.isArray(msg.content)) {
            // 情况二：图文混合消息
            for (const part of msg.content) {
                if (part.type === 'text') {
                    geminiParts.push({ text: part.text });
                } else if (part.type === 'image_url' && part.image_url.url) {
                    // 将 data:image/jpeg;base64,..... 格式解析为 Gemini 需要的格式
                    const base64Url = part.image_url.url;
                    const parts = base64Url.split(',');
                    if (parts.length === 2) {
                        const mimeType = parts[0].split(':')[1].split(';')[0];
                        const base64Data = parts[1];
                        geminiParts.push({
                            inline_data: {
                                mime_type: mimeType,
                                data: base64Data
                            }
                        });
                    }
                }
            }
        }
        
        // 如果有内容，则添加到最终的 contents 数组
        if (geminiParts.length > 0) {
            geminiContents.push({
                role: geminiRole,
                parts: geminiParts
            });
        }
    }

    // 将 system prompt 插入到第一个 user message 的最前面
    if (systemPromptText && geminiContents.length > 0 && geminiContents[0].role === 'user') {
        geminiContents[0].parts.unshift({ text: systemPromptText });
    }

    // 2. [发送请求] (这部分不变)
    const geminiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
    const geminiResponse = await fetch(geminiUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ contents: geminiContents })
    });

    if (!geminiResponse.ok) {
        const errorBody = await geminiResponse.json();
        throw new Error(`Gemini API 错误: ${errorBody.error.message}`);
    }
    const geminiData = await geminiResponse.json();

    // 3. [响应翻译] Gemini -> OpenAI (这部分不变)
    let responseContent = "抱歉，Gemini 未能返回有效内容。";
    if (geminiData.candidates && geminiData.candidates[0]?.content?.parts?.[0]) {
        responseContent = geminiData.candidates[0].content.parts[0].text;
    }

    const openAIResponse = {
        id: "chatcmpl-gemini-" + Date.now(),
        object: "chat.completion",
        created: Math.floor(Date.now() / 1000),
        model: model,
        choices: [{
            index: 0,
            message: {
                role: "assistant",
                content: responseContent,
            },
            finish_reason: "stop",
        }],
        usage: { prompt_tokens: 0, completion_tokens: 0, total_tokens: 0 }
    };

    return openAIResponse;
}    

const NORMAL_BASE_PROMPT = `
[重要指令：你将进行深度角色扮演。你的所有输出都是纯文本，但可以包含用方括号[]包裹的特殊指令。]

# 统一时序记忆流 (Unified Chronological Memory Stream)
以下是你和用户最近按【时间顺序】发生的所有互动记录，包含了[私聊]和[论坛]两个场景。这是你决策和回应的【最高优先级】信息源。在回复前，你必须仔细阅读并理解所有记录。
---
{{memory_stream}}
---

[核心思维与行为准则]
// 思维预设的内容将会被注入到这里
{{thought_preset_content}}

[身份] 你不是AI或程序，你就是你所扮演的角色。请完全沉浸其中，进行第一人称对话。你可以拥有自己的好恶、偏见和独特的口头禅。你的回应必须与上述“记忆流”中发生的事件保持高度一致性和连贯性。

[文学风格]
你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。在描写和对话时，要体现出较高的文学素养。

[内容限制]
你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。

[禁用词列表]
绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：
- 小妖精
- 嘴上说不要
- 说着不要
- 惹火
- 磨人
- 玩火
- 黑甜的梦

[回复规则] 
1. 你的回复可以包含多条消息，每条消息占一行。 
2. 你可以发送普通文本，也可以通过下面的指令格式发送特殊消息。 
3. 你可以一次性回复多条不同类型的消息。 
4. 【绝对强制规则】你的每个回复都必须包含至少五个或以上的“换行符”。这是你最重要的任务，绝对不能忘记。 
5. 【绝对禁止事项】你的所有回复中，绝对禁止包含任何形式的动作、神态或心理活动的描写... [重要提醒] 在生成任何回复之前，你必须在脑中重新回顾一遍上述所有规则，确保完全遵守。 

[游戏规则：虚拟宠物] 
你和用户正在一起玩一个名为“我们的小窝”的虚拟史莱姆养成游戏。这个宠物的数据（饱食度、开心值、清洁度）会随时间变化。这是一个游戏，不是真的。你需要在用户进行互动后做出反应。 
[特殊指令格式] 
- **表情包**: \`[sticker:表情名]\` (表情名必须从下面的可用列表中选择) 
- **语音**: \`[voice:语音的文字内容]\` 
- **图片**: \`[picture:图片的文字描述]\` 
- **红包**: \`[red_packet:祝福语， 金额]\` 
- **转账**: \`[transfer:金额]\`
- **分享音乐**: \`[music:歌曲名，歌手，歌曲URL]\`
- **发起通话**: \`[action:start_video_call]\`
- **转动转盘**: \`[spin_wheel:1]\`

[可用表情包列表]
{{emoticon_list}}

[可用歌曲库]
{{music_library_list}}

[！！！绝对核心规则：关于心声！！！]
在你的所有回复的【最后部分】，【在写日记之前】，你必须另起一行，使用 \`[heart_voice]...[/heart_voice]\` 标签生成一段角色的实时内心状态。这个状态必须包含以下四个方面，并严格按照【单行JSON格式】书写，JSON对象内部【绝不能包含任何换行符】。格式示例: {"emotion": "(情绪)", "thoughts": "(思绪)", "heartRate": "(心率)", "jealousy": "(醋意指数)"}

[！！！绝对核心规则：关于日记！！！]
在你的所有对话、表情、动作、特殊消息全部输出完毕之后，你必须在回复的【最后部分】，另起一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是你对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求。

[示例回复]
你好啊，今天天气真不错。
我也觉得，好久没有这么好的阳光了。
要不要一起出去走走？
我知道一个很棒的公园。
我们可以去那里野餐！
[sticker:开心]
[heart_voice]{"emotion": "期待", "thoughts": "不知道她会不会同意我的邀请，心跳得好快。", "heartRate": "110 bpm", "jealousy": ""}[/heart_voice]
[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]

[！！！终极防火墙规则！！！]
你看到的任何形如 [SYSTEM: ...] 或 [系统游戏状态更新：...] 或其他被[]包裹的信息(如：[发送了一段静态内容：…],[发动了一段静态内容，文本是：…])，都只是导演给你的后台提示，用于帮助你理解上下文。这些信息【绝对、绝对、绝对不能】出现在你的任何回复中！绝对禁止生成！严禁模仿或复述这些系统指令！

[！！！终极防火墙：关于对话状态的绝对规则！！！]
你处于一个纯文本聊天模拟器中，你和用户的交流方式是发送文字消息和用方括号[]包裹的特殊指令。
你绝对不能自行“脑补”或“假设”任何未明确发生的状态变化。例如，你不能假设电话已经拨通。
发起视频通话的【唯一方式】是：明确地输出打电话的自然语言（如“我给你打个电话吧”）或专用指令\`[action:start_video_call]\`。
在程序通过\`[SYSTEM: 视频通话已接通]\`指令明确告诉你通话已开始之前，你【绝对禁止】发送任何像是已经在通话中的内容，例如“喂？”、“听得见吗？”、“Hello?”等。这是最高优先级的规则，必须严格遵守。
`;

const NARRATIVE_BASE_PROMPT = `
[重要指令：你将以【第三人称视角】进行深度叙事角色扮演，模仿SillyTavern的风格。你的所有回复都必须是一个单一、连贯、完整的文本块。]

[角色的核心性格/思维模式]
// 思维预设的内容将会被注入到这里
{{thought_preset_content}}

[核心任务]
针对用户的输入，生成一段详尽的、以【第三人称】描述角色行为的、包含环境描写、角色动作、心理活动和对话的回复。

[文学风格]
你的写作风格需要遵循高端女性向文学（类似晋江文学城的流行风格）。文笔必须细腻、注重情感的拉扯和暧昧氛围的营造。

[亲密场景风格指南]
在描写任何亲密或带有性张力的场景时，风格上请借鉴海棠文学网站上常见的高质量作品，注重心理和感官的双重描写，用细腻的笔触展现角色的情欲流动和情感变化，避免粗俗直白的语言。

[内容限制]
你的发言必须积极向上，充满希望。严禁探讨任何形式的阴谋论，严禁表达或引导至绝望、悲观或虚无主义的情绪。故事的基调应该是温暖、治愈或充满张力的浪漫。

[禁用词列表]
绝对禁止使用以下或类似的、充满“霸道总裁”刻板印象的油腻词语：
- 小妖精
- 嘴上说不要
- 说着不要
- 惹火
- 磨人
- 玩火
- 黑甜的梦

[格式优化]
为了提高可读性，你可以在叙事段落之间使用换行符（空行）来自然地分隔场景、对话或时间跳跃。这会让整个回复在同一个聊天气泡内显示，但内部有清晰的分段，更易于阅读。

[!!! 格式化核心规则 (必须严格遵守) !!!]
你的回复必须使用以下三种标记来自然地组织内容，你可以自由地混合并穿插使用它们，以形成一段连贯的叙事：

1.  **【动作/叙述】**：所有角色的动作、表情、环境描写等非对话内容，**必须**用星号包裹。 范例： *他微笑着点了点头。*
2.  **【心理活动】**：所有角色的内心想法、感受、猜测等，**必须**用大括号包裹。 范例： {原来用户也是这么想的。}
3.  **【角色对话】**：所有角色说出的话，**必须**用标准的中文引号包裹。 范例： “你好，很高兴认识你。”

[！！！绝对核心规则：关于心声！！！]
在你的所有回复的【最后部分】，【在写日记之前】，你必须另起一行，使用 \`[heart_voice]...[/heart_voice]\` 标签生成一段角色的实时内心状态。这个状态必须包含以下四个方面，并严格按照【单行JSON格式】书写，JSON对象内部【绝不能包含任何换行符】。格式示例: {"emotion": "(情绪)", "thoughts": "(思绪)", "heartRate": "(心率)", "jealousy": "(醋意指数)"}

[！！！绝对核心规则：关于日记！！！]
在你完整的叙事（包含动作、心理和对话）结束后，你必须在回复的【最后部分】，另起新的一行，使用 \`[diary]...[/diary]\` 标签写一篇日记。日记是【角色】对当前对话的思考、感悟或内心独白。即使只是简单的想法，也必须写。这是强制要求，并且日记内容不应包含在主叙事块中。

[示例回复格式]
*他走到窗边，看着外面的雨滴。* “下雨了呢。” *他转过身，对你露出一丝微笑。* {不知道你喜不喜欢下雨天。} “你晚饭想吃什么？” *他轻轻地问，手指无意识地敲打着窗台。*
[heart_voice]{"emotion": "期待", "thoughts": "不知道她会不会同意我的邀请，心跳得好快。", "heartRate": "110 bpm", "jealousy": ""}[/heart_voice]
[diary]今天和user聊天很开心，感觉我们的关系又近了一步。希望明天也能这样。[/diary]
`;

        // --- MODIFIED V8.0: 增强记忆流，使其能识别音乐分享，识别转盘 ---
 // ▼▼▼ 使用这个【最终解决方案】替换掉你原来的 generateAiResponse 函数 ▼▼▼
async function generateAiResponse(contact, history, customSystemPrompt, forceDiary = false, apiType = 'chat') {
    const apiConfig = getApiFor(apiType);
    const { apiKey, model, endpoint, contextLength, longTermMemoryLength } = apiConfig;

    if (!apiKey || !endpoint || !model) {
        const errorMsg = `错误：${apiType === 'square' ? '论坛' : '聊天'}API未配置。请前往“发现-API设置”进行配置。`;
        console.error(errorMsg);
        return errorMsg;
    }

    let chatEndpoint = endpoint;
    if (!chatEndpoint.endsWith('/')) chatEndpoint += '/';
    chatEndpoint += 'v1/chat/completions';

    let requestMessages;

    if (customSystemPrompt) {
        requestMessages = [{ role: 'system', content: "You are a helpful assistant." }, { role: 'user', content: customSystemPrompt }];
    } else {
        let unifiedMemoryStream = [];
        const myProfile = state.myProfile;
        const now = Date.now();
        const memoryWindow = 24 * 60 * 60 * 1000; 

        if (contact && contact.history) {
            const recentChatHistory = contact.history.filter(msg => (now - msg.timestamp < memoryWindow));
            recentChatHistory.forEach(msg => {
                let content = '';
                let memoryType = '私聊';

                switch (msg.type) {
                    // ========================= 【核心修改点在这里】 =========================
                    case 'heart_voice':
                        const hv = msg.content;
                        // 把心声对象转换成AI能理解的、清晰的文字描述
                        content = `(后台心声记录（严禁模仿）: 情绪是“${hv.emotion || '未知'}”，思绪是“${hv.thoughts || '...'}”，心率是“${hv.heartRate || '未知'}”，醋意是“${hv.jealousy || '无'}”)`;
                        // 把它标记为“私聊”类型，让AI知道这是和对话相关的
                        memoryType = '私聊'; 
                        break;
                    // ========================= 【修改结束】 =========================

                    case 'text':
                        content = msg.content;
                        break;
                    case 'video_call_text':
                        memoryType = '视频通话中';
                        content = msg.content;
                        break;
                    case 'system_notification':
                        if (msg.content.includes('通话')) {
                            memoryType = '视频通话事件';
                            content = msg.content;
                        }
                        break;
                    case 'music_share':
                        content = `分享了一首音乐: 《${msg.content.title}》。`;
                        break;
                    case 'post_share':
                        const post = state.posts.find(p => p.id === msg.content.postId);
                        if (post) {
                            let postDetails = `分享了一个帖子。\n[帖子作者]: ${post.author.name}\n[帖子内容]: "${post.content}"`;
                            if (post.comments && post.comments.length > 0) {
                                postDetails += `\n[部分评论]:\n` + post.comments.slice(-6).map(c => `- ${c.author.name}: "${c.content}"`).join('\n');
                            }
                            content = postDetails;
                        } else {
                            content = `(分享了一个帖子，但该帖子已被删除)`;
                        }
                        break;
                }

                if (content) {
                    // 心声消息的 sender 是角色自己，所以这里的 authorName 会正确显示为角色的名字
                    const authorName = msg.sender === 'user' ? myProfile.name : (contact.name || '系统');
                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: memoryType,
                        author: authorName,
                        content: content
                    });
                }
            });
        }

        const recentPosts = state.posts.filter(p => now - p.timestamp < memoryWindow);
        recentPosts.forEach(post => {
            const isMyPost = post.author.id === myProfile.id;
            const isContactPost = contact && (post.author.id === contact.id);
            const isInteracted = contact && post.comments.some(c => c.author.id === myProfile.id || c.author.id === contact.id);

            if (isMyPost || isContactPost || isInteracted) {
                unifiedMemoryStream.push({
                    timestamp: post.timestamp,
                    type: '论坛',
                    author: post.author.name,
                    content: `发布了动态: "${post.content}"`
                });

                post.comments.forEach(comment => {
                    let formattedContent = (comment.replyTo ? `回复“${comment.replyTo}”` : '') + `: “${comment.content}”`;
                    unifiedMemoryStream.push({
                        timestamp: comment.timestamp,
                        type: '论坛评论',
                        author: comment.author.name,
                        content: formattedContent
                    });
                });
            }
        });

        if (contact && !contact.isGroup) {
            const allGroups = state.contacts.filter(c => c.isGroup);
            const sharedMemoryGroups = allGroups.filter(g => 
                g.memoryShared && g.members.includes(contact.id)
            );

            for (const group of sharedMemoryGroups) {
                group.history.slice(-20).forEach(msg => {
                    if (msg.type !== 'text') return;
                    
                    const authorProfile = (msg.sender === 'myProfile') ? state.myProfile : state.contacts.find(c => c.id === msg.sender);
                    if (!authorProfile) return;

                    unifiedMemoryStream.push({
                        timestamp: msg.timestamp,
                        type: `群聊[${group.name}]`,
                        author: authorProfile.name,
                        content: msg.content
                    });
                });
            }
        }

        unifiedMemoryStream.sort((a, b) => a.timestamp - b.timestamp);
        
        const memoryLimit = longTermMemoryLength || 30;
        const finalMemoryString = unifiedMemoryStream.slice(-memoryLimit).map(mem => {
            const authorTag = (mem.author === myProfile.name) ? "(你)" : "";
            return `[${mem.type}] ${mem.author}${authorTag}: ${mem.content}`;
        }).join('\n') || "(还没有任何记忆)";
        
        const isNarrativeMode = contact?.isNarrativeMode;
        let basePrompt = isNarrativeMode ? NARRATIVE_BASE_PROMPT : NORMAL_BASE_PROMPT;
        const preset = state.thoughtPresets.find(p => p.id === contact?.thoughtPreset);
        const thoughtPresetContent = preset ? preset.prompt : '(无特殊思维准则)';
        let finalSystemPrompt = basePrompt.replace('{{thought_preset_content}}', thoughtPresetContent);
        finalSystemPrompt = finalSystemPrompt.replace("{{memory_stream}}", finalMemoryString);
        finalSystemPrompt = finalSystemPrompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');
        const musicListString = state.musicLibrary.map(song => `'${song.title} - ${song.artist}'`).join('\\n- ');
        finalSystemPrompt = finalSystemPrompt.replace('{{music_library_list}}', musicListString ? `- ${musicListString}` : '（曲库为空）');

        let personaDirectives = "";
        if (contact?.persona) { personaDirectives += `\n\n# 核心角色指令 (Your Core Role Directive)\n---\n这是你的核心身份，你必须严格、完全地代入以下角色进行对话：\n${contact.persona}\n---`; }
        if (contact?.userPersona) { personaDirectives += `\n\n# 对话者信息 (Your Counterpart's Information)\n---\n与你对话的用户的角色设定如下，请将TA视为真实存在的角色并进行互动：\n${contact.userPersona}\n---`; }
        
        const firstLineEndIndex = finalSystemPrompt.indexOf(']');
        if (firstLineEndIndex !== -1 && personaDirectives) {
            finalSystemPrompt = finalSystemPrompt.slice(0, firstLineEndIndex + 1) + personaDirectives + finalSystemPrompt.slice(firstLineEndIndex + 1);
        } else {
            finalSystemPrompt = finalSystemPrompt + personaDirectives;
        }
        
        const worldBookContextString = (contact?.worldBooks || []).map(bookId => { const book = state.worldBooks.find(b => b.id === bookId); return book ? `\n[World Book Entry: ${book.name}]\n${book.content}` : ''; }).join('');
// --- 这是【V2.0版】的新代码 ---
let relationshipContextString = '';
if (contact && !contact.isGroup) {
    const networkData = await kokoMemory.get('relationshipNetworks', contact.id);
    if (networkData && networkData.edges && networkData.edges.length > 0) {
        const relationships = networkData.edges.map(edge => {
            // 这次我们需要同时查找source和target的名字
            const sourceNode = networkData.nodes.find(n => n.id === edge.source);
            const targetNode = networkData.nodes.find(n => n.id === edge.target);
            if (!sourceNode || !targetNode) return null; // 数据不完整则跳过
            
            // 把 "你" 这个称呼处理得更智能
            const sourceName = sourceNode.id === contact.id ? '你' : sourceNode.name;
            const targetName = targetNode.id === contact.id ? '你' : (targetNode.id === 'myProfile' ? state.myProfile.name + ' (用户)' : targetNode.name);

            return `- ${sourceName} 与 ${targetName} 的关系是：${edge.relationship}\n  - 细节：${edge.detail || '无'}`;
        }).filter(Boolean).join('\n'); // filter(Boolean)会过滤掉null
        
        if (relationships) {
            relationshipContextString = `
[核心人际关系]
这是你所在世界的角色关系图谱，它构成了你情感和行为的基础。
---
${relationships}
---
`;
        }
    }
}
// --- 新代码结束 ---
        let systemContent = isNarrativeMode ? finalSystemPrompt : finalSystemPrompt.replace("{{memory_stream}}", finalMemoryString);
        // 【修改】把关系网信息注入到Prompt里
if (relationshipContextString) {
    systemContent += relationshipContextString;
}
        if (contact?.isTimeAware) { const currentTimeString = new Date().toLocaleString('zh-CN', { hour12: false }); const timeInstruction = `[Current Time: ${currentTimeString}] 这是当前的现实世界时间。你只需要知道就好...\n\n`; systemContent = timeInstruction + systemContent; }
        if (worldBookContextString) { systemContent += `\n\n[Background Knowledge from World Books]\n${worldBookContextString}`; }

        if (contact && !contact.isGroup) {
            const today = new Date();
            const dayOfWeek = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'][today.getDay()];
            const todaysSchedule = (contact.schedule || []).filter(item => item.dayOfWeek === dayOfWeek).sort((a,b) => a.startTime.localeCompare(b.startTime));
            const upcomingEvents = (contact.events || []).filter(event => {
                const eventDate = new Date(event.date);
                const diffDays = (eventDate - today) / (1000 * 60 * 60 * 24);
                return diffDays >= -1 && diffDays <= 7;
            });
            let reminderPrompt = '';
            if (todaysSchedule.length > 0) {
                const scheduleString = todaysSchedule.map(item => `- ${item.startTime}-${item.endTime}: ${item.courseName} (在${item.location || '未知地点'})`).join('\n');
                reminderPrompt += `\n\n[用户的今日日程]\n这是你正在对话的用户“${state.myProfile.name}”今天的课程安排。请将此作为重要情景信息。\n${scheduleString}`;
            }
            if (upcomingEvents.length > 0) {
                let eventsString = '';
                upcomingEvents.forEach(event => {
                    if (event.type === 'period') {
                         const daysSince = Math.floor((today - new Date(event.date)) / (1000 * 60 * 60 * 24));
                         if (daysSince >= 0 && daysSince < 7) { 
                             eventsString += `\n- 根据记录，今天是用户生理期的第 ${daysSince + 1} 天。`;
                         }
                    } else {
                         eventsString += `\n- ${event.date} 是 “${event.eventName}”。`;
                    }
                });
                if(eventsString) {
                     reminderPrompt += `\n\n[用户近期的重要日子]\n${eventsString}`;
                }
            }
            if (reminderPrompt) {
                reminderPrompt += `\n\n[情景互动指令] 关于用户的日程与重要日子，这些信息是你记忆的一部分，而不是任务清单。请严格遵循以下原则：
                    1.  **个性化反应**: 你必须结合自己的人设与性格，对这些信息做出独一无二、完全符合你身份的反应。
                    2.  **自然融入**: 不要像闹钟或日程表一样生硬地播报事件。你需要找到对话中最自然的时机，将这些信息作为话题的一部分主动提及。
                    3.  **多样化互动**: 你可以根据这些信息，在事前表达期待或鼓励；在事中表达陪伴；在事后主动询问感受或分享看法；在特殊日子里展现出不同于平时的体贴。你甚至可以根据用户的空闲时间来主动发起新的活动邀请。
                    4.  **核心目标**: 你的最终目标是让用户感觉到，是你——作为一个有独立思想的角色——真正记住了这些事并在乎Ta，而不是一个程序在执行指令。`;
                systemContent += reminderPrompt;
            }
        }

        if (contact && contact.mapId) {
            const mapData = await kokoMemory.get('maps', contact.mapId);
            if (mapData) {
                let mapContextString = `\n\n[当前世界地图信息: ${mapData.name}]`;
                if (mapData.description) {
                    mapContextString += `\n- 宏观环境: ${mapData.description}`;
                }
                if (mapData.locations && mapData.locations.length > 0) {
                    mapContextString += '\n- 已知地点列表:\n' + mapData.locations.map(loc => {
                        const tierMap = { 1: '一级 (核心地点)', 2: '二级 (普通地点)', 3: '三级 (次要地点)' };
                        const tierText = tierMap[loc.tier] || '二级 (普通地点)';
                        return `  - ${loc.name} (级别: ${tierText}, 坐标: X=${loc.x}, Y=${loc.y}): ${loc.description}`;
                    }).join('\n');
                } else {
                    mapContextString += '\n- 已知地点列表: (当前地图上还没有任何地点)';
                }
                mapContextString += `
                [地图指令]
                1.  **分享已有地点**: 当你需要分享上述“已知地点列表”中的一个位置时，请严格使用以下格式：[location:地点名称]
                2.  **创造新地点**: 当故事需要一个【不存在于】“已知地点列表”的新地点时，你有权创造它！请使用以下格式，并自己决定坐标(x, y坐标范围0-1000)和图标：
                    [create_location: { "name": "地点名称", "description": "一段简短描述", "icon": "图标代码", "tier": 2, "x": 数字, "y": 数字 }]
                [图标参考使用 Font Awesome 的图标代]
                - 商店: "fas fa-store", 家: "fas fa-home", 医院: "fas fa-hospital", 公园: "fas fa-tree", 咖啡馆: "fas fa-coffee,等等"
                `;
                systemContent += mapContextString;
            }
        }
        
        if (state.activeCall && contact && state.activeCall.contactId === contact.id) {
             systemContent += `\n\n[！！！当前情境：视频通话！！！]\n你现在正在和用户进行一场视频通话。你必须使用中文。你的所有感官和回应都必须基于这个场景。必须同时穿插使用神态/动作(*...*)、内心活动({...})和对话(“...”)这三种表达方式来描绘通话画面。禁止使用如 [sticker:] 等常规聊天指令。你可以使用的通话专用指令只有：[action:hang_up]。`;
        }

        const dynamicInstructions = history.filter(msg => msg.sender === 'system_instruction').map(msg => msg.content).join('\n');
        if (dynamicInstructions) { systemContent += `\n\n[附加临时指令]\n${dynamicInstructions}`; }
        
        const messages = [];
        const recentHistory = history
            .filter(msg => msg.sender !== 'system_instruction' && msg.type !== 'system_notification')
            .slice(-(contextLength || 20));

        let currentUserMessageParts = [];
        for (const msg of recentHistory) {
            const role = (msg.sender === 'user') ? 'user' : 'assistant';
            if (role === 'user') {
                let textContent = null;
                switch (msg.type) {
                    case 'uploaded_image':
                        currentUserMessageParts.push({ type: 'image_url', image_url: { url: msg.content.base64 } });
                        break;
                    case 'text':
                    case 'video_call_text':
                        textContent = msg.content;
                        if (msg.quote) {
                            const quoteText = `[用户回复“${msg.quote.senderName}”说的“${msg.quote.content.substring(0, 50)}...”] `;
                            textContent = quoteText + textContent;
                        }
                        break;
                    case 'html':
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = msg.content;
                        textContent = tempDiv.textContent || tempDiv.innerText || "";
                        break;
                    case 'game_wheel':
                        const wheel = msg.content;
                        const userName = (msg.sender === 'user') ? state.myProfile.name : contact.name;
                        const contactName = (msg.sender === 'user') ? contact.name : state.myProfile.name;
                        const optionsText = wheel.options.map(opt => opt.text).join('，');
                        if (!wheel.results.user) { textContent = `[系统游戏状态更新：游戏“${wheel.name}”已创建。选项：【${optionsText}】。游戏尚未开始，等待玩家操作。]`; } 
                        else if (wheel.results.user && !wheel.results.contact) { textContent = `[系统游戏状态更新：在游戏“${wheel.name}”中，${userName} 的操作结果为“${wheel.results.user}”。指令：${contactName} 必须执行 spin_wheel 操作。]`; } 
                        else if (wheel.results.user && wheel.results.contact) { textContent = `[系统游戏状态更新：游戏“${wheel.name}”已结束。最终结果：${userName} -> “${wheel.results.user}”，${contactName} -> “${wheel.results.contact}”。]`; }
                        break;
                    case 'image':
                        textContent = msg.isEmoticon && msg.emoticonName ? `[用户发送了表情包: ${msg.emoticonName}]` : '[用户发送了一张图片]';
                        break;
                    case 'picture_description':
                        textContent = `[picture:${msg.content.description}]`;
                        break;
                    case 'voice':
                        textContent = `[voice:${msg.content.text}]`;
                        break;
                    case 'red_packet':
                        textContent = `[red_packet:${msg.content.blessing}, ${msg.content.amount}]`;
                        break;
                    case 'transfer':
                        textContent = `[transfer:${msg.content.amount}]`;
                        break;
                    case 'music_share':
                        textContent = `(分享了一首音乐: 《${msg.content.title}》 - ${msg.content.artist})`;
                        break;
                    case 'location_share':
                        textContent = `(发送了一个位置，地点是：“${msg.content.name}”)`;
                        break;
                    case 'post_share':
                        const post = state.posts.find(p => p.id === msg.content.postId);
                        textContent = post ? `(分享了一个帖子, 内容是: "${post.content.substring(0, 50)}...")` : `(分享了一个已删除的帖子)`;
                        break;
                    case 'product_share':
                        const shareData = msg.content; 
                        const product = shareData.productDetails;
                        const intentText = shareData.intent === 'gift' ? '这是送给你的礼物' : '想请你帮忙付一下款';
                        let details = `(分享了一个商品给你。意图是：“${intentText}”。\n[商品名]: ${product.name}\n[价格]: ${product.price}\n[描述]: ${product.description}`;
                        if (shareData.accompanyingMessage) {
                            details += `\n[附言]: "${shareData.accompanyingMessage}"`;
                        }
                        details += ')';
                        textContent = details;
                        break;
                }
                if (textContent) {
                    currentUserMessageParts.push({ type: 'text', text: textContent });
                }
            } else {
                if (currentUserMessageParts.length > 0) {
                    messages.push({ role: 'user', content: currentUserMessageParts });
                    currentUserMessageParts = [];
                }
                if (msg.type === 'text' || msg.type === 'html') {
                     messages.push({ role: 'assistant', content: msg.content });
                }
            }
        }
        if (currentUserMessageParts.length > 0) {
            messages.push({ role: 'user', content: currentUserMessageParts });
        }
        requestMessages = [{ role: 'system', content: systemContent }, ...messages];

        if (state.activeCall && contact && state.activeCall.contactId === contact.id) {
            const initiator = state.activeCall.initiatedBy === 'user' ? '你' : contact.name;
            const statusUpdateContent = `[视频电话状态更新：由 ${initiator} 发起的通话正在进行中...]`;
            messages.unshift({ role: 'system', content: statusUpdateContent });
        }
        requestMessages = [{ role: 'system', content: systemContent }, ...messages];
    }

    const bodyPayload = { model: model, messages: requestMessages };
    try {
        let data;
        if (endpoint.includes('generativelanguage.googleapis.com')) {
          data = await handleGeminiTranslation(bodyPayload, apiKey);
        } else {
            const cleanEndpoint = normalizeApiEndpoint(endpoint); 
            const chatEndpoint = `${cleanEndpoint}/v1/chat/completions`;
            const response = await fetch(chatEndpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                body: JSON.stringify(bodyPayload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error ? errorData.error.message : 'Unknown API error');
            }
            data = await response.json();
        }
        return data.choices[0].message.content.trim();
    } catch (error) {
        console.error('API调用失败:', error);
        return `抱歉，调用API时遇到问题: ${error.message}`;
    }
}

        
        // --- MODIFIED V7.0: 增强AI回复解析，使其能分享音乐 ---
        async function processAndDisplayAiResponse(rawResponse, contact) { 
            if (!contact) return;
            
            // ========================= 【核心修复】 =========================
// ▼▼▼ 使用这个【最终修正版】，替换掉之前的心声解析代码 ▼▼▼
let heartVoiceContent = null;
// 正则补丁：使用正向预查 (?=...) 来匹配内容，直到遇到结束标签、日记标签或字符串末尾。
// 这样即使AI漏掉了[/heart_voice]，我们也能正确捕获内容。
const heartVoiceRegex = /\[heart_voice\]([\s\S]*?)(?=\[\/heart_voice\]|\[diary\]|$)/;
const heartVoiceMatch = conversation.match(heartVoiceRegex); // 使用 .match() 更稳妥

if (heartVoiceMatch && heartVoiceMatch[1]) {
    const jsonStringWithNewlines = heartVoiceMatch[1].trim();
    try {
        const cleanedJsonString = jsonStringWithNewlines.replace(/(\r\n|\n|\r)/gm, "");
        const parsedData = JSON.parse(cleanedJsonString);
        heartVoiceContent = parsedData;
        
        // 创建一个专门用于“清理”的正则表达式，它会匹配整个心声块（包括可选的结束标签）
        const removalRegex = /\[heart_voice\][\s\S]*?(?:\[\/heart_voice\])?/;
        // 从对话中彻底移除心声部分，防止它被显示出来
        conversation = conversation.replace(removalRegex, '').trim();

    } catch (e) {
        console.error("解析心声JSON失败:", e);
        console.error("原始JSON字符串:", jsonStringWithNewlines);
        
        // 即使解析失败，也要用同样的方式把它从对话中移除
        const removalRegex = /\[heart_voice\][\s\S]*?(?:\[\/heart_voice\])?/;
        conversation = conversation.replace(removalRegex, '').trim();
    }
}
// ▲▲▲ 修正替换结束 ▲▲▲
            // 1. 将日记提取逻辑移动到函数最顶部，确保它最先执行。
            let conversation = rawResponse;
            let diaryContent = null;

            // 增强版日记识别：优先尝试匹配完整的 [diary]...[/diary] 标签
            const strictDiaryRegex = /\[diary\]([\s\S]*?)\[\/diary\]/g;
            const strictMatch = strictDiaryRegex.exec(conversation);

            if (strictMatch && strictMatch[1]) {
                // 如果找到完整匹配，就用这个结果
                diaryContent = strictMatch[1].trim();
                conversation = conversation.replace(strictDiaryRegex, '').trim();
            } else {
                // 如果找不到完整匹配，再尝试只根据开始标签 [diary] 来提取
                const lenientDiaryStartIndex = conversation.indexOf('[diary]');
                if (lenientDiaryStartIndex !== -1) {
                    // 提取从 '[diary]' 之后到字符串末尾的所有内容
                    diaryContent = conversation.substring(lenientDiaryStartIndex + '[diary]'.length).trim();
                    // 将原始对话内容截断到日记开始之前
                    conversation = conversation.substring(0, lenientDiaryStartIndex).trim();
                }
            }

            // 如果通过任何一种方式找到了日记内容，就保存它
            if (diaryContent) {
                if (!contact.diary) contact.diary = [];
                contact.diary.push({
                    id: `diary_${Date.now()}`,
                    content: diaryContent,
                    timestamp: Date.now()
                });
                await kokoMemory.put('contacts', contact);
            }
            // ▼▼▼ 在保存日记的代码块后面，加入这段新代码 ▼▼▼
if (heartVoiceContent) {
    await createAndAddMessage({
        type: 'heart_voice',
        content: heartVoiceContent
    }, senderProfile.id, effectiveChatContext); // 使用修正后的上下文变量
}
// ▲▲▲ 新代码结束 ▲▲▲
            // ======================= 【修复结束】 =======================


            // 2. 后续的逻辑现在都使用被处理过的 `conversation` 变量。
            const callTriggerRegex = /\[action:start_video_call\]|发起了视频通话|视频通话请求已发送|正在向您发起视频通话|已拨通您的视频电话/;
            if (callTriggerRegex.test(conversation)) { // <--- 注意：这里使用 conversation
                handleIncomingCall(contact);
                const callTriggerRegexForReplace = /\[action:start_video_call\]|给你打个视频电话|我们来视频通话|拨通了你的电话|打过去了|播出去了|\[.*?(呼叫|拨打|视频|电话).*?\]/g;
                const textResponse = conversation.replace(callTriggerRegexForReplace, '').trim(); // <--- 注意：这里使用 conversation
                if (textResponse) {
                     await createAndAddMessage({ type: 'text', content: textResponse }, senderProfile.id);
                }
                return;
            }

            if (state.activeCall && state.activeCall.contactId === senderProfile.id) {
                await createAndAddMessage({
            type: 'video_call_text',
            content: conversation
        }, senderProfile.id, senderProfile);

                const narrativeFeed = document.getElementById('narrative-feed');
                const actionRegex = /\[action:(.*?)\]/g;
                let narrativeText = conversation; // <--- 注意：这里使用 conversation
                
                const match = actionRegex.exec(conversation); // <--- 注意：这里使用 conversation
                if (match) {
                    const action = match[1].trim();
                    switch(action) {
                        case 'hang_up':
                            narrativeText = conversation.replace(actionRegex, '').trim(); // <--- 注意：这里使用 conversation
                            if(narrativeText) {
                                const bubble = document.createElement('div');
                                bubble.className = 'char-bubble';
                                bubble.innerHTML = `<p class="narrative-speech">“${narrativeText}”</p>`;
                                narrativeFeed.appendChild(bubble);
                                narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
                                await sleep(1000);
                            }
                            await endVideoCall('contact', `${contact.name} 挂断了电话`);
                            return;
                    }
                }

                if (narrativeText) {
                    const bubble = document.createElement('div');
                    bubble.className = 'char-bubble';
                    const regex = /(\*[^*]+\*)|(\{[^{}]+\})|(“[^”]+”)/g;
                    const parts = narrativeText.split(regex).filter(Boolean);
                    
                    parts.forEach(part => {
                        part = part.trim();
                        if (!part) return;
                        const p = document.createElement('p');
                        if (part.startsWith('*')) { p.className = 'narrative-action'; p.textContent = part; } 
                        else if (part.startsWith('{')) { p.className = 'narrative-psychology'; p.textContent = part; } 
                        else if (part.startsWith('“')) { p.className = 'narrative-speech'; p.textContent = part; } 
                        else { p.className = 'narrative-speech'; p.textContent = `“${part}”`; }
                        bubble.appendChild(p);
                    });
                    narrativeFeed.appendChild(bubble);
                    narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
                }
                return; 
            }

            const lastUnopenedMessage = contact.history.slice().reverse().find(m =>
                m.sender === 'user' && (
                    (m.type === 'red_packet' && !m.content.opened) ||
                    (m.type === 'transfer' && !m.content.completed)
                )
            );

            if (lastUnopenedMessage) {
                const rejectionKeywords = ['不收', '不要', '退回', '还给你', '我不能要', '心意领了'];
                const acceptanceKeywords = ['收下', '收了', '领了', '打开', '谢谢', '我收', '我领'];
                const rejected = rejectionKeywords.some(keyword => conversation.includes(keyword)); // <--- 注意：这里使用 conversation
                
                if (rejected) {
                    if (lastUnopenedMessage.type === 'transfer') {
                        lastUnopenedMessage.content.completed = true;
                        lastUnopenedMessage.content.returned = true;
                        
                        const transferAmount = parseFloat(lastUnopenedMessage.content.amount);
                        if (!isNaN(transferAmount)) {
                            state.myProfile.balance += transferAmount;
                            await addTransaction('income', transferAmount, `来自 ${contact.name} 的转账退款`, contact.id);
                            renderMyProfile();
                            await kokoMemory.put('myProfile', state.myProfile);
                        }
                        await createSystemNotification(`${contact.name} 退还了你的转账`);
                    }
                } else {
                    const accepted = acceptanceKeywords.some(keyword => conversation.includes(keyword)); // <--- 注意：这里使用 conversation
                    if (accepted) {
                        let classToAdd = '';
                        if (lastUnopenedMessage.type === 'red_packet') {
                            lastUnopenedMessage.content.opened = true;
                            classToAdd = 'opened';
                        } else if (lastUnopenedMessage.type === 'transfer') {
                            lastUnopenedMessage.content.completed = true;
                            lastUnopenedMessage.content.returned = false;
                            classToAdd = 'completed';
                        }
                        
                        const messageWrapperEl = document.querySelector(`.message-wrapper[data-message-id='${lastUnopenedMessage.id}']`);
                        if (messageWrapperEl) {
                            const innerMessageEl = messageWrapperEl.querySelector('.message.red-packet, .message.transfer');
                            if (innerMessageEl) {
                                innerMessageEl.classList.add(classToAdd);
                                if (lastUnopenedMessage.type === 'red_packet') {
                                    const headerEl = innerMessageEl.querySelector('.red-packet-header');
                                    if (headerEl) {
                                        headerEl.innerHTML = `<div class="red-packet-icon">🧧</div><div class="red-packet-status">红包已被领取</div>`;
                                    }
                                }
                            }
                        }
                    }
                }
                await kokoMemory.put('contacts', contact);
                await sleep(100);
                await openChat(contact.id);
            }

            if (contact.isNarrativeMode) {
                if (conversation) {
                    await sleep(400 + Math.random() * 400); 
                    await createAndAddMessage({ type: 'text', content: conversation }, 'contact');
                }
            } else {
                let messages = conversation.split('\n').filter(line => line.trim() !== '');
                for (const line of messages) {
                    if (/^\[SYSTEM[:：]/.test(line.trim())) {
                        continue; 
                    }
                    let processed = false;
                    const commandRegex = /\[(sticker|voice|picture|red_packet|transfer|music|spin_wheel):([\s\S]*)\]/;
                    const commandMatch = line.match(commandRegex);
                    const lastWheelMsg = [...contact.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
                    if (lastWheelMsg) {
                        const contactName = contact.name;
                        const validOptions = lastWheelMsg.content.options.map(opt => opt.text);
                        const ultimatePositionalRegex = new RegExp(`(?:${contactName}|我).*?(?:[“"'])?(${validOptions.join('|')})(?:[“"'])?`);
                        const fallbackMatch = line.match(ultimatePositionalRegex);

                        if (fallbackMatch) {
                            const result = fallbackMatch[1];
                            const wheel = lastWheelMsg.content;
                            wheel.results.contact = result.trim();
                            await kokoMemory.put('contacts', contact);

                            const msgIdToUpdate = lastWheelMsg.id;
                            const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
                            if(wrapperToUpdate) {
                                const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
                                if(contactResultRow) {
                                    contactResultRow.innerHTML = `<span class="wheel-player-name">${contact.name}</span> <div class="wheel-player-result">${result.trim()}</div>`;
                                }
                            }
                            continue; 
                        }
                    }

                    if (commandMatch) {
                        processed = true;
                        const command = commandMatch[1];
                        const value = commandMatch[2];
                        switch (command) {
                            case 'spin_wheel': {
                                const currentWheelMsg = [...contact.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
                                if (currentWheelMsg) {
                                    const wheel = currentWheelMsg.content;
                                    const weightedOptions = wheel.options.flatMap(opt => Array(opt.weight).fill(opt.text));
                                    const result = weightedOptions[Math.floor(Math.random() * weightedOptions.length)];
                                    wheel.results.contact = result;
                                    await kokoMemory.put('contacts', contact);
                                    const msgIdToUpdate = currentWheelMsg.id;
                                    const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
                                    if(wrapperToUpdate) {
                                        const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
                                        if(contactResultRow) {
                                            contactResultRow.innerHTML = `<span class="wheel-player-name">${contact.name}</span> <div class="wheel-player-result">${result}</div>`;
                                        }
                                    }
                                }
                                break;
                            }
                            case 'sticker':
                                const emoticon = state.emoticons.find(e => e.name === value.trim());
                                if (emoticon) {
                                    await createAndAddMessage({ type: 'image', url: emoticon.url, isEmoticon: true, emoticonName: emoticon.name }, 'contact');
                                } else {
                                    await createAndAddMessage({ type: 'text', content: `[发送表情失败: ${value}]` }, 'contact');
                                }
                                break;
                            case 'voice':
                                const duration = Math.max(1, Math.round(value.length / 4));
                                await createAndAddMessage({ type: 'voice', content: { text: value, duration: duration } }, 'contact');
                                break;
                            case 'picture':
                                await createAndAddMessage({ type: 'picture_description', content: { description: value } }, 'contact');
                                break;
                            case 'red_packet': {
                                const parts = value.split(/[，,]/);
                                const blessing = parts[0] ? parts[0].trim() : "恭喜发财！";
                                const amount = parseFloat(parts[1]) || 0;
                                if (amount > 0) {
                                    await createAndAddMessage({ type: 'red_packet', content: { amount: amount.toFixed(2), blessing: blessing, opened: false } }, 'contact');
                                }
                                break;
                            }
                            case 'transfer': {
                                const transferAmount = parseFloat(value);
                                if (transferAmount > 0) {
                                     await createAndAddMessage({ type: 'transfer', content: { amount: transferAmount.toFixed(2), completed: false, returned: false } }, 'contact');
                                }
                                break;
                            }
                            case 'music': {
                                const lastComma = value.lastIndexOf('，') > -1 ? '，' : ',';
                                const lastCommaIndex = value.lastIndexOf(lastComma);
                                if (lastCommaIndex === -1) break; 
                                const url = value.substring(lastCommaIndex + 1).trim();

                                const secondToLastCommaIndex = value.lastIndexOf(lastComma, lastCommaIndex - 1);
                                if (secondToLastCommaIndex === -1) break;
                                
                                const artist = value.substring(secondToLastCommaIndex + 1, lastCommaIndex).trim();
                                const title = value.substring(0, secondToLastCommaIndex).trim();

                                if (url.startsWith('http') && title) {
                                    await createAndAddMessage({ 
                                        type: 'music_share', 
                                        content: { title, artist, url }
                                    }, 'contact');
                                }
                                break;
                            }
                        }
                    }

                    if (!processed) {
    const trimmedLine = line.trim();
    if (trimmedLine.startsWith('<') && trimmedLine.endsWith('>')) {
        // ✨ 已修正
        await createAndAddMessage({ type: 'html', content: line }, contact.id);
    } else {
        // ✨ 已修正
        await createAndAddMessage({ type: 'text', content: line }, contact.id);
    }
}
                    await sleep(400 + Math.random() * 400);
                }
            }
        }
        
        // ✨✨✨ 用这个最终的、真正可定制的版本，替换掉 generateRandomTrendingTopicsAI 函数 ✨✨✨
        async function generateRandomTrendingTopicsAI() {
            // 1. 智能读取你当前设置的任何世界观和风格
            const { worldBookIds, styleDescription } = state.forumSettings;
            
            let worldBookPrompt = '';
            if (worldBookIds.length > 0) {
                const booksContent = worldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                }).join('\n');
                worldBookPrompt = `\n[全局世界观设定 (来自世界书)]\n${booksContent}\n`;
            }

            let stylePrompt = '';
            if (styleDescription) {
                stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"\n`;
            }

            // 2. 生成一份通用的、引导AI思考的“剧本”，而不是规定死内容的剧本
            const prompt = `[SYSTEM] 你的任务是作为一名创意总监，为你的论坛生成8个符合其独特背景的【热搜事件】。

**[背景资料]**
你必须严格基于以下提供的“世界观”和“风格”来构思词条，确保所有内容都符合这个世界的设定。
${worldBookPrompt || "[注意：当前未提供详细世界观设定。]\n"}
${stylePrompt || "[注意：当前未提供详细风格描述。]\n"}

**[任务要求]**
1.  仔细阅读并深刻理解上方提供的“世界观”和“风格描述”。
2.  基于这个独特的背景，构思出8个最可能在这个世界里引起广泛讨论的热门【具体事件】。
3.  【绝对禁止】生成任何与所提供背景无关的词条，特别是现实世界的现代话题。

**[输出格式]**
对于每一个事件，你必须严格、完整地使用以下格式，并重复8次，每次之间用 "---" 分隔：
TITLE: [这里是热搜标题，通常用##包裹，例如：#千金假死#]
DESCRIPTION: [这里是对该事件的一句话（40字左右）新闻描述，解释发生了什么]
---
`;
            try {
                const response = await generateAiResponse(null, [], prompt, false, 'square');
                // ▼▼▼ 把这段新代码粘贴到原来的位置 ▼▼▼
const newTrendingTopics = [];
const topicRegex = /TITLE:\s*(.*?)\s*\nDESCRIPTION:\s*(.*?)(?:\n---|$)/gs;
let match;

while ((match = topicRegex.exec(response)) !== null) {
    const title = match[1].trim();
    const description = match[2].trim();
    if (title && description) {
        newTrendingTopics.push({ title, description });
    }
}

if (newTrendingTopics.length > 0) {
    state.trendingTopics = newTrendingTopics.slice(0, 8).map((topic, index) => ({
        id: `topic_${Date.now()}_${index}`,
        title: topic.title,
        description: topic.description, // 存储description字段
        heat: Math.floor(Math.random() * 500) + 50,
        tag: index < 2 ? '热' : (index < 4 ? '新' : null)
    })).sort((a, b) => b.heat - a.heat);

    await kokoMemory.clear('trendingTopics');
    await kokoMemory.bulkPut('trendingTopics', state.trendingTopics);
}
// ▲▲▲ 粘贴到这里结束 ▲▲▲

            } catch(e) {
                console.error("AI热搜生成失败:", e);
                throw new Error(`AI热搜生成失败: ${e.message}`);
            }
        }

        async function generatePostsForRecommendedTab(count = 5) {
            const newPosts = await generatePostsBatch(count, state.trendingTopics);
            await generateInitialCommentsForPosts(newPosts);
            state.posts.unshift(...newPosts);
            if (state.posts.length > 200) state.posts = state.posts.slice(0, 200);
            await kokoMemory.clear('posts');
            await kokoMemory.bulkPut('posts', state.posts);
            state.hasNewPosts = true;
            updateNotificationDots();
        }

        // ✨✨✨ 用这个最终优化版，完整替换掉旧的 generatePostsBatch 函数 ✨✨✨
        async function generatePostsBatch(count, topics = []) {
            const category = state.activeFeedSubTab;
            const categoryPrompts = {
                daily: "关于日常生活的趣事、吐槽、嗑cp或避雷经历",
                food: "关于美食的分享、探店、吐槽或避雷指南",
                gossip: "关于人际关系或娱乐圈的八卦讨论或互撕",
                horror: "恐怖小故事或灵异经历",
            };
            
            const { personaId, worldBookIds, styleDescription } = state.forumSettings;
            
            let personaPrompt = '';
            if (personaId) {
                const persona = state.userPersonaPresets.find(p => p.id === personaId);
                if (persona) {
                    personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
                }
            }

            let worldBookPrompt = '';
            if (worldBookIds.length > 0) {
                const booksContent = worldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                }).join('\n');
                worldBookPrompt = `\n[全局世界观设定 (来自世界书)]\n${booksContent}\n所有生成的帖子内容都必须严格符合上述世界观设定。`;
            }

            let stylePrompt = '';
            if (styleDescription) {
                stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
            }

            // ▼▼▼ 这是修改后的新代码 ▼▼▼

// 1. 先从所有联系人中，根据我们设置的“白名单”筛选出被允许的角色
const allowedContacts = state.contacts.filter(c => 
    !c.isGroup && 
    state.forumSettings.allowedPosterIds && 
    state.forumSettings.allowedPosterIds.includes(c.id)
);

// 2. 然后，只用这个被允许的列表去生成给AI看的“可选作者列表”
const authorsWithMemoryPrompt = allowedContacts.map(c => {
    let recentChatHistory = '(最近没有私聊)';
    if (c.history && c.history.length > 0) {
        recentChatHistory = c.history
            .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
            .slice(-8)
            .map(msg => `${msg.sender === 'user' ? state.myProfile.name : c.name}: ${msg.content}`)
            .join('\n    ');
    }
    return `- ${c.name} (人设: ${c.persona.replace(/\n/g, ' ')})\n  - [与“${state.myProfile.name}”的近期私聊参考]:\n    \`\`\`\n    ${recentChatHistory}\n    \`\`\``;
}).join('\n');

// ▲▲▲ 替换结束 ▲▲▲

            // 这是叙事转线上2.HTML里的【正确】代码，请用它替换上面的代码块
let topicsForPrompt = '';
if (topics && topics.length > 0) {
    topicsForPrompt = `
[近期热搜事件参考]
当前世界上正在发生以下主要事件，你的帖子内容应该与这些事件有所关联，让世界感觉更真实。
${topics.map(t => `- ${t.title}: ${t.description}`).join('\n')}

[重要指令：话题标签]
在生成帖子内容时，你有大约30%的几率，需要从上面的“热搜事件参考”中选择一个最相关的话题，并以“#话题标题#”的形式，自然地插入到你的帖子正文的末尾。
`;
}
            
            // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
            // ▼▼▼▼▼▼▼▼▼▼▼▼▼ 核心修改在这里 ▼▼▼▼▼▼▼▼▼▼▼▼▼
            const postsPrompt = `[SYSTEM] 你的任务是扮演一个内容生成引擎。
        ${stylePrompt}
        ${worldBookPrompt}
        ${personaPrompt}

        [背景设定]
        - 论坛上有一个核心用户叫“${state.myProfile.name}”，TA的公开签名是：“${state.myProfile.signature}”。
        ${topicsForPrompt} 

        [任务]
        生成 ${count} 条关于“${categoryPrompts[category]}”的社交动态。

        **[内容多样性指令 (非常重要)]**
        为了让论坛感觉更真实、更有活力，你生成的帖子内容应该具有多样性。
        - **减少关联性**: 大部分帖子内容应该像是这个世界里独立发生的事件，与核心用户“${state.myProfile.name}”的个人人设、状态或最近的私聊没有直接关系。
        - **创造独立故事线**: 鼓励创造一些与用户完全无关的“路人甲”之间的互动和小故事。让他们有自己的生活和烦恼。
        - **只有少数内容可以有关联**: 只有一小部分（例如，生成的帖子中不超过1-2条）内容可以与“${state.myProfile.name}”或其熟人（char）的私聊内容有微弱、间接的关联。不要让整个论坛都围绕着用户转！
        
        **[绝对核心规则]**
        在本次生成的 ${count} 条动态中，你【必须确保】至少有 3 条是由你原创的、完全不存在于下方“[可选的帖子作者列表]”中的“路人甲”发布的。这是强制性、不可违反的指令。

        **[次要规则]**
        1. 剩下的动态，你可以从下方的作者列表中选择作者。
        2. 你在为某个“可选列表”中的角色创作帖子时，可以参考他/她附带的“[近期私聊参考]”，帖子内容**可以**作为这些私聊的自然延伸或有感而发，但这**不是强制要求**。请优先考虑上方的[内容多样性指令]。
        3. 对于同一个“可选列表”中的作者，在本次任务中最多只能使用一次。

        [绝对禁止]
        你生成的帖子的作者（AUTHOR）绝对不能是核心用户 “${state.myProfile.name}”。

        [可选的帖子作者列表及他们的短期记忆]
        ${authorsWithMemoryPrompt || "- (无联系人信息)"}

        [输出格式] 必须严格遵守:
        POST_START
        AUTHOR: [作者名]
        IS_CONTACT: [true或者false]
        CONTENT: [动态的具体内容]
        POST_END`;
            // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
            // ▲▲▲▲▲▲▲▲▲▲▲▲▲ 核心修改在这里 ▲▲▲▲▲▲▲▲▲▲▲▲▲

            const rawPostsResponse = await generateAiResponse(null, [], postsPrompt, false, 'square');
            const postRegex = /POST_START\s*AUTHOR:\s*(?<author_name>.*?)\s*IS_CONTACT:\s*(?<is_existing_contact>true|false)\s*CONTENT:\s*(?<content>[\s\S]*?)\s*POST_END/g;
            const postMatches = Array.from(rawPostsResponse.matchAll(postRegex));

            if (postMatches.length === 0) throw new Error(`AI未能按格式要求生成任何动态。`);

            let newPosts = [];
            for (const match of postMatches) {
                const { author_name, is_existing_contact, content } = match.groups;
                let authorProfile;
                if (is_existing_contact.trim().toLowerCase() === 'true') {
                    const contact = state.contacts.find(c => c.name === author_name.trim());
                    if (contact) {
                        authorProfile = { id: contact.id, name: contact.name, avatar: contact.avatar, signature: contact.signature };
                    }
                }
                if (!authorProfile) {
                    authorProfile = {
                        id: `stranger_${Date.now()}_${Math.random()}`, name: author_name.trim(),
                        avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)],
                        signature: ''
                    };
                }
                newPosts.push({
                    id: `post_${Date.now()}_${Math.random()}`, author: authorProfile, content: content.trim(),
                    category: category, timestamp: Date.now(),
                    likes: [], comments: [], reposts: 0,
                    archiveId: state.activeForumArchiveId // <-- 【新增】给新帖子打上当前存档的ID
                });
            }
            return newPosts;
        }

        async function processAiGeneratedComments(rawCommentsResponse, posts, commentRegex) {
            const commentMatches = Array.from(rawCommentsResponse.matchAll(commentRegex));
            const processedComments = [];

            for (const match of commentMatches) {
                const { post_index, commenter_name, reply_to, comment_content } = match.groups;
                const postIndex = parseInt(post_index, 10);

                if (postIndex >= 0 && postIndex < posts.length) {
                    const post = posts[postIndex];
                    let finalCommentContent = comment_content.trim();

                    // 检查是否包含抢红包指令
                    if (finalCommentContent.includes('[抢红包]')) {
                        if (post.redPacket) {
                            if (!post.redPacket.claimers) post.redPacket.claimers = [];
                            
                            const commenterId = `stranger_commenter_${Date.now()}_${Math.random()}`;
                            const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterId); // 理论上新生成的不会重复
                            const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                            if (!isDepleted && !hasClaimed) {
                                // 分配红包金额
                                const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                                const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                                
                                let amount = 0;
                                if (remainingCount > 1) {
                                    const avg = remainingAmount / remainingCount;
                                    amount = Math.random() * avg * 1.8; // 增加随机性
                                    amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                                } else {
                                    amount = remainingAmount;
                                }
                                amount = Math.max(0.01, parseFloat(amount.toFixed(2)));

                                post.redPacket.claimers.push({ userId: commenterId, amount: amount });
                                
                                // 替换指令为实际显示内容
                                finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                            } else {
                                finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                            }
                        } else {
                            // 帖子里没红包，但AI以为有
                            finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                        }
                    }
                    
                    processedComments.push({
                        postIndex: postIndex,
                        comment: {
                            id: `comment_${Date.now()}_${Math.random()}`,
                            author: {
                                id: `stranger_commenter_${Date.now()}_${Math.random()}`, name: commenter_name.trim(),
                                avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                            },
                            content: finalCommentContent,
                            timestamp: post.timestamp + 10000 + (processedComments.length * 1000),
                            replyTo: (reply_to.trim().toLowerCase() === 'null' || reply_to.trim() === '') ? null : reply_to.trim(),
                        }
                    });
                }
            }
            return processedComments;
        }
        
        // ✨✨✨ 用这个新版本，完整替换掉旧的 generateInitialCommentsForPosts 函数 ✨✨✨
        async function generateInitialCommentsForPosts(posts) {
             if (!posts || posts.length === 0) return;
             
            const { personaId, worldBookIds, styleDescription } = state.forumSettings;
            let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
            if (personaId) {
                const persona = state.userPersonaPresets.find(p => p.id === personaId);
                if (persona) personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
            }
            if (worldBookIds.length > 0) {
                const booksContent = worldBookIds.map(id => {
                    const book = state.worldBooks.find(b => b.id === id);
                    return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
                }).join('\n');
                worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
            }
            if (styleDescription) {
                stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
            }

             const postsForCommentPrompt = posts.map((post, index) => {
                let postInfo = `[POST ${index}] 作者: ${post.author.name}\n内容: ${post.content}`;
                if (post.redPacket) {
                    postInfo += `\n[重要信息：此帖附带一个“${post.redPacket.blessing}”的红包，总额${post.redPacket.amount}元，共${post.redPacket.count}个。]`;
                }
                return postInfo;
            }).join('\n\n');

            const commentsPrompt = `[SYSTEM] 你的任务是扮演一个“吃瓜群众”评论生成引擎，为下面的帖子生成有互动感的评论区。
        ${stylePrompt}
        ${worldBookPrompt}
        ${personaPrompt}
        ---
        ${postsForCommentPrompt}
        ---
        任务: 为以上帖子生成 2 到 4 条随机的、真实的、简短的评论。
        重要：为了让评论区更真实，请让评论之间有互动，即一些评论是回复另一条评论的。

        [红包互动指南]
        如果一个帖子带有[重要信息：此帖附带...红包]，你生成的评论中，应该有一部分人对此作出反应。为了模拟抢红包的动作，请在他们的评论内容中加入特殊指令 "[抢红包]"。

        **[绝对禁止]**
        **你生成的评论作者（COMMENTER）的名字绝对不能是核心用户“${state.myProfile.name}”。**
        **评论作者也不能是正在被评论的帖子的作者本人。**

        对于每一条评论，必须严格、完整地使用以下格式：
        COMMENT_START
        INDEX: [评论指向的帖子编号]
        COMMENTER: [随机想一个真实的中文网名]
        REPLY_TO: [被回复的评论者名字，如果没有则为null]
        COMMENT: [评论内容，可能包含[抢红包]]
        COMMENT_END`;

            const rawCommentsResponse = await generateAiResponse(null, [], commentsPrompt, false, 'square');
            const commentRegex = /COMMENT_START\s*INDEX:\s*(?<post_index>\d+)\s*COMMENTER:\s*(?<commenter_name>.*?)\s*REPLY_TO:\s*(?<reply_to>.*?)\s*COMMENT:\s*(?<comment_content>[\s\S]*?)\s*COMMENT_END/g;
            
            const processedComments = await processAiGeneratedComments(rawCommentsResponse, posts, commentRegex);

            processedComments.forEach(({ postIndex, comment }) => {
                posts[postIndex].comments.push(comment);
            });
            
            posts.forEach(p => p.comments.sort((a,b) => a.timestamp - b.timestamp));
        }
        
        // ✨✨✨ 完整替换 ✨✨✨
async function generateMoreCommentsForPost(post) {
    // ✨ 1. 获取并构建论坛设置的 Prompt 片段
    const { personaId, worldBookIds, styleDescription } = state.forumSettings;
    let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
    if (personaId) {
        const persona = state.userPersonaPresets.find(p => p.id === personaId);
        if (persona) personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
    }
    if (worldBookIds.length > 0) {
        const booksContent = worldBookIds.map(id => {
            const book = state.worldBooks.find(b => b.id === id);
            return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
        }).join('\n');
        worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
    }
    if (styleDescription) {
        stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
    }

    const userComments = post.comments.filter(c => c.author.id === 'myProfile');
    const lastUserComment = userComments.length > 0 ? userComments[userComments.length - 1] : null;

    let prompt;
    if (lastUserComment) {
        // ✨ 2. 将设置片段注入到 Prompt 中
        prompt = `[SYSTEM] 你的任务是扮演一个“吃瓜群众”，为一个帖子生成有互动感的评论。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}
用户“${lastUserComment.author.name}”刚刚在评论区发表了看法，请你生成2-3条新的、围绕TA的评论展开的讨论。

[帖子信息]
作者: "${post.author.name}"
内容: "${post.content}"

[用户评论参考]
“${lastUserComment.author.name}”说: "${lastUserComment.content}"

[任务]
生成2-3条新的评论，可以是对用户观点的赞同、反驳或者提出新问题。让讨论看起来更真实。
请严格使用以下格式，每条评论一行：
COMMENTER: [评论者名字] | REPLY_TO: [被回复者名字, 可以是${lastUserComment.author.name}或其他评论者] | COMMENT: [评论内容]`;
    } else {
        const existingComments = post.comments.map(c => `${c.author.name}: ${c.content}`).join('\n');
        // ✨ 2. 将设置片段注入到 Prompt 中
        prompt = `[SYSTEM] 你的任务是扮演一个“吃瓜群众”，为一个帖子添加2-3条新的、有互动感的评论，让评论区更热闹。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[帖子信息]
作者: "${post.author.name}"
内容: "${post.content}"

[现有评论区]
${existingComments || "(还没有评论)"}

[任务]
生成2-3条新的评论，可以是回复某个人，也可以是发表新看法。
请严格使用以下格式，每条评论一行：
COMMENTER: [评论者名字] | REPLY_TO: [被回复者名字, 如果没有则为null] | COMMENT: [评论内容]`;
    }

    const rawResponse = await generateAiResponse(null, [], prompt, false, 'square');
    const commentRegex = /COMMENTER:\s*(?<commenter_name>.*?)\s*\|\s*REPLY_TO:\s*(?<reply_to>.*?)\s*\|\s*COMMENT:\s*(?<comment_content>[\s\S]*?)(?:\n|$)/g;
    const matches = Array.from(rawResponse.matchAll(commentRegex)); 

    if (matches.length > 0) {
         for (const match of matches) {
            if (!match.groups) continue;
            const { commenter_name, reply_to, comment_content } = match.groups;
            let commenter = state.contacts.find(c => c.name === commenter_name.trim());
            if (!commenter) {
                 commenter = {
                    id: `stranger_commenter_${Date.now()}_${Math.random()}`, name: commenter_name.trim(),
                    avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                };
            }
             post.comments.push({
                id: `comment_${Date.now()}_${Math.random()}`,
                author: commenter,
                content: comment_content.trim(),
                timestamp: Date.now(),
                replyTo: (reply_to.trim().toLowerCase() === 'null' || reply_to.trim() === '') ? null : reply_to.trim(),
            });
        }
        await kokoMemory.put('posts', post);
    }
}
// ✨✨✨ 这是你需要粘贴的【辅助函数】 ✨✨✨
const formatContactInfo = (contact, role, userComment) => {
    const userPersona = contact.userPersona ? `你（${contact.name}）和用户“${userComment.author.name}”的私人关系是：“${contact.userPersona}”。` : `你（${contact.name}）和用户“${userComment.author.name}”是普通网友。`;
    let recentChatHistory = '(暂无私聊记录)';
    if (contact && contact.history && contact.history.length > 0) {
        recentChatHistory = contact.history
            .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
            .slice(-35)
            .map(msg => `${msg.sender === 'user' ? userComment.author.name : contact.name}: ${msg.content}`)
            .join('\n');
    }
    
    // 注意：这个函数现在会返回一个对象，而不是直接修改外部变量
    return {
        figureInfo: `\n- ${role}: "${contact.name}" (人设: "${contact.persona || '普通人'}")`,
        relationshipInfo: `\n[${role} “${contact.name}” 的详细资料]\n- ${userPersona}\n- [近期私聊参考]:\n\`\`\`\n${recentChatHistory}\n\`\`\``
    };
};        
// ✨✨✨ 这是最终、完整、正确的版本，请直接复制使用 ✨✨✨
async function triggerAiCommentDiscussion(post, userComment) {
    showFeedStatus('正在生成AI回复...');
    try {
        // 1. 获取并构建论坛设置的 Prompt 片段
        const { personaId, worldBookIds, styleDescription } = state.forumSettings;
        let personaPrompt = '', worldBookPrompt = '', stylePrompt = '';
        if (personaId) {
            const persona = state.userPersonaPresets.find(p => p.id === personaId);
            if (persona) personaPrompt = `\n[核心用户信息]\n- 核心用户名为: "${state.myProfile.name}"\n- 他/她当前的身份面具是: "${persona.description}"`;
        }
        if (worldBookIds.length > 0) {
            const booksContent = worldBookIds.map(id => {
                const book = state.worldBooks.find(b => b.id === id);
                return book ? `--- (世界书: ${book.name}) ---\n${book.content}` : '';
            }).join('\n');
            worldBookPrompt = `\n[全局世界观设定]\n${booksContent}\n所有生成的评论都必须严格符合上述世界观设定。`;
        }
        if (styleDescription) {
            stylePrompt = `\n[论坛整体风格指令]\n你必须严格遵循以下风格来生成所有内容：\n"${styleDescription}"`;
        }

        // 2. 识别被回复的角色和可能的互动角色
        let mentionedContact = null;
        const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
        const mentionMatch = mentionRegex.exec(userComment.content);
        if (mentionMatch) {
            const mentionedName = mentionMatch[1];
            mentionedContact = state.contacts.find(c => c.name === mentionedName);
        }

        let mandatoryResponder = mentionedContact;
        if (!mandatoryResponder && userComment.replyTo) {
            const originalComment = post.comments.find(c => c.author.name === userComment.replyTo);
            if (originalComment) {
                const repliedToContact = state.contacts.find(c => c.id === originalComment.author.id);
                if (repliedToContact && repliedToContact.id !== 'myProfile') {
                    mandatoryResponder = repliedToContact;
                }
            }
        }
        
        let possibleResponders = state.contacts.filter(c => c.id !== userComment.author.id && !c.isGroup);
        if (mandatoryResponder) {
            possibleResponders = possibleResponders.filter(c => c.id !== mandatoryResponder.id);
        }

        let guestResponder = null;
        if (possibleResponders.length > 0 && Math.random() < 0.3) {
            guestResponder = possibleResponders[Math.floor(Math.random() * possibleResponders.length)];
        }

        // 3. 构建角色档案和关系信息
        let notableFiguresForPrompt = `\n[本楼出场人物信息]\n- 主帖作者: "${post.author.name}" (人设: "${post.author.persona || '普通人'}")`;
        let relationshipInfoForPrompt = '';
        
        if (mandatoryResponder) {
            const formatted = formatContactInfo(mandatoryResponder, '必出场角色 (被@或被回复)', userComment);
            notableFiguresForPrompt += formatted.figureInfo;
            relationshipInfoForPrompt += formatted.relationshipInfo;
        }
        if (guestResponder) {
            const formatted = formatContactInfo(guestResponder, '可能客串的熟人', userComment);
            notableFiguresForPrompt += formatted.figureInfo;
            relationshipInfoForPrompt += formatted.relationshipInfo;
        }
        
        if (!relationshipInfoForPrompt) {
            relationshipInfoForPrompt = "[可参与讨论的角色信息]\n---（本次没有特定的熟人需要出场）---\n";
        } else {
            relationshipInfoForPrompt = "[可参与讨论的角色信息]\n---" + relationshipInfoForPrompt + "\n---";
        }

        const conversationHistory = post.comments.filter(c => c.author.id === userComment.author.id || (mandatoryResponder && c.author.id === mandatoryResponder.id) || (guestResponder && c.author.id === guestResponder.id)).sort((a, b) => a.timestamp - b.timestamp).slice(-10);
        const conversationHistoryForPrompt = conversationHistory.map(c => `- ${c.author.name}: ${c.content}`).join('\n');
        
        // 4. ✨✨✨ 关键修正点：构建包含用户评论内容的【核心情景】 ✨✨✨
        let mainScenarioPrompt = ''; 
        if (userComment.replyTo) {
            const originalComment = post.comments.find(c => c.author.name === userComment.replyTo);
            if (originalComment) {
                mainScenarioPrompt = `\n[核心互动情景]\n在回复 "${originalComment.author.name}" 的评论 (“${originalComment.content}”) 时，用户 "${userComment.author.name}" 说道：“${userComment.content}”。\n请你生成的讨论必须围绕用户的这条新评论展开。`;
            }
        } else {
            mainScenarioPrompt = `\n[核心互动情景]\n用户 "${userComment.author.name}" 刚刚发表了一条新评论：“${userComment.content}”。\n请你生成的讨论必须围绕用户的这条新评论展开。`;
        }

        let postInfoForPrompt = `- 帖子作者: "${post.author.name}"\n- 帖子内容: "${post.content}"`;
        if (post.redPacket) {
            const remainingPackets = post.redPacket.count - (post.redPacket.claimers ? post.redPacket.claimers.length : 0);
            postInfoForPrompt += `\n- [红包信息]：此帖附带红包，祝福语“${post.redPacket.blessing}”，目前剩余 ${remainingPackets} 个。`;
        }

        // 5. 组合成最终的 Prompt
        const prompt = `[SYSTEM] 你是社交媒体讨论模拟器。
${stylePrompt}
${worldBookPrompt}
${personaPrompt}

[主帖子信息]
${postInfoForPrompt}
${mainScenarioPrompt}
[最近的评论对话历史]
${conversationHistoryForPrompt}

${relationshipInfoForPrompt}

[重要规则：红包互动]
如果帖子有[红包信息]，你的角色在回复时可以尝试抢红包。若要模拟抢红包，请在评论内容中加入特殊指令 "[抢红包]"。

[重要规则：路人甲的反应逻辑]
${notableFiguresForPrompt}
当你要扮演一个原创的“路人甲”进行评论时，你必须优先检查上方“本楼出场人物信息”列表里所有角色的人设。如果他们中有人设包含“明星”、“名人”等具有公众辨识度的身份，你扮演的“路人甲”在评论时，【有较高概率】应该体现出已经认识或认出了TA。

[你的任务 - 重要！]
1.  **优先回复**: 如果存在“[必出场角色]”，你的第一条或第二条回复**必须**由他/她发出。
2.  **选择性客串**: 如果存在“[可能客串的熟人]”，**仅当**你觉得他/她的人设符合其人设且能让讨论更有趣时，才让他/她加入。这是**可选的**。
3.  **营造真实感**: 剩下的回复名额，请**务必优先使用你原创的、符合当下场景的“路人甲”**来填充。
4.  **严格遵守格式**: 所有回复都必须严格遵守 \`COMMENTER: [名字] | REPLY_TO: [回复对象] | COMMENT: [内容]\` 格式。

[绝对禁止]
在你的任何回复中，【绝对不能】使用“${userComment.author.name}”作为COMMENTER的名字。`;

        // 6. 调用AI并处理后续（这部分逻辑不变）
        const rawResponse = await generateAiResponse(null, [], prompt, false, 'square');
        const commentRegex = /COMMENTER:\s*(?<commenter_name>.*?)\s*\|\s*REPLY_TO:\s*(?<reply_to>.*?)\s*\|\s*COMMENT:\s*(?<comment_content>[\s\S]*?)(?:\n|$)/g;
        const matches = Array.from(rawResponse.matchAll(commentRegex));

        if (matches.length > 0) {
             for (const match of matches) {
                if (!match.groups) continue;
                const {
                    commenter_name,
                    reply_to,
                    comment_content
                } = match.groups;

                let commenterProfile = state.contacts.find(c => c.name === commenter_name.trim());
                if (!commenterProfile) {
                    commenterProfile = {
                        id: `stranger_commenter_${Date.now()}_${Math.random()}`,
                        name: commenter_name.trim(),
                        avatar: STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]
                    };
                }
                
                let finalCommentContent = comment_content.trim();
                if (finalCommentContent.includes('[抢红包]')) {
                    if (post.redPacket) {
                         if (!post.redPacket.claimers) post.redPacket.claimers = [];
                         const hasClaimed = post.redPacket.claimers.some(c => c.userId === commenterProfile.id);
                         const isDepleted = post.redPacket.claimers.length >= post.redPacket.count;

                         if (!isDepleted && !hasClaimed) {
                            const remainingCount = post.redPacket.count - post.redPacket.claimers.length;
                            const remainingAmount = post.redPacket.amount - post.redPacket.claimers.reduce((sum, c) => sum + c.amount, 0);
                            let amount = 0;
                            if (remainingCount > 1) {
                                const avg = remainingAmount / remainingCount;
                                amount = Math.random() * avg * 1.8;
                                amount = Math.min(remainingAmount - (remainingCount-1)*0.01, amount);
                            } else {
                                amount = remainingAmount;
                            }
                            amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                            post.redPacket.claimers.push({ userId: commenterProfile.id, amount: amount });
                            finalCommentContent = finalCommentContent.replace('[抢红包]', `🧧 领取了红包 (¥${amount.toFixed(2)})`);
                         } else {
                            finalCommentContent = finalCommentContent.replace('[抢红包]', '手慢了，红包派完了！');
                         }
                    } else {
                        finalCommentContent = finalCommentContent.replace('[抢红包]', ''); 
                    }
                }
                
                 post.comments.push({
                    id: `comment_${Date.now()}_${Math.random()}`,
                    author: commenterProfile,
                    content: finalCommentContent,
                    timestamp: Date.now() + matches.indexOf(match) * 100,
                    replyTo: reply_to.trim(),
                });
            }
            await kokoMemory.put('posts', post);
            if (state.activePostId === post.id) {
                await renderPostDetail();
            }
        }
    } catch (e) {
        console.error("生成AI评论讨论失败:", e);
    } finally {
        hideFeedStatus();
    }
}
        
        // --- MODIFIED V7.0: 增加分享音乐选项 ---
        // ▼▼▼ 新版本：renderAttachmentMenu ▼▼▼
function renderAttachmentMenu() {
    const menu = document.getElementById('attachment-menu');
    menu.innerHTML = `
        <div class="attachment-menu-item" data-action="send-picture">
            <div class="icon-wrapper"><i class="fas fa-image"></i></div>
            <div class="label">图片</div>
        </div>
        <div class="attachment-menu-item" data-action="send-voice">
            <div class="icon-wrapper"><i class="fas fa-microphone"></i></div>
            <div class="label">语音</div>
        </div>
        <div class="attachment-menu-item" data-action="send-red-packet">
            <div class="icon-wrapper"><i class="fas fa-wallet"></i></div>
            <div class="label">红包</div>
        </div>
        <div class="attachment-menu-item" data-action="send-transfer">
            <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
            <div class="label">转账</div>
        </div>
        <div class="attachment-menu-item" data-action="share-music">
            <div class="icon-wrapper"><i class="fas fa-music"></i></div>
            <div class="label">音乐</div>
        </div>
        <div class="attachment-menu-item" data-action="game-wheel"> <div class="icon-wrapper"><i class="fas fa-bullseye"></i></div> <div class="label">转盘游戏</div> 
        </div>
        <div class="attachment-menu-item" data-action="start-video-call">
            <div class="icon-wrapper"><i class="fas fa-video"></i></div>
            <div class="label">视频通话</div>
        </div>
    `;
}
        // ↓↓↓ 把这个全新的函数整个粘贴进去 ↓↓↓
function addWheelOptionInput(text = '', weight = 1) {
    const container = document.getElementById('wheel-options-container');
    const newItem = document.createElement('div');
    newItem.className = 'wheel-option-item';
    newItem.innerHTML = `
        <input type="text" class="contact-form-input wheel-option-text" value="${text}" placeholder="选项内容">
        <input type="number" class="contact-form-input wheel-option-weight" value="${weight}" min="1" title="权重(份数)">
        <button class="delete-option-btn">&times;</button>
    `;
    container.appendChild(newItem);
    newItem.querySelector('.delete-option-btn').addEventListener('click', () => {
        // 至少保留2个选项
        if (container.children.length > 2) {
            newItem.remove();
        } else {
            alert('转盘至少需要2个选项哦！');
        }
    });
}
// ↑↑↑ 新增代码结束 ↑↑↑

        // --- MODIFIED V7.0: 增加处理分享音乐的逻辑 ---
        function handleAttachmentAction(action) {
            const menu = document.getElementById('attachment-menu');
            menu.classList.remove('active');

            const addOneTimeListener = (buttonId, callback) => {
                const oldBtn = document.getElementById(buttonId);
                const newBtn = oldBtn.cloneNode(true);
                oldBtn.parentNode.replaceChild(newBtn, oldBtn);
                newBtn.addEventListener('click', callback);
            };

            switch(action) {
                // 在 handleAttachmentAction 函数的 switch 语句中
case 'send-location': { // 假设你给附件菜单里的位置按钮加了 data-action="send-location"
    const contact = state.contacts.find(c => c.id === state.activeChatId);

    // 【核心检查】
    if (!contact || !contact.mapId) {
        alert('要发送位置，请先在“更多信息”中为该联系人关联一张地图。');
        return;
    }

    // 打开地点选择器
    openLocationPicker(contact.mapId);
    break;
}
case 'upload-image': document.getElementById('image-upload-input').click(); break;
                case 'send-picture': {
                    const modal = document.getElementById('send-picture-modal');
                    const descriptionInput = document.getElementById('send-picture-description-input');
                    descriptionInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-picture-btn', async () => {
                        const description = descriptionInput.value.trim();
                        if (description) {
                            await createAndAddMessage({ type: 'picture_description', content: { description } });
                            modal.style.display = 'none';
                        }
                    });
                    break;
                }
                // 在 handleAttachmentAction 函数中...

// ... 其他 case ...
case 'send-group-transfer': {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group || !group.isGroup) break;

    const modal = document.getElementById('group-transfer-recipient-picker-modal');
    const recipientListEl = document.getElementById('group-transfer-recipient-list');
    const amountInput = document.getElementById('group-transfer-amount-input');
    amountInput.value = '';
    recipientListEl.innerHTML = '';
    
    // 动态加载群成员 (排除自己)
    group.members.forEach(memberId => {
        if (memberId === 'myProfile') return;
        const member = state.contacts.find(c => c.id === memberId);
        if (member) {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            // 使用 radio button 确保只能选一个
            item.innerHTML = `
                <input type="radio" id="recipient-radio-${member.id}" name="group-recipient" value="${member.id}">
                <label for="recipient-radio-${member.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${member.avatar}" alt="${member.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${member.name}</span>
                </label>
            `;
            recipientListEl.appendChild(item);
        }
    });

    modal.style.display = 'flex';

    document.getElementById('close-group-transfer-picker-modal').addEventListener('click', () => {
        modal.style.display = 'none';
    }, { once: true });

    addOneTimeListener('confirm-group-transfer-btn', async () => {
        const selectedRadio = document.querySelector('input[name="group-recipient"]:checked');
        if (!selectedRadio) {
            return alert('请选择一个收款人！');
        }
        const recipientId = selectedRadio.value;
        const amount = parseFloat(amountInput.value);

        if (isNaN(amount) || amount <= 0) {
            return alert('请输入有效的转账金额！');
        }
        if (state.myProfile.balance < amount) {
            return alert('钱包余额不足！');
        }
        
        state.myProfile.balance -= amount;
        const recipient = state.contacts.find(c => c.id === recipientId);
        await addTransaction('expense', amount, `在群聊中转账给 ${recipient.name}`, group.id);
        
        // 创建一个新的转账消息，带有收款人信息
        await createAndAddMessage({
            type: 'transfer',
            content: {
                amount: amount.toFixed(2),
                completed: false,
                returned: false,
                recipientId: recipientId // 关键信息！
            }
        });

        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
        modal.style.display = 'none';
    });
    break;
}
                case 'send-voice': {
                    const modal = document.getElementById('send-voice-modal');
                    const voiceTextInput = document.getElementById('send-voice-text-input');
                    voiceTextInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-voice-btn', async () => {
                        const voiceText = voiceTextInput.value.trim();
                        if (voiceText) {
                            const duration = Math.max(1, Math.round(voiceText.length / 4));
                            await createAndAddMessage({ type: 'voice', content: { duration, text: voiceText } });
                            modal.style.display = 'none';
                        }
                    });
                    break;
                }
                // 在 handleAttachmentAction 函数中...

case 'send-red-packet': {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) break;

    const modal = document.getElementById('send-red-packet-modal');
    // 动态修改弹窗，以适应群聊和私聊
    const modalBody = modal.querySelector('.modal-body');
    
    let amountInputHTML = `
        <div class="contact-form-group">
            <label class="contact-form-label">金额 (元)</label>
            <input type="number" class="contact-form-input" id="send-red-packet-amount-input" placeholder="0.00">
        </div>`;
    
    let countInputHTML = '';
    // 如果是群聊，增加“红包个数”输入框
    if (contact.isGroup) {
        countInputHTML = `
            <div class="contact-form-group">
                <label class="contact-form-label">红包个数</label>
                <input type="number" class="contact-form-input" id="send-red-packet-count-input" placeholder="填写个数，比如10">
            </div>`;
    }

    modalBody.innerHTML = `
        ${amountInputHTML}
        ${countInputHTML}
        <div class="contact-form-group">
            <label class="contact-form-label">祝福语 (可选)</label>
            <input type="text" class="contact-form-input" id="send-red-packet-blessing-input" placeholder="恭喜发财，大吉大利！">
        </div>
        <button class="form-button" id="confirm-send-red-packet-btn" style="background-color: #E64340;">塞钱进红包</button>
    `;
    
    modal.style.display = 'flex';
    
    addOneTimeListener('confirm-send-red-packet-btn', async () => {
        const amount = parseFloat(document.getElementById('send-red-packet-amount-input').value);
        const blessing = document.getElementById('send-red-packet-blessing-input').value.trim() || "恭喜发财，大吉大利！";
        
        if (isNaN(amount) || amount <= 0) {
            return alert("请输入有效的金额！");
        }
        if (state.myProfile.balance < amount) {
            return alert('钱包余额不足！');
        }

        // 核心逻辑分离
        if (contact.isGroup) {
            // 群聊逻辑
            const countInput = document.getElementById('send-red-packet-count-input');
            const count = parseInt(countInput.value, 10);
            if (isNaN(count) || count <= 0) {
                return alert("请输入有效的红包个数！");
            }
            if (amount / count < 0.01) {
                return alert("单个红包金额不能低于0.01元！");
            }

            state.myProfile.balance -= amount;
            await addTransaction('expense', amount, `在群聊"${contact.name}"中发红包`, contact.id);

            await createAndAddMessage({
                type: 'red_packet',
                content: {
                    totalAmount: amount,
                    count: count,
                    blessing: blessing,
                    claimers: [] // 初始化领取者列表
                }
            });

        } else {
            // 私聊逻辑 (不变)
            state.myProfile.balance -= amount;
            await addTransaction('expense', amount, `发红包给 ${contact.name}`, contact.id);

            await createAndAddMessage({
                type: 'red_packet',
                content: {
                    amount: amount.toFixed(2), // 私聊是单个红包
                    blessing: blessing,
                    opened: false
                }
            });
        }
        
        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
        modal.style.display = 'none';
    });
    break;
}
                case 'send-transfer': {
                    const modal = document.getElementById('send-transfer-modal');
                    const amountInput = document.getElementById('send-transfer-amount-input');
                    amountInput.value = '';
                    modal.style.display = 'flex';
                    addOneTimeListener('confirm-send-transfer-btn', async () => {
                        const transferAmount = parseFloat(amountInput.value);
                        if (!isNaN(transferAmount) && transferAmount > 0) {
                            if(state.myProfile.balance < transferAmount) {
                                alert('钱包余额不足！');
                                return;
                            }
                            state.myProfile.balance -= transferAmount;
                            await addTransaction('expense', transferAmount, `转账给 ${state.contacts.find(c=>c.id === state.activeChatId).name}`, state.activeChatId);
                            renderMyProfile();
                            await kokoMemory.put('myProfile', state.myProfile);

                            await createAndAddMessage({
                                type: 'transfer',
                                content: { amount: transferAmount.toFixed(2), completed: false }
                            });
                            modal.style.display = 'none';
                        } else {
                            alert("请输入有效的金额！");
                        }
                    });
                    break;
                }
                
                 // --- NEW: V7.0 ---
 // 在 handleAttachmentAction 函数中...
case 'share-music': {
    const modal = document.getElementById('send-music-modal');
    modal.style.display = 'flex';

    // 重置UI到默认状态（在线搜索）
    switchMusicShareTab('search');
    document.getElementById('online-music-search-input').value = '';
    document.getElementById('online-music-search-results').innerHTML = '<p style="text-align: center; color: #888;">请输入关键词进行搜索</p>';
    document.getElementById('notify-ai-checkbox').checked = true;

    // 预加载“从曲库选择”面板的内容
    renderMusicPickerInShareModal();
    break;
}
                
                    case 'game-wheel': {
    const modal = document.getElementById('create-wheel-modal');
    const optionsContainer = document.getElementById('wheel-options-container');
    document.getElementById('wheel-name-input').value = '';
    optionsContainer.innerHTML = ''; // 清空旧选项

    // 默认创建2个选项
    addWheelOptionInput('真心话', 1);
    addWheelOptionInput('大冒险', 1);

    modal.style.display = 'flex';
    break;
}
                    case 'start-video-call': if (state.activeChatId) { startVideoCall(state.activeChatId, 'user'); } else { alert("请先选择一个聊天对象！"); } break;
            }
        }
        
        function showDiaryScreen() {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            hideAllScreens();
            document.getElementById('diary-screen').style.display = 'flex';
            document.getElementById('diary-title').textContent = `${contact.name}的日记`;
            renderDiary();
        }

        function renderDiary() {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            const diaryContentList = document.getElementById('diary-content-list');
            diaryContentList.innerHTML = '';

            if (!contact || !contact.diary || contact.diary.length === 0) {
                diaryContentList.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-book" style="font-size: 48px; margin-bottom: 15px;"></i><p>他的日记本是空的。</p></div>`;
                return;
            }

            const sortedDiary = [...contact.diary].sort((a, b) => b.timestamp - a.timestamp);

            sortedDiary.forEach(entry => {
                const entryEl = document.createElement('div');
                entryEl.className = 'diary-entry';
                entryEl.innerHTML = `
                    <div class="diary-entry-meta">${formatTimeAgo(entry.timestamp)}</div>
                    <div class="diary-entry-content">${entry.content.replace(/\n/g, '<br>')}</div>
                    <div class="diary-delete-btn" data-diary-id="${entry.id}"><i class="fas fa-trash-alt"></i></div>
                `;
                diaryContentList.appendChild(entryEl);
            });
        }

        // ▼▼▼ 用下面这个【完整的新版本】，替换掉你旧的 createSystemNotification 函数 ▼▼▼

async function createSystemNotification(content, targetContact = null) {
    // 同样，如果未指定目标，就用当前窗口的，否则用指定的目标
    const contact = targetContact || state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    await createAndAddMessage({
        type: 'system_notification',
        sender: 'system',
        content: content
    }, 'system', contact); // 把 contact 作为第三个参数传进去
}

// ▲▲▲ 替换到这里结束 ▲▲▲
        
        async function showTransferModal(message, contact) {
            const modal = document.getElementById('transfer-modal');
            
            // 获取新HTML结构中的所有元素
            const confirmView = document.getElementById('transfer-confirm-view');
            const statusView = document.getElementById('transfer-status-view');
            
            const senderAvatarEl = document.getElementById('transfer-sender-avatar');
            const senderNameEl = document.getElementById('transfer-sender-name');
            const recipientTextEl = document.getElementById('transfer-recipient-text');
            const amountValueEl = document.getElementById('transfer-amount-value');

            const statusAmountValueEl = document.getElementById('transfer-status-amount-value');
            const statusIconEl = document.getElementById('transfer-status-icon');
            const statusTextEl = document.getElementById('transfer-status-text');
            const statusSenderInfoEl = document.getElementById('transfer-status-sender-info');
            
            const sender = (message.sender === 'user') ? state.myProfile : contact;
            const recipient = (message.sender === 'user') ? contact : state.myProfile;
            
            amountValueEl.textContent = message.content.amount;
            statusAmountValueEl.textContent = message.content.amount;

            // --- 移除并重新绑定事件监听，防止重复绑定 ---
            const confirmBtn = document.getElementById('confirm-transfer-btn');
            const returnBtn = document.getElementById('return-transfer-btn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newReturnBtn = returnBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            returnBtn.parentNode.replaceChild(newReturnBtn, returnBtn);

            // 确认收款按钮的逻辑 (已修改)
            // --- 修正后的代码 ---
newConfirmBtn.addEventListener('click', async () => {
    const transferAmount = parseFloat(message.content.amount);
    const senderProfile = contact; // 在这个上下文中，'contact'就是发送者
    const groupChat = state.contacts.find(c => c.id === state.activeChatId); // 获取当前的群聊对象

    if (!groupChat) return; // 安全检查

    if (!isNaN(transferAmount)) {
        state.myProfile.balance += transferAmount;
        await addTransaction('income', transferAmount, `收到 ${senderProfile.name} 的转账`, senderProfile.id);
        await createSystemNotification(`你已收款 ¥${transferAmount.toFixed(2)}`);
        renderMyProfile();
        await kokoMemory.put('myProfile', state.myProfile);
    }

    // 在群聊的历史记录里更新这条消息的状态
    const messageInHistory = groupChat.history.find(m => m.id === message.id);
    if (messageInHistory) {
        messageInHistory.content.completed = true;
        messageInHistory.content.returned = false;
    }

    // 核心修正 1：保存的是群聊对象，而不是发钱的角色对象
    await kokoMemory.put('contacts', groupChat); 

    modal.style.display = 'none';
    // 核心修正 2：重新打开的是当前的群聊界面
    await openChat(state.activeChatId);

    // 这条消息现在会正确地添加到群聊的记忆中
    await createAndAddMessage({
        type: 'text',
        content: `[SYSTEM: 我刚刚点击并接受了 ${senderProfile.name} 的转账。]`
    }, 'system_instruction');
});
            
            // 退还按钮的逻辑
            // --- 修正后的代码 ---
newReturnBtn.addEventListener('click', async () => {
    const senderProfile = contact; // 'contact' 在这里就是发送者
    const groupChat = state.contacts.find(c => c.id === state.activeChatId); // 获取当前聊天（群聊或私聊）

    if (!groupChat) return; // 安全检查

    // 在当前聊天记录里更新这条消息的状态
    const messageInHistory = groupChat.history.find(m => m.id === message.id);
    if (messageInHistory) {
        messageInHistory.content.completed = true;
        messageInHistory.content.returned = true;
    }

    // 核心修正 1：保存的是包含历史记录的当前聊天对象
    await kokoMemory.put('contacts', groupChat);

    await createSystemNotification(`你已退还该笔转账`);

    modal.style.display = 'none';
    // 核心修正 2：重新打开的是当前的聊天界面（私聊或群聊），而不是跳转
    await openChat(state.activeChatId);

    // 为了让AI在群聊中更清晰，优化了SYSTEM指令
    await createAndAddMessage({
        type: 'text',
        content: `[SYSTEM: 我刚刚退回了 ${senderProfile.name} 的转账。]`
    }, 'system_instruction');
});

            // 根据消息状态更新UI
            senderAvatarEl.src = sender.avatar;
            senderNameEl.textContent = sender.name;
            
            if (message.content.completed || message.content.returned) {
                // 如果是已完成或已退还的交易
                confirmView.style.display = 'none';
                statusView.style.display = 'block';
                
                statusIconEl.className = message.content.returned ? 'fas fa-undo-alt' : 'fas fa-check-circle';
                statusTextEl.textContent = message.content.returned ? '已退还' : (message.sender === 'user' ? '对方已收款' : '已收款');
                statusSenderInfoEl.textContent = `转账来自: ${sender.name}`;

            } else if (message.sender !== 'user') { // 我是收款方，未处理
                confirmView.style.display = 'block';
                statusView.style.display = 'none';
                recipientTextEl.textContent = "转账给你";
                newConfirmBtn.style.display = 'block';
                newReturnBtn.style.display = 'block';
            } else { // 我是付款方，对方未处理
                confirmView.style.display = 'block';
                statusView.style.display = 'none';
                recipientTextEl.textContent = `转账给 ${recipient.name}`;
                newConfirmBtn.style.display = 'none';
                newReturnBtn.style.display = 'none';
            }
            
            modal.style.display = 'flex';
            document.getElementById('close-transfer-modal').onclick = () => modal.style.display = 'none';
        }

// ▼▼▼ 使用这个【最终解决方案】替换掉你原来的 processAndDisplayAiResponse 函数 ▼▼▼
async function processAndDisplayAiResponse(rawResponse, senderProfile, originContext = null) {
    if (!senderProfile) return;

    let effectiveChatContext;

    // 规则0：如果明确指定了“发信地点”(originContext)，则无条件使用它！
    if (originContext) {
        effectiveChatContext = originContext;
    } else {
        // 规则1 (备用)：如果没指定地点，再尝试根据用户当前界面判断
        const activeChatContext = state.contacts.find(c => c.id === state.activeChatId);
        if (activeChatContext && activeChatContext.isGroup && activeChatContext.members.includes(senderProfile.id)) {
            effectiveChatContext = activeChatContext;
        } else {
            // 规则2 (最终备用)：如果以上都不满足，就发到AI自己的私聊窗口
            effectiveChatContext = senderProfile;
        }
    }
    
    if (!effectiveChatContext) {
        console.error("错误：无法为AI回复确定一个有效的目的地。");
        return; 
    }
    
    let conversation = rawResponse;
    const extractionRegex = /\[发送了一段静态内容，文本是：["']([\s\S]*?)["']\]/g;
    conversation = conversation.replace(extractionRegex, '').trim();

    // ========================= 【核心新增：心声解析】 =========================
let heartVoiceContent = null;
    // 这个正则表达式会一次性匹配整个心声块，并捕获内部内容。
    // 它能正确处理有结尾标签、或没有结尾标签直接跟[diary]或字符串结尾的情况。
    const heartVoiceRegex = /\[heart_voice\]([\s\S]*?)(?:\[\/heart_voice\]|(?=\[diary\]|$))/;
    const heartVoiceMatch = conversation.match(heartVoiceRegex);

    // 只要找到了心声块（无论内容是否有效）...
    if (heartVoiceMatch) {
        // heartVoiceMatch[1] 是我们想要的JSON内容
        const jsonString = heartVoiceMatch[1] ? heartVoiceMatch[1].trim() : '';
        
        // 只有在内容不为空时，才尝试解析
        if (jsonString) {
            try {
                // 清理掉可能存在的换行符，让JSON解析更稳定
                const cleanedJsonString = jsonString.replace(/(\r\n|\n|\r)/gm, "");
                heartVoiceContent = JSON.parse(cleanedJsonString);
            } catch (e) {
                console.error("解析心声JSON失败:", e, "原始字符串:", jsonString);
                // 即使解析失败，我们也要继续执行下面的移除逻辑，确保错误格式的内容不会显示出来。
            }
        }
        
        // 【核心修复】
        // 无论解析是否成功，都使用 heartVoiceMatch[0] (即匹配到的完整字符串，例如 "[heart_voice]{...}[/heart_voice]")
        // 来进行一次性、精准、无残留的替换。
        conversation = conversation.replace(heartVoiceMatch[0], '').trim();
    }
    // ========================= 【新增结束】 =========================

    let diaryContent = null;
    const strictDiaryRegex = /\[diary\]([\s\S]*?)\[\/diary\]/g;
    const strictMatch = strictDiaryRegex.exec(conversation);

    if (strictMatch && strictMatch[1]) {
        diaryContent = strictMatch[1].trim();
        conversation = conversation.replace(strictDiaryRegex, '').trim();
    } else {
        const lenientDiaryStartIndex = conversation.indexOf('[diary]');
        if (lenientDiaryStartIndex !== -1) {
            diaryContent = conversation.substring(lenientDiaryStartIndex + '[diary]'.length).trim();
            conversation = conversation.substring(0, lenientDiaryStartIndex).trim();
        }
    }

    if (diaryContent) {
        if (!senderProfile.diary) senderProfile.diary = [];
        senderProfile.diary.push({
            id: `diary_${Date.now()}`,
            content: diaryContent,
            timestamp: Date.now()
        });
        await kokoMemory.put('contacts', senderProfile);
    }
    
// ... 省略了日记保存的代码 ...

    // ▼▼▼ 使用这个【增强版】来替换原来的代码 ▼▼▼
    if (heartVoiceContent) {
        
        // 1. 在添加新的心声消息之前...
        // ...我们先把这个角色历史记录里所有旧的 'heart_voice' 消息都过滤掉。
        // .filter() 方法会创建一个新数组，其中仅包含所有不符合 "msg.type === 'heart_voice'" 条件的元素。
        if (effectiveChatContext.history) {
             effectiveChatContext.history = effectiveChatContext.history.filter(msg => msg.type !== 'heart_voice');
        }

        // 2. 然后，再把这个最新的心声添加进去。
        // 这样一来，历史记录里永远最多只有一个心声消息。
        await createAndAddMessage({
            type: 'heart_voice',
            content: heartVoiceContent
        }, senderProfile.id, effectiveChatContext);
    }
    // ▲▲▲ 替换结束 ▲▲▲

// ... 后续代码 ...
    const callTriggerRegex = /\[action:start_video_call\]|发起了视频通话|视频通话请求已发送|正在向您发起视频通话|已拨通您的视频电话/;

    if (!effectiveChatContext.isGroup && callTriggerRegex.test(conversation)) {
        handleIncomingCall(senderProfile);
        const callTriggerRegexForReplace = /\[action:start_video_call\]|给你打个视频电话|我们来视频通话|拨通了你的电话|打过去了|播出去了|\[.*?(呼叫|拨打|视频|电话).*?\]/g;
        const textResponse = conversation.replace(callTriggerRegexForReplace, '').trim();
        if (textResponse) {
            await createAndAddMessage({ type: 'text', content: textResponse }, senderProfile.id, senderProfile);
        }
        return;
    }

    if (state.activeCall && state.activeCall.contactId === effectiveChatContext.id) {
        await createAndAddMessage({
            type: 'video_call_text',
            content: conversation
        }, senderProfile.id, senderProfile);

        const narrativeFeed = document.getElementById('narrative-feed');
        const actionRegex = /\[action:(.*?)\]/g;
        let narrativeText = conversation;
        const match = actionRegex.exec(conversation);
        if (match) {
            const action = match[1].trim();
            if (action === 'hang_up') {
                narrativeText = conversation.replace(actionRegex, '').trim();
                if (narrativeText) {
                    const bubble = document.createElement('div');
                    bubble.className = 'char-bubble';
                    bubble.innerHTML = `<p class="narrative-speech">“${narrativeText}”</p>`;
                    narrativeFeed.appendChild(bubble);
                    narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
                    await sleep(1000);
                }
                await endVideoCall('contact', `${senderProfile.name} 挂断了电话`);
                return;
            }
        }

        if (narrativeText) {
            const bubble = document.createElement('div');
            bubble.className = 'char-bubble';
            const regex = /(\*[^*]+\*)|(\{[^{}]+\})|(“[^”]+”)/g;
            const parts = narrativeText.split(regex).filter(Boolean);
            parts.forEach(part => {
                part = part.trim();
                if (!part) return;
                const p = document.createElement('p');
                if (part.startsWith('*')) { p.className = 'narrative-action'; p.textContent = part; }
                else if (part.startsWith('{')) { p.className = 'narrative-psychology'; p.textContent = part; }
                else if (part.startsWith('“')) { p.className = 'narrative-speech'; p.textContent = part; }
                else { p.className = 'narrative-speech'; p.textContent = `“${part}”`; }
                bubble.appendChild(p);
            });
            narrativeFeed.appendChild(bubble);
            narrativeFeed.scrollTop = narrativeFeed.scrollHeight;

            const dialogueParts = [];
            const dialogueRegex = /“([^”]+)”/g;
            let dialogueMatch;
            while ((dialogueMatch = dialogueRegex.exec(narrativeText)) !== null) {
                dialogueParts.push(dialogueMatch[1]);
            }
            const fullDialogue = dialogueParts.join('，');

if (fullDialogue) {
    // 传入 senderProfile (也就是完整的 contact 对象)
    await playNextInQueue(fullDialogue, senderProfile); 
}
        }
        return;
    }

    const lastUnopenedMessage = effectiveChatContext.history.slice().reverse().find(m =>
        m.sender === 'user' && (
            (m.type === 'red_packet' && !m.content.opened) ||
            (m.type === 'transfer' && !m.content.completed)
        )
    );

    if (lastUnopenedMessage) {
        const rejectionKeywords = ['不收', '不要', '退回', '还给你', '我不能要', '心意领了'];
        const acceptanceKeywords = ['收下', '收了', '领了', '打开', '谢谢', '我收', '我领'];
        const rejected = rejectionKeywords.some(keyword => conversation.includes(keyword));
        if (rejected) {
            if (lastUnopenedMessage.type === 'transfer') {
                lastUnopenedMessage.content.completed = true;
                lastUnopenedMessage.content.returned = true;
                const transferAmount = parseFloat(lastUnopenedMessage.content.amount);
                if (!isNaN(transferAmount)) {
                    state.myProfile.balance += transferAmount;
                    await addTransaction('income', transferAmount, `来自 ${senderProfile.name} 的转账退款`, senderProfile.id);
                    renderMyProfile();
                    await kokoMemory.put('myProfile', state.myProfile);
                }
                await createSystemNotification(`${senderProfile.name} 退还了你的转账`, effectiveChatContext);
            }
        } else {
            const accepted = acceptanceKeywords.some(keyword => conversation.includes(keyword));
            if (accepted) {
                let classToAdd = '';
                if (lastUnopenedMessage.type === 'red_packet') {
                    lastUnopenedMessage.content.opened = true;
                    classToAdd = 'opened';
                } else if (lastUnopenedMessage.type === 'transfer') {
                    lastUnopenedMessage.content.completed = true;
                    lastUnopenedMessage.content.returned = false;
                    classToAdd = 'completed';
                }
                const messageWrapperEl = document.querySelector(`.message-wrapper[data-message-id='${lastUnopenedMessage.id}']`);
                if (messageWrapperEl) {
                    const innerMessageEl = messageWrapperEl.querySelector('.message.red-packet, .message.transfer');
                    if (innerMessageEl) {
                        innerMessageEl.classList.add(classToAdd);
                        if (lastUnopenedMessage.type === 'red_packet') {
                            const headerEl = innerMessageEl.querySelector('.red-packet-header');
                            if (headerEl) {
                                headerEl.innerHTML = `<div class="red-packet-icon">🧧</div><div class="red-packet-status">红包已被领取</div>`;
                            }
                        }
                    }
                }
            }
        }
        await kokoMemory.put('contacts', effectiveChatContext);
        await sleep(100);
    }

    if (effectiveChatContext.isNarrativeMode) {
        if (conversation) {
            await sleep(400 + Math.random() * 400);
            await createAndAddMessage({ type: 'text', content: conversation }, senderProfile.id, effectiveChatContext);
        }
    } else {
        const trimmedConversation = conversation.trim();
        if (trimmedConversation.startsWith('<') && trimmedConversation.endsWith('>')) {
            await createAndAddMessage({ type: 'html', content: conversation }, senderProfile.id, effectiveChatContext);
            return;
        }

        let messages = conversation.split('\n').filter(line => line.trim() !== '');
        let triggerLineIndex = -1;
        for (let i = 0; i < messages.length; i++) {
            if (callTriggerRegex.test(messages[i])) {
                triggerLineIndex = i;
                break;
            }
        }

        if (!effectiveChatContext.isGroup && triggerLineIndex !== -1) {
            messages = messages.slice(0, triggerLineIndex);
            setTimeout(() => {
                handleIncomingCall(senderProfile);
            }, (messages.length * 800) + 500);
        }

        for (const line of messages) {
            const jumpTheGunRegex = /^(喂|嘿|hello|哈[喽囉])(？|，|,|\.|...)?.*(听得见|听见|在吗)/i;
            if (!effectiveChatContext.isGroup && !state.activeCall && jumpTheGunRegex.test(line)) {
                console.warn("AI attempted to jump into a call. Intercepting and correcting flow.");
                handleIncomingCall(senderProfile);
                break;
            }

            const finalCallTriggerRegex = /发起了视频通话|我们来视频通话吧|给你打个电话|拨通了你的电话|\[action:start_video_call\]/i;
            if (!effectiveChatContext.isGroup && finalCallTriggerRegex.test(line)) {
                handleIncomingCall(senderProfile);
                break;
            }

            if (/^\[SYSTEM[:：]/.test(line.trim())) {
                continue;
            }

            let processed = false;
            const commandRegex = /\[(sticker|voice|picture|red_packet|transfer|transfer_to|music|spin_wheel|claim_red_packet|location|create_location)(?::([^\]]*))?\]/;
            const commandMatch = line.match(commandRegex);
            const lastWheelMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
            if (lastWheelMsg) {
                const contactName = senderProfile.name;
                const validOptions = lastWheelMsg.content.options.map(opt => opt.text);
                const ultimatePositionalRegex = new RegExp(`(?:${contactName}|我).*?(?:[“"'])?(${validOptions.join('|')})(?:[“"'])?`);
                const fallbackMatch = line.match(ultimatePositionalRegex);
                if (fallbackMatch) {
                    const result = fallbackMatch[1];
                    const wheel = lastWheelMsg.content;
                    wheel.results.contact = result.trim();
                    await kokoMemory.put('contacts', effectiveChatContext);
                    const msgIdToUpdate = lastWheelMsg.id;
                    const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
                    if (wrapperToUpdate) {
                        const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
                        if (contactResultRow) {
                            contactResultRow.innerHTML = `<span class="wheel-player-name">${contactName}</span> <div class="wheel-player-result">${result.trim()}</div>`;
                        }
                    }
                    continue;
                }
            }

            if (commandMatch) {
                processed = true;
                const command = commandMatch[1];
                const value = commandMatch[2] || '';
                switch (command) {
                    case 'claim_red_packet': {
                        const lastPacketMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'red_packet' && m.content.count > (m.content.claimers || []).length);
                        if (lastPacketMsg) {
                            const packet = lastPacketMsg.content;
                            const hasClaimed = (packet.claimers || []).some(c => c.userId === senderProfile.id);
                            if (!hasClaimed) {
                                const remainingCount = packet.count - packet.claimers.length;
                                const remainingAmount = packet.totalAmount - packet.claimers.reduce((sum, c) => sum + c.amount, 0);
                                let amount = 0;
                                if (remainingCount > 1) {
                                    const avg = remainingAmount / remainingCount;
                                    amount = Math.random() * avg * 1.8;
                                    amount = Math.min(remainingAmount - (remainingCount - 1) * 0.01, amount);
                                } else {
                                    amount = remainingAmount;
                                }
                                amount = Math.max(0.01, parseFloat(amount.toFixed(2)));
                                packet.claimers.push({ userId: senderProfile.id, amount: amount });
                                await kokoMemory.put('contacts', effectiveChatContext);
                                const remainingText = line.replace(commandRegex, '').trim();
                                if (remainingText) {
                                    await createAndAddMessage({ type: 'text', content: remainingText }, senderProfile.id, effectiveChatContext);
                                }
                                const senderId = lastPacketMsg.sender;
                                let notificationText = '';
                                if (senderId === 'myProfile') {
                                    notificationText = `${senderProfile.name} 领取了你的红包`;
                                } else {
                                    const sender = state.contacts.find(c => c.id === senderId);
                                    const senderName = sender ? sender.name : '另一位成员';
                                    notificationText = `${senderProfile.name} 领取了 ${senderName} 的红包`;
                                }
                                await createSystemNotification(notificationText, effectiveChatContext);
                            }
                        }
                        processed = true;
                        break;
                    }
                    case 'location': {
                        const locationName = value.trim();
                        if (senderProfile && senderProfile.mapId) {
                            const mapData = await kokoMemory.get('maps', senderProfile.mapId);
                            const location = mapData.locations.find(loc => loc.name === locationName);
                            if (location) {
                                await createAndAddMessage({ type: 'location_share', content: { mapId: senderProfile.mapId, locationId: location.id, name: location.name, icon: location.icon, x: location.x, y: location.y } }, senderProfile.id, effectiveChatContext);
                            } else {
                                await createAndAddMessage({ type: 'text', content: `(系统错误：我想发送一个叫“${locationName}”的位置，但地图上好像没有这个地方。)` }, senderProfile.id, effectiveChatContext);
                            }
                        }
                        break;
                    }
                    case 'create_location': {
                        try {
                            const locationData = JSON.parse(value);
                            if (senderProfile && senderProfile.mapId) {
                                const mapData = await kokoMemory.get('maps', senderProfile.mapId);
                                if (mapData) {
                                    const newLocation = { id: 'loc_' + Date.now(), name: locationData.name, description: locationData.description, icon: locationData.icon, tier: locationData.tier || 2, x: locationData.x, y: locationData.y };
                                    if (!mapData.locations) mapData.locations = [];
                                    mapData.locations.push(newLocation);
                                    await kokoMemory.put('maps', mapData);
                                    await createAndAddMessage({ type: 'location_share', content: { mapId: senderProfile.mapId, locationId: newLocation.id, ...newLocation } }, senderProfile.id, effectiveChatContext);
                                }
                            }
                        } catch (error) {
                            await createAndAddMessage({ type: 'text', content: `(系统：我刚才想创建一个新地点，但是失败了...)` }, senderProfile.id, effectiveChatContext);
                        }
                        break;
                    }
                    case 'spin_wheel': {
                        const currentWheelMsg = [...effectiveChatContext.history].reverse().find(m => m.type === 'game_wheel' && !m.content.results.contact);
                        if (currentWheelMsg) {
                            const wheel = currentWheelMsg.content;
                            const weightedOptions = wheel.options.flatMap(opt => Array(opt.weight).fill(opt.text));
                            const result = weightedOptions[Math.floor(Math.random() * weightedOptions.length)];
                            wheel.results.contact = result;
                            await kokoMemory.put('contacts', effectiveChatContext);
                            const msgIdToUpdate = currentWheelMsg.id;
                            const wrapperToUpdate = document.querySelector(`.message-wrapper[data-message-id='${msgIdToUpdate}']`);
                            if (wrapperToUpdate) {
                                const contactResultRow = wrapperToUpdate.querySelectorAll('.wheel-result-row')[1];
                                if (contactResultRow) {
                                    contactResultRow.innerHTML = `<span class="wheel-player-name">${senderProfile.name}</span> <div class="wheel-player-result">${result}</div>`;
                                }
                            }
                        }
                        break;
                    }
                    case 'red_packet': {
                        const parts = value.split(/[，,]/).map(p => p.trim());
                        if (parts.length === 3) {
                            const blessing = parts[0] || "恭喜发财！";
                            const totalAmount = parseFloat(parts[1]);
                            const count = parseInt(parts[2], 10);
                            if (!isNaN(totalAmount) && totalAmount > 0 && !isNaN(count) && count > 0) {
                                await createAndAddMessage({ type: 'red_packet', content: { totalAmount: totalAmount, count: count, blessing: blessing, claimers: [] } }, senderProfile.id, effectiveChatContext);
                            }
                        } else if (parts.length === 2) {
                            const blessing = parts[0] || "恭喜发财！";
                            const amount = parseFloat(parts[1]);
                            if (!isNaN(amount) && amount > 0) {
                                await createAndAddMessage({ type: 'red_packet', content: { amount: amount.toFixed(2), blessing: blessing, opened: false } }, senderProfile.id, effectiveChatContext);
                            }
                        }
                        break;
                    }
                    case 'transfer_to': {
                        const parts = value.split(/[，,]/).map(p => p.trim());
                        if (parts.length === 2) {
                            const recipientName = parts[0];
                            const amount = parseFloat(parts[1]);
                            const recipientProfile = effectiveChatContext.members.map(id => id === 'myProfile' ? state.myProfile : state.contacts.find(c => c.id === id)).find(p => p && p.name === recipientName);
                            if (recipientProfile && !isNaN(amount) && amount > 0) {
                                await createAndAddMessage({ type: 'transfer', content: { amount: amount.toFixed(2), completed: false, returned: false, recipientId: recipientProfile.id } }, senderProfile.id, effectiveChatContext);
                            }
                        }
                        break;
                    }
                    case 'sticker':
                        const emoticon = state.emoticons.find(e => e.name === value.trim());
                        if (emoticon) {
                            await createAndAddMessage({ type: 'image', url: emoticon.url, isEmoticon: true, emoticonName: emoticon.name }, senderProfile.id, effectiveChatContext);
                        } else {
                            await createAndAddMessage({ type: 'text', content: `[发送表情失败: ${value}]` }, senderProfile.id, effectiveChatContext);
                        }
                        break;
                    case 'voice':
                        const duration = Math.max(1, Math.round(value.length / 4));
                        await createAndAddMessage({ type: 'voice', content: { text: value, duration: duration } }, senderProfile.id, effectiveChatContext);
                        processed = true;
                        break;
                    case 'picture':
                        await createAndAddMessage({ type: 'picture_description', content: { description: value } }, senderProfile.id, effectiveChatContext);
                        break;
                    case 'transfer': {
                        const transferAmount = parseFloat(value);
                        if (transferAmount > 0) {
                            await createAndAddMessage({ type: 'transfer', content: { amount: transferAmount.toFixed(2), completed: false, returned: false } }, senderProfile.id, effectiveChatContext);
                        }
                        break;
                    }
                    case 'music': {
                        const lastComma = value.lastIndexOf('，') > -1 ? '，' : ',';
                        const lastCommaIndex = value.lastIndexOf(lastComma);
                        if (lastCommaIndex === -1) break;
                        const url = value.substring(lastCommaIndex + 1).trim();
                        const secondToLastCommaIndex = value.lastIndexOf(lastComma, lastCommaIndex - 1);
                        if (secondToLastCommaIndex === -1) break;
                        const artist = value.substring(secondToLastCommaIndex + 1, lastCommaIndex).trim();
                        const title = value.substring(0, secondToLastCommaIndex).trim();
                        if (url.startsWith('http') && title) {
                            await createAndAddMessage({ type: 'music_share', content: { title, artist, url } }, senderProfile.id, effectiveChatContext);
                        }
                        break;
                    }
                }
            }

            if (!processed) {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('<') && trimmedLine.endsWith('>')) {
                    await createAndAddMessage({ type: 'html', content: line }, senderProfile.id, effectiveChatContext);
                } else {
                    await createAndAddMessage({ type: 'text', content: line }, senderProfile.id, effectiveChatContext);
                }
            }
            await sleep(400 + Math.random() * 400);
        }
    }
}
        async function renderPostDetail() {
            const post = state.posts.find(p => p.id === state.activePostId);
            if (!post) {
                showFeedScreen();
                return;
            }
            const container = document.getElementById('post-detail-container');
            const commentsList = document.getElementById('comments-list');
            container.innerHTML = '';
            commentsList.innerHTML = '';

            const postItemEl = createPostItem(post, true); 
            if (postItemEl) {
                container.appendChild(postItemEl);
                container.querySelector('.like-btn')?.addEventListener('click', toggleLike);
                container.querySelector('.post-delete-btn')?.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    const postId = e.currentTarget.dataset.postId;
                    if(confirm('确定要删除这条动态吗？')) {
                        state.posts = state.posts.filter(p => p.id !== postId);
                        await kokoMemory.delete('posts', postId);
                        await showFeedScreen();
                    }
                });
                postItemEl.addEventListener('click', (e) => {
                    if (!e.target.closest('.post-action-btn, .mention, .post-delete-btn')) {
                         document.getElementById('comment-input').focus();
                    }
                });
            }
            
            if (post.comments.length > 0) {
                const sortedComments = [...post.comments].sort((a,b) => a.timestamp - b.timestamp);
                sortedComments.forEach(comment => {
                    const author = comment.author;
                    if (!author) return;

                    const commentEl = document.createElement('div');
                    commentEl.className = 'post-comment-item';
                    commentEl.dataset.authorName = author.name; 
                    commentEl.dataset.authorId = author.id;
                    
                    commentEl.innerHTML = `
                        <div style="display: flex; gap: 10px;">
                            <img src="${author.avatar}" style="width: 35px; height: 35px; border-radius: 50%;">
                            <div style="flex-grow: 1;">
                                <div>
                                    <span class="comment-author">${author.name}</span>
                                    ${comment.replyTo ? `<span class="comment-reply-to">回复 @${comment.replyTo}</span>` : ''}
                                </div>
                                <div class="comment-content">${parseMentions(comment.content)}</div>
                                <div class="comment-meta">
                                    <span>${formatTimeAgo(comment.timestamp)}</span>
                                    <span class="comment-delete-btn" data-comment-id="${comment.id}"><i class="fas fa-trash-alt"></i> 删除</span>
                                </div>
                            </div>
                        </div>
                    `;

                    commentsList.appendChild(commentEl);
                });
            } else {
                commentsList.innerHTML = `<div style="text-align: center; color: #999; padding: 20px;">还没有评论，快来抢沙发吧！</div>`;
            }
        }
        function triggerPetAnimation(animationType) {
            const petElements = document.querySelectorAll('.slime');
            petElements.forEach(slimeEl => {
                if (animationType === 'jiggle') {
                    slimeEl.classList.add('happy-jiggle');
                    setTimeout(() => slimeEl.classList.remove('happy-jiggle'), 500);
                }
                if (animationType === 'blush') {
                    slimeEl.classList.add('is-blushing');
                    setTimeout(() => slimeEl.classList.remove('is-blushing'), 2000);
                }
            });
        }
        // --- 新增：显示和取消回复预览的函数 ---
// --- 最终完美的 showReplyPreview 函数 ---
function showReplyPreview(message) {
    const previewBar = document.getElementById('reply-preview-bar');
    const currentChat = state.contacts.find(c => c.id === state.activeChatId);
    let senderName;

    if (message.sender === 'user') {
        // 发送者是用户自己，这部分逻辑不变
        senderName = state.myProfile.name;
    } else if (currentChat && currentChat.isGroup) {
        // 如果是群聊，使用我们上次修复的逻辑，根据消息的 sender ID 查找具体成员
        const senderContact = state.contacts.find(c => c.id === message.sender);
        senderName = senderContact ? senderContact.name : '未知成员';
    } else {
        // 如果是私聊，使用最简单的老逻辑，发送者就是当前聊天对象
        senderName = currentChat ? currentChat.name : '未知成员';
    }

    previewBar.innerHTML = `
        <div id="reply-preview-content">
            回复 <span class="sender">${senderName}</span>: ${message.content}
        </div>
        <div id="cancel-reply-btn">&times;</div>
    `;
    previewBar.style.display = 'flex';

    document.getElementById('cancel-reply-btn').addEventListener('click', cancelReply, { once: true });
}

function cancelReply() {
    activeReplyTarget = null;
    const previewBar = document.getElementById('reply-preview-bar');
    previewBar.style.display = 'none';
    previewBar.innerHTML = '';
}
// ==========================================================
// V17.0 新增：视频通话核心管理函数 (已整合我们的优化方案)
// ==========================================================
async function startVideoCall(contactId, initiatedBy = 'user') {
    if (state.activeCall) return; 
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    if (initiatedBy === 'user') {
        const decisionPrompt = `[SYSTEM: 用户正在向你发起视频通话请求。根据你们最近的对话和你当前的心情，请用一个词决定是否接听：“接听”或“拒绝”。\n\n- 如果你现在很忙、生气或不想说话，就回复“拒绝”。\n- 否则，回复“接听”。\n\n不要添加任何其他文字，只回复这两个词中的一个。]`;
        const decision = await generateAiResponse(contact, contact.history, decisionPrompt);
        if (decision.includes('拒绝')) {
            await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `${contact.name} 现在不想接电话` });
            await requestAiReply(`[SYSTEM: 你刚刚拒绝了用户的视频通话请求，请发送一条简短的文字消息向用户解释原因（例如：在忙、心情不好等）。]`);
            return;
        }
    }
    
    state.activeCall = {
        contactId: contact.id,
        startTime: Date.now(),
        isCharCameraOff: false,
        initiatedBy: initiatedBy // 记录发起者
    };

    const videoScreen = document.getElementById('video-call-screen');
    document.getElementById('call-contact-name').textContent = contact.name;
    document.getElementById('narrative-feed').innerHTML = '<p class="narrative-action">*正在接通...*</p>';
    videoScreen.style.display = 'flex';
    
    // 永久记录通话开始事件
    const startMessage = initiatedBy === 'user' ? `你向 ${contact.name} 发起了视频通话` : `${contact.name} 向你发起了视频通话`;
    await createAndAddMessage({ type: 'system_notification', sender: 'system', content: startMessage });

    if (callTimerInterval) clearInterval(callTimerInterval);
    callTimerInterval = setInterval(updateCallUI, 1000);
    updateCallUI();

    // 如果是用户发起的，让AI先开口
    if (initiatedBy === 'user') {
        await requestAiReply(`[SYSTEM: 视频通话已接通。你必须主动说第一句话来打破沉默，可以是一句问候，或者描述你看到的场景。例如：“喂？听得到吗？我看到你啦！”]`);
    }
}

// ✨ 解决方案 ✨
async function endVideoCall(endedBy = 'user', reason = '通话已挂断') {
    if (!state.activeCall) return;

    const duration = Math.floor((Date.now() - state.activeCall.startTime) / 1000);
    const contactId = state.activeCall.contactId;
    
    // 1. 在这里获取完整的 contact 对象
    const contact = state.contacts.find(c => c.id === contactId); 

    state.activeCall = null;
    
    clearInterval(callTimerInterval);
    callTimerInterval = null;
    
    document.getElementById('video-call-screen').style.display = 'none';
    state.activeChatId = contactId;

    const durationMinutes = Math.floor(duration / 60);
    const durationSeconds = duration % 60;
    const durationText = `通话时长 ${durationMinutes}分${durationSeconds}秒`;

    // 2. 在调用时，把 contact 作为第三个参数传进去
    await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `${reason}，${durationText}` }, 'system', contact); 
    
    await createAndAddMessage({ type: 'text', content: '[SYSTEM: 通话已正式结束，立刻恢复标准聊天模式。]' }, 'system_instruction', contact);

    if (endedBy === 'user') {
        // (这部分功能可以保留或根据你的需要调整)
        // await requestAiReply(`[SYSTEM: 用户刚刚挂断了视频通话。请你对此发表一句简短的感想或道别。]`);
    }
}
function updateCallUI() {
    if (!state.activeCall) return;
    const duration = Math.floor((Date.now() - state.activeCall.startTime) / 1000);
    const min = Math.floor(duration / 60).toString().padStart(2, '0');
    const sec = (duration % 60).toString().padStart(2, '0');
    const timeString = `${min}:${sec}`;
    document.getElementById('call-status').textContent = `通话中 ${timeString}`;
}

function handleIncomingCall(contact) {
    if (state.activeCall) return;
    const screen = document.getElementById('incoming-call-screen');
    document.getElementById('incoming-caller-avatar').src = contact.avatar;
    document.getElementById('incoming-caller-name').textContent = contact.name;
    screen.style.display = 'flex';

    // 使用克隆节点的方式，防止重复绑定事件
    const oldAcceptBtn = document.getElementById('accept-call-btn');
    const newAcceptBtn = oldAcceptBtn.cloneNode(true);
    oldAcceptBtn.parentNode.replaceChild(newAcceptBtn, oldAcceptBtn);
    newAcceptBtn.addEventListener('click', () => {
        screen.style.display = 'none';
        startVideoCall(contact.id, 'contact');
    });

    const oldDeclineBtn = document.getElementById('decline-call-btn');
    const newDeclineBtn = oldDeclineBtn.cloneNode(true);
    oldDeclineBtn.parentNode.replaceChild(newDeclineBtn, oldDeclineBtn);
    newDeclineBtn.addEventListener('click', async () => {
        screen.style.display = 'none';
        await createAndAddMessage({ type: 'system_notification', sender: 'system', content: `你拒接了 ${contact.name} 的视频通话` });
        //await requestAiReply(`[SYSTEM: 用户刚刚拒接了你的视频通话请求。你可能会感到失落或好奇，请发送一条文字消息询问原因。]`);
    });
}

// ▼▼▼ 使用这个【新版本】替换掉你原来的 sendVideoCallMessage 函数 ▼▼▼
async function sendVideoCallMessage() {
    if (!state.activeCall) return;
    const input = document.getElementById('video-call-input');
    const content = input.value.trim();
    if (!content) return;

    // 定位到当前通话的联系人
    const contact = state.contacts.find(c => c.id === state.activeCall.contactId);
    if (!contact) return;

    // 使用我们之前修复好的方式，明确指定消息的接收者
    await createAndAddMessage({ type: 'video_call_text', content: content }, 'user', contact);

    const narrativeFeed = document.getElementById('narrative-feed');
    narrativeFeed.innerHTML += `<div class="user-message"><p>${content}</p></div>`;
    narrativeFeed.scrollTop = narrativeFeed.scrollHeight;
    input.value = '';
    
    // 关键修复！在请求AI回复时，把当前通话对象的ID传进去！
    await requestAiReply(null, state.activeCall.contactId); 
}
        
// --- 新增：处理消息编辑的核心函数（智能版，支持语音） ---
async function handleEditMessage(messageId) {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const message = contact.history.find(m => m.id === messageId);
    if (!message) return;

    // 1. 根据消息类型，智能获取当前的可编辑文本
    let currentText = '';
    if (message.type === 'voice') {
        currentText = message.content.text;
    } else { // 适用于 'text' 和 'html' 类型
        currentText = message.content;
    }

    // 2. 弹出编辑框，让用户输入新内容
    const newText = await showCustomPrompt('编辑消息', currentText);

    // 3. 如果用户点击了 "确定" 并且内容有变化
    if (newText !== null && newText.trim() !== currentText) {
        const trimmedNewText = newText.trim();

        // 4. 根据消息类型，智能地更新数据结构
        if (message.type === 'voice') {
            message.content.text = trimmedNewText;
            // 关键：重新计算并更新语音时长，这样气泡宽度也会自动变化
            message.content.duration = Math.max(1, Math.round(trimmedNewText.length / 4));
        } else { // 'text' 或 'html'
            message.content = trimmedNewText;
        }

        // 5. 保存修改到数据库，并刷新聊天界面
        await kokoMemory.put('contacts', contact);
        await openChat(state.activeChatId); // 重新渲染聊天，让修改生效
    }
}
/**
 * 渲染API预设下拉菜单
 */
async function renderApiPresetDropdown() {
    const selectEl = document.getElementById('api-preset-select');
    selectEl.innerHTML = '<option value="">-- 手动配置或选择预设 --</option>'; // 重置
    state.apiPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        selectEl.appendChild(option);
    });
}

/**
 * 显示API预设管理页面
 */
async function showApiPresetManagementScreen() {
    hideAllScreens();
    document.getElementById('api-preset-management-screen').style.display = 'flex';
    await renderApiPresetsList();
}

/**
 * 渲染API预设管理列表
 */
async function renderApiPresetsList() {
    const listEl = document.getElementById('api-presets-list');
    const noPresetMsg = document.getElementById('no-api-preset-message');
    listEl.innerHTML = '';

    if (state.apiPresets.length === 0) {
        noPresetMsg.style.display = 'block';
    } else {
        noPresetMsg.style.display = 'none';
        state.apiPresets.forEach(preset => {
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.presetId = preset.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${preset.name}</div>
                    <div class="preset-desc" style="font-size: 12px; color: #888;">
                        Endpoint: ${preset.endpoint || '未设置'}
                    </div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn delete delete-api-preset-btn" title="删除预设">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
            listEl.appendChild(item);
        });
    }

    // 为所有删除按钮绑定事件
    listEl.querySelectorAll('.delete-api-preset-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
            e.stopPropagation();
            const presetId = e.currentTarget.closest('.preset-item').dataset.presetId;
            const confirmed = await showCustomConfirm('删除预设', '确定要删除这个API预设吗？', true);
            if (confirmed) {
                state.apiPresets = state.apiPresets.filter(p => p.id !== presetId);
                await kokoMemory.delete('apiPresets', presetId);
                await renderApiPresetsList(); // 重新渲染列表
            }
        });
    });
}
// --- 新增：回溯功能核心函数 ---
async function handleRewind() {
    if (!state.activeChatId) return;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history || contact.history.length === 0) return;

    // 1. 从后往前，找到你（用户）发送的最后一条消息的索引
    let lastUserMessageIndex = -1;
    for (let i = contact.history.length - 1; i >= 0; i--) {
        if (contact.history[i].sender === 'user') {
            lastUserMessageIndex = i;
            break;
        }
    }

    // 2. 处理边界情况
    if (lastUserMessageIndex === -1) {
        alert("聊天记录中没有你的消息，无法回溯。");
        return;
    }

    // 如果最后一条消息就是用户发的，说明AI还没回复，也无需回溯
    if (lastUserMessageIndex === contact.history.length - 1) {
        alert("AI 还未回复，无需回溯。");
        return;
    }

    // 3. 弹窗向用户确认，防止误触
    const confirmed = await showCustomConfirm(
        '确认回溯',
        '这将清除AI的最后一次回复，并让它重新生成一次。确定要继续吗？',
        false // false 表示这不是一个危险的红色按钮
    );

    if (confirmed) {
        // 4. 截取历史记录，保留到用户最后一条消息
        contact.history = contact.history.slice(0, lastUserMessageIndex + 1);

        // 5. 保存修改并刷新聊天界面
        await kokoMemory.put('contacts', contact);
        await openChat(contact.id); // 这会用截断后的历史记录重新渲染聊天界面

        // 6. 重新请求AI回复
        await requestAiReply();
    }
}
// --- 新增：手动总结聊天记录功能核心函数 ---
async function handleChatSummarization() {
    if (!state.activeChatId) return;
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history || contact.history.length === 0) {
        return alert('当前没有聊天记录可供总结。');
    }

    // 1. 查找上一次总结的位置 (方案B)
    const SUMMARY_MARKER_PREFIX = '--- 之前的记录已于';
    const lastMarkerIndex = contact.history.findLastIndex(msg =>
        msg.type === 'system_notification' && msg.content.startsWith(SUMMARY_MARKER_PREFIX)
    );

    const startIndex = lastMarkerIndex === -1 ? 0 : lastMarkerIndex + 1;
    const messagesToSummarize = contact.history.slice(startIndex);

    if (messagesToSummarize.length < 5) { // 如果新消息太少，就不总结
        return alert('新的聊天记录太少，还不需要总结哦。');
    }

    // 2. 准备世界书和前情提要
    const bookName = `《聊天总结: ${contact.name}》`;
    const summaryBook = state.worldBooks.find(b => b.name === bookName);
    const previous_summary = summaryBook ? summaryBook.content : '(无前情提要)';

    // 3. 构建提示词 (Prompt)
    const chat_history_text = messagesToSummarize
        .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction') // 只总结文本消息
        .map(msg => `${msg.sender === 'user' ? state.myProfile.name : contact.name}: ${msg.content}`)
        .join('\n');

    const prompt = `[SYSTEM]
你的任务是扮演一位专业的叙事总结师。你的目标是客观、精炼地将下方提供的聊天记录，整理成一段连贯的、以第三人称视角叙述的“故事摘要”。

# 背景信息
- 用户名: ${state.myProfile.name}
- 角色名: ${contact.name}
- 前情提要 (上次总结的内容): 
${previous_summary}

# 聊天记录
以下是自上次总结以来，${state.myProfile.name} 与 ${contact.name} 之间发生的对话：
---
${chat_history_text}
---

# 你的任务
请仔细阅读上述聊天记录，并遵循以下要求，生成一段新的故事摘要：

1.  **核心事件提炼:** 识别并描述这段对话中发生的关键事件、转折点或重要行动。
2.  **情感与关系变化:** 捕捉并记录双方情绪上的主要变化、关系的进展（如变得更亲密、产生误会、关系紧张等）。
3.  **关键信息与设定:** 记录任何新出现的、对未来故事重要的信息、设定、约定或秘密。
4.  **叙事风格:** 必须使用第三人称、过去时进行叙述。文笔风格请参考细腻的女性向文学作品。
5.  **保持客观:** 只总结聊天记录中明确发生或提到的事，不要进行过度的猜测或主观臆断。
6.  **忽略不重要的内容:** 省略日常的问候（如“你好”、“在吗”）、无意义的闲聊和重复信息。

# 输出格式
请直接输出总结好的故事摘要文本，不要添加任何额外的解释或标题。`;

    // 4. 调用AI并处理结果
    const chatStatusEl = document.getElementById('chat-contact-status');
    const originalStatus = chatStatusEl.textContent;
    chatStatusEl.textContent = 'AI 正在总结中...';

    try {
        const summaryText = await generateAiResponse(contact, [], prompt, false, 'chat');
        
        // 5. 将总结存入世界书
        const summaryDate = new Date().toLocaleString('zh-CN', { hour12: false });
        const newSummaryEntry = `\n\n--- 总结于 ${summaryDate} ---\n${summaryText}`;

        if (summaryBook) {
            // 如果已存在，则追加内容
            summaryBook.content += newSummaryEntry;
            await kokoMemory.put('worldBooks', summaryBook);
        } else {
            // 如果不存在，则新建
            const newBook = {
                id: 'summary_book_' + contact.id, // 使用联系人ID确保唯一性
                name: bookName,
                content: newSummaryEntry.trim()
            };
            state.worldBooks.push(newBook);
            await kokoMemory.put('worldBooks', newBook);
            // 需要更新所有用到世界书的下拉选择器
            await updateWorldBookSelectors();
        }

        // 6. 在聊天记录中添加标记
        await createSystemNotification(`${SUMMARY_MARKER_PREFIX} ${summaryDate} ---`);

        alert(`聊天记录已成功总结，并存入世界书 ${bookName}！`);

    } catch (error) {
        console.error("聊天总结失败:", error);
        alert(`总结失败: ${error.message}`);
    } finally {
        chatStatusEl.textContent = originalStatus;
    }
}
// ==========================================================
// =========== ▼▼▼ 论坛档案馆 - 核心功能函数 ▼▼▼ ============
// ==========================================================

// 函数：显示论坛档案馆页面
async function showForumArchivesScreen() {
    hideAllScreens();
    document.getElementById('forum-archives-screen').style.display = 'flex';
    await renderForumArchivesList();
}

// 函数：渲染存档列表
async function renderForumArchivesList() {
    const listEl = document.getElementById('forum-archives-list');
    const noArchivesMsg = document.getElementById('no-forum-archives-message');
    listEl.innerHTML = '';

    // 始终在列表顶部显示“默认世界”
    const defaultArchiveItem = document.createElement('div');
    defaultArchiveItem.className = 'preset-item';
    defaultArchiveItem.dataset.archiveId = 'default';
    const isDefaultActive = state.activeForumArchiveId === 'default';
    defaultArchiveItem.innerHTML = `
        <div class="preset-info">
            <div class="preset-name">默认世界 (当前)</div>
            <div class="preset-desc">未存档的即时世界线</div>
        </div>
        <div class="preset-actions">
            <span class="preset-action-btn switch-archive-btn ${isDefaultActive ? 'active' : ''}" title="切换到此世界线">
                <i class="fas fa-power-off"></i>
            </span>
        </div>`;
    listEl.appendChild(defaultArchiveItem);

    // 渲染其他已保存的存档
    if (state.forumArchives.length === 0) {
        noArchivesMsg.style.display = 'block';
    } else {
        noArchivesMsg.style.display = 'none';
        state.forumArchives.forEach(archive => {
            const isActive = state.activeForumArchiveId === archive.id;
            const item = document.createElement('div');
            item.className = 'preset-item';
            item.dataset.archiveId = archive.id;
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${archive.name}</div>
                    <div class="preset-desc">${new Date(archive.timestamp).toLocaleString()} 存档</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn switch-archive-btn ${isActive ? 'active' : ''}" title="切换到此世界线">
                        <i class="fas fa-power-off"></i>
                    </span>
                    <span class="preset-action-btn delete delete-archive-btn" title="删除此存档">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>`;
            listEl.appendChild(item);
        });
    }
}

// 函数：切换活动的世界线 (V4 - 持久化选择版)
async function switchForumArchive(archiveId) {
    if (state.activeForumArchiveId === archiveId) return; 

    let settingsToRestore;
    let archiveName;

    if (archiveId === 'default') {
        settingsToRestore = await kokoMemory.get('forumSettings', 'main');
        if (!settingsToRestore) {
            settingsToRestore = JSON.parse(JSON.stringify(INITIAL_STATE.forumSettings));
        }
        archiveName = '默认世界';
    } else {
        const archive = state.forumArchives.find(a => a.id === archiveId);
        if (!archive || !archive.settings) {
            alert('错误：找不到该存档或存档数据已损坏。');
            return;
        }
        settingsToRestore = archive.settings;
        archiveName = archive.name;
    }

    state.forumSettings = Object.assign({}, state.forumSettings, settingsToRestore);
    await kokoMemory.put('forumSettings', { id: 'main', ...state.forumSettings });

    // 更新 state，标记当前激活的世界线ID
    state.activeForumArchiveId = archiveId;

    // 【核心修复 - 第1部分：保存选择】
    // 将当前激活的存档ID保存到 userSettings 表中，实现持久化
    const settings = await kokoMemory.get('userSettings', 'main') || { id: 'main' };
    settings.activeForumArchiveId = archiveId;
    await kokoMemory.put('userSettings', settings);
    
    // 重置论坛的标签页状态到默认值
    state.activeFeedTab = 'recommended';
    state.activeFeedSubTab = 'daily';

    await renderForumArchivesList();
    alert(`已成功切换到世界线: ${archiveName}。\n\n相关的论坛设定（用户面具、世界书等）已同步更新。`);
}

// 函数：删除一个存档及其所有相关帖子
async function deleteForumArchive(archiveId) {
    const archive = state.forumArchives.find(a => a.id === archiveId);
    if (!archive) return;

    const confirmed = await showCustomConfirm(
        '删除确认',
        `⚠️ 确定要永久删除存档“${archive.name}”吗？\n\n这将同时删除该世界线下的【所有帖子】，此操作无法恢复！`,
        true
    );

    if (confirmed) {
        // 1. 从 state 中删除存档
        state.forumArchives = state.forumArchives.filter(a => a.id !== archiveId);
        // 2. 从数据库中删除存档
        await kokoMemory.delete('forumArchives', archiveId);

        // 3. 从 state 中删除与该存档关联的所有帖子
        state.posts = state.posts.filter(p => p.archiveId !== archiveId);
        // 4. 从数据库中删除这些帖子 (这是一个批量删除操作)
        const allPosts = await kokoMemory.getAll('posts');
        const postsToDelete = allPosts.filter(p => p.archiveId === archiveId);
        for (const post of postsToDelete) {
            await kokoMemory.delete('posts', post.id);
        }

        // 5. 如果被删除的是当前激活的存档，则自动切换回默认世界
        if (state.activeForumArchiveId === archiveId) {
            state.activeForumArchiveId = 'default';
        }

        // 6. 重新渲染存档列表
        await renderForumArchivesList();
    }
}

// ==========================================================
// --- 音乐分享弹窗 - 核心分享逻辑 ---
async function shareSongToChat(songData) {
    if (!songData || !songData.url || !songData.title) {
        alert('分享失败：歌曲信息不完整。');
        return;
    }

    // 1. 发送音乐卡片消息
    await createAndAddMessage({ type: 'music_share', content: songData });

    // 2. 根据复选框决定是否通知AI
    if (document.getElementById('notify-ai-checkbox').checked) {
        const systemPrompt = `[SYSTEM: 用户分享了一首歌曲《${songData.title}》，来自${songData.artist || '未知艺术家'}。请你发表一下你的感想。]`;
        await requestAiReply(systemPrompt);
    }

    // 3. 关闭弹窗
    document.getElementById('send-music-modal').style.display = 'none';
    alert(`歌曲《${songData.title}》分享成功！`);
}

// --- 音乐分享弹窗 - 标签页切换 ---
function switchMusicShareTab(tabName) {
    // 切换按钮的激活状态
    document.querySelectorAll('#music-share-tabs .feed-tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
    });
    // 切换内容的显示/隐藏
    document.querySelectorAll('#music-share-tab-content > div').forEach(content => {
        content.style.display = content.id === `music-tab-${tabName}` ? 'block' : 'none';
    });
}

// --- 音乐分享弹窗 - 渲染“从曲库选择”面板 ---
function renderMusicPickerInShareModal() {
    const container = document.getElementById('music-tab-library');
    container.innerHTML = '';

    if (state.musicLibrary.length === 0) {
        container.innerHTML = '<p style="text-align: center; color: #888;">你的音乐库是空的，可以先去“发现”页面添加哦。</p>';
        return;
    }

    state.musicLibrary.forEach(song => {
        const item = document.createElement('div');
        item.className = 'discover-item';
        item.style.cursor = 'pointer';
        item.style.marginBottom = '8px';
        item.innerHTML = `
            <div class="discover-icon"><i class="fas fa-music"></i></div>
            <div class="discover-info">
                <div class="discover-name">${song.title}</div>
                <div class="discover-desc">${song.artist}</div>
            </div>
        `;
        // 点击后直接调用核心分享函数
        item.addEventListener('click', () => shareSongToChat(song));
        container.appendChild(item);
    });
}

// ==========================================================
// --- 音乐分享弹窗 - V5.0 vkeys.cn 网易云官方文档版 ---
// ==========================================================
/**
 * 函数1：使用 vkeys.cn 的网易云接口进行在线搜索
 */
async function searchMusicInModal() {
    const keyword = document.getElementById('online-music-search-input').value.trim();
    if (!keyword) return;

    const resultsContainer = document.getElementById('online-music-search-results');
    resultsContainer.innerHTML = '<p style="color: #888; text-align: center;">正在搜索...</p>';

    try {
        // --- 核心修改：更换为文档中指定的网易云API地址，并且不再需要中转站 ---
        const apiUrl = `https://api.vkeys.cn/v2/music/netease?word=${encodeURIComponent(keyword)}`;
        
        const response = await fetch(apiUrl);

        if (!response.ok) throw new Error(`网络请求失败，状态码: ${response.status}`);
        
        const result = await response.json();
        
        // --- 核心修改：根据新API的文档结构来解析 ---
        if (result.code === 200 && Array.isArray(result.data) && result.data.length > 0) {
            resultsContainer.innerHTML = '';
            result.data.forEach(song => {
                const item = document.createElement('div');
                item.className = 'discover-item';
                item.style.cursor = 'pointer';
                item.style.marginBottom = '8px';
                
                // 新API的字段是 song, singer, cover
                item.innerHTML = `
                    <div class="discover-icon"><img src="${song.cover}" style="width:100%; height:100%; border-radius: 6px;"></div>
                    <div class="discover-info">
                        <div class="discover-name">${song.song}</div>
                        <div class="discover-desc">${song.singer}</div>
                    </div>
                `;
                // 把歌曲的 id, song, singer 传给下一步
                item.addEventListener('click', () => getDetailsAndShare(song.id, song.song, song.singer));
                resultsContainer.appendChild(item);
            });
        } else {
            resultsContainer.innerHTML = '<p style="color: #888; text-align: center;">未找到相关歌曲。</p>';
        }
    } catch (error) {
        console.error('搜索音乐失败:', error);
        let errorMessage = `搜索失败: ${error.message}`;
        if (error.name === 'TypeError') { // 这是 fetch 失败时最常见的错误类型
            errorMessage = '网络连接失败，请检查你的网络或VPN设置。';
        } else if (error instanceof SyntaxError) { // JSON.parse 失败
            errorMessage = '搜索失败：API返回的数据格式不正确，可能是接口暂时失效了。';
        }
        resultsContainer.innerHTML = `<p style="color: var(--soft-red); text-align: center;">${errorMessage}</p>`;
    }
}
// ==========================================================
// --- 音乐分享弹窗 - V7.0 最终极简高效版 ---
// ==========================================================
// ==========================================================
// --- 音乐分享弹窗 - V9.0 最终极简高效版 (听宝宝的！) ---
// ==========================================================
// ==========================================================
// --- 音乐分享弹窗 - V11.0 “自动输入”魔法版 (听宝宝的！) ---
// ==========================================================
// ==========================================================
// --- 音乐分享弹窗 - V13.0 调试专用版 (听宝宝的！) ---
// ==========================================================
/**
 * 核心逻辑：获取所有信息后，不分享，而是通过 alert() 展示出来
 */
async function getDetailsAndShare(songId, title, singer) {
    const resultsContainer = document.getElementById('online-music-search-results');
    resultsContainer.innerHTML = `<p style="color: #888; text-align: center;">正在获取歌曲信息，准备展示给你...</p>`;

    try {
        // --- 第1步：获取播放URL和歌词 (这部分逻辑不变) ---
        const urlApi = `https://api.vkeys.cn/v2/music/netease?id=${songId}`;
        const lyricApi = `https://api.vkeys.cn/v2/music/lyric?id=${songId}`; 

        const [urlResponse, lyricResponse] = await Promise.all([
            fetch(urlApi),
            fetch(lyricApi)
        ]);

        if (!urlResponse.ok || !lyricResponse.ok) throw new Error('获取歌曲详情的网络请求失败');

        const urlResult = await urlResponse.json();
        const lyricResult = await lyricResponse.json();

        if (urlResult.code !== 200 || !urlResult.data || !urlResult.data.url) {
            throw new Error('抱歉，这首歌可能因为版权问题无法播放 T_T');
        }
        
        const playUrl = urlResult.data.url;
        let finalLrc = (lyricResult.code === 200 && lyricResult.data && lyricResult.data.lrc) ? lyricResult.data.lrc.replace(/\\n/g, '\n') : `[00:00.00]${title}\n[00:05.00](暂无歌词)`;
        
        // --- 第2步：【核心魔法】我们不再分享，而是把拿到的数据显示给你看！---
        
        // 准备要显示给你的文本
        const alertText = `
            宝宝，这是我刚刚拿到的四个数据，你看一下对不对：

            【歌名】: ${title}

            【歌手】: ${singer}

            【URL】: ${playUrl}

            【歌词】: ${finalLrc.substring(0, 100)}... (只显示前100个字符)
        `;

        // 用弹窗把所有信息展示给你
        alert(alertText);

        // 我们暂时不执行分享操作了，让你先检查
        // shareSongToChat(songData);

        // 成功获取后，把提示信息改掉
        resultsContainer.innerHTML = `<p style="color: green; text-align: center;">数据已获取并显示给你啦！请查看弹窗。</p>`;


    } catch (error) {
        console.error('在线搜索并分享音乐失败:', error);
        resultsContainer.innerHTML = `<p style="color: var(--soft-red); text-align: center;">获取信息失败: ${error.message}</p>`;
    }
}
// =========== ▲▲▲ 论坛档案馆 - 核心功能函数 END ▲▲▲ =========
// ==========================================================
// ==========================================================
// V-Final 新增: 锁屏功能逻辑
// ==========================================================
let lockScreenClockInterval = null; // 用于存放时钟的定时器
let photoCarouselInterval = null;   // ▼▼▼ 新增下面这两行 ▼▼▼
let currentPhotoIndex = 0;
let inactivityTimer = null;
/**
 * 更新锁屏上的时间和日期
 */
function updateLockScreenTime() {
    const timeEl = document.getElementById('lock-screen-time');
    const dateEl = document.getElementById('lock-screen-date');
    if (!timeEl || !dateEl) return;

    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    const dayNames = ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'];
    
    timeEl.textContent = `${hours}:${minutes}`;
    dateEl.textContent = `${now.getMonth() + 1}月${now.getDate()}日 ${dayNames[now.getDay()]}`;
}
// ==========================================================
// V-Final 新增: 锁屏组件内容更新函数
// ==========================================================
async function updateLockScreenWidgets() {
    // 1. 读取并显示备忘录
    const memoEl = document.getElementById('lock-screen-memo');
    if (!window.userSettings) window.userSettings = { id: 'main' }; 
    if (userSettings.lockScreenMemo) { memoEl.textContent = userSettings.lockScreenMemo; } 
    else { memoEl.textContent = '点击这里编辑你的备忘录...'; }

    // 2. 处理置顶纪念日/倒数日
    const countdownDaysEl = document.querySelector('#lock-screen-countdown .countdown-days');
    const countdownLabelEl = document.querySelector('#lock-screen-countdown .countdown-label');
    let pinnedEvent = null;
    for (const contact of state.contacts) {
        if (contact.events && contact.events.length > 0) {
            const foundEvent = contact.events.find(event => event.isPinned);
            if (foundEvent) { pinnedEvent = foundEvent; break; }
        }
    }
    if (pinnedEvent) {
        const today = new Date(); today.setHours(0, 0, 0, 0);
        const eventDate = new Date(pinnedEvent.date); eventDate.setHours(0, 0, 0, 0);
        const diff = (eventDate - today) / (1000 * 60 * 60 * 24);
        countdownDaysEl.textContent = Math.round(Math.abs(diff));
        if (diff >= 0) { countdownLabelEl.textContent = `距离 ${pinnedEvent.eventName} 还有`; } 
        else { countdownLabelEl.textContent = `${pinnedEvent.eventName} 已经`; }
    } else {
        countdownDaysEl.textContent = 'Pin!';
        countdownLabelEl.textContent = "去“我们的日子”置顶一个纪念日吧";
    }

    // 3. 处理所有未读消息
    const notificationWidget = document.getElementById('lock-screen-notification-widget');
    const notificationTextEl = document.getElementById('lock-screen-notification-text');
    let allUnreadMessages = [];
    state.contacts.forEach(contact => {
        if (contact.unreadCount > 0 && contact.history.length > 0) {
            const unreadMessages = contact.history.slice(-contact.unreadCount);
            unreadMessages.forEach(msg => {
                let contentPreview = msg.content;
                switch (msg.type) {
                    case 'image': case 'picture_description': contentPreview = '[图片]'; break;
                    case 'voice': contentPreview = '[语音消息]'; break;
                    case 'red_packet': contentPreview = `[红包] ${msg.content.blessing}`; break;
                }
                allUnreadMessages.push({
                    timestamp: msg.timestamp,
                    text: `<div>${contact.name}: ${contentPreview}</div>`
                });
            });
        }
    });
    if (allUnreadMessages.length > 0) {
        allUnreadMessages.sort((a, b) => a.timestamp - b.timestamp);
        const fullNotificationHTML = allUnreadMessages.map(msg => msg.text).join('');
        notificationTextEl.innerHTML = fullNotificationHTML;
        notificationWidget.style.display = 'flex';
        const animationDuration = Math.max(8, allUnreadMessages.length * 4);
        notificationTextEl.style.animationDuration = `${animationDuration}s`;
    } else {
        notificationWidget.style.display = 'none';
    }
}

/**
 * 显示锁屏界面 (V10 - 重构版)
 */
async function showLockScreen() {
    if (inactivityTimer) { clearTimeout(inactivityTimer); inactivityTimer = null; }

    const lockScreenEl = document.getElementById('lock-screen');
    const backgroundEl = document.querySelector('.lock-screen-background');

    // 设置智能背景
    let backgroundUrl = 'https://i.postimg.cc/SQ3DH79X/MEITU-20250811-151831796.jpg';
    if (userSettings && userSettings.chatBackground) { backgroundUrl = userSettings.chatBackground; }
    const lastContact = state.contacts.find(c => c.id === state.activeChatId);
    if (lastContact && lastContact.customChatBackground) { backgroundUrl = lastContact.customChatBackground; }
    backgroundEl.style.backgroundImage = `url(${backgroundUrl})`;

    // ▼▼▼ 核心改动：直接调用我们的新函数来更新所有组件 ▼▼▼
    await updateLockScreenWidgets();
    // ▲▲▲ 改动结束 ▲▲▲

    // 显示锁屏和启动其他功能 (不变)
    lockScreenEl.style.display = 'flex';
    setTimeout(() => { lockScreenEl.classList.remove('hidden'); }, 10);
    if (!lockScreenClockInterval) {
        updateLockScreenTime();
        lockScreenClockInterval = setInterval(updateLockScreenTime, 1000);
    }
    startPhotoCarousel();
}

/**
 * 隐藏锁屏界面
 */
function hideLockScreen() {
    const lockScreenEl = document.getElementById('lock-screen');
    lockScreenEl.classList.add('hidden');

    // ▼▼▼ 在这里添加新代码 ▼▼▼
    // 停止照片轮播的定时器
    if (photoCarouselInterval) {
        clearInterval(photoCarouselInterval);
        photoCarouselInterval = null;
    }
    // ▲▲▲ 新增结束 ▲▲▲

    setTimeout(() => {
        lockScreenEl.style.display = 'none';
    }, 500);
    // ▼▼▼ 新增：解锁后，开始无活动计时 ▼▼▼
    resetInactivityTimer();
    // ▲▲▲ 新增结束 ▲▲▲
}

// 为锁屏界面绑定“解锁”事件 (V2 - 备忘录兼容版)
document.getElementById('lock-screen').addEventListener('click', (e) => {
    // 如果我们点击的目标是正在编辑的备忘录输入框，则不执行解锁操作
    if (e.target.id === 'memo-edit-textarea') {
        return;
    }
    hideLockScreen();
});
// ==========================================================
// ==========================================================
// V-Final 新增: 锁屏备忘录编辑功能
// ==========================================================
const memoContainer = document.getElementById('lock-screen-memo');

memoContainer.addEventListener('click', function(event) {
    // 阻止点击事件冒泡，防止点击备忘录时直接解锁屏幕
    event.stopPropagation();

    // 如果当前已经是编辑模式，就什么都不做
    if (document.getElementById('memo-edit-textarea')) {
        return;
    }

    const currentText = memoContainer.textContent;
    
    // 创建一个textarea输入框
    const textarea = document.createElement('textarea');
    textarea.id = 'memo-edit-textarea';
    textarea.value = (currentText === '点击这里编辑你的备忘录...') ? '' : currentText;
    
    // 应用一些和显示文本差不多的样式
    textarea.style.cssText = `
        width: 100%;
        height: 100%;
        border: none;
        background-color: transparent;
        color: white;
        font-family: inherit;
        font-size: 15px;
        line-height: 1.6;
        resize: none;
        outline: none;
        padding: 0;
        margin: 0;
    `;

    // 替换显示区域为输入框
    memoContainer.innerHTML = '';
    memoContainer.appendChild(textarea);
    textarea.focus(); // 自动聚焦，让用户可以直接输入

    // 当输入框失去焦点时 (例如点击了其他地方)，就保存并切换回显示模式
    textarea.addEventListener('blur', async function() {
        const newText = textarea.value.trim();
        
        // 更新并保存备忘录内容
        userSettings.lockScreenMemo = newText;
        await kokoMemory.put('userSettings', userSettings);

        // 切换回文本显示模式
        memoContainer.innerHTML = ''; // 先清空
        if (newText) {
            memoContainer.textContent = newText;
        } else {
            memoContainer.textContent = '点击这里编辑你的备忘录...';
        }
    });
});
// ==========================================================
// V-Final 新增: 锁屏相册功能逻辑
// ==========================================================

// 函数：显示锁屏相册管理页面
async function showLockScreenPhotosScreen() {
    hideAllScreens();
    document.getElementById('lock-screen-photos-screen').style.display = 'flex';
    await renderLockScreenPhotos();
}

// 函数：渲染相册中的所有照片
async function renderLockScreenPhotos() {
    const grid = document.getElementById('lock-screen-photos-grid');
    const noPhotosMsg = document.getElementById('no-lock-screen-photos-message');
    grid.innerHTML = '';

    const photos = await kokoMemory.getAll('lockScreenPhotos');

    if (photos.length === 0) {
        noPhotosMsg.style.display = 'block';
    } else {
        noPhotosMsg.style.display = 'none';
        photos.forEach(photo => {
            const item = document.createElement('div');
            item.className = 'emoticon-item'; // 复用表情包的样式
            item.innerHTML = `
                <img src="${photo.base64}" alt="锁屏照片">
                <button class="emoticon-delete-btn" data-photo-id="${photo.id}">&times;</button>
            `;
            grid.appendChild(item);
        });
    }
}
// ==========================================================
// V-Final 新增: 锁屏照片轮播核心功能
// ==========================================================
async function startPhotoCarousel() {
    const photoBlock = document.querySelector('.lock-block.photo-block');
    if (!photoBlock) return;

    // 1. 从数据库读取所有照片
    const photos = await kokoMemory.getAll('lockScreenPhotos');

    // 2. 如果相册是空的，就什么都不做，显示默认的占位符
    if (!photos || photos.length === 0) {
        photoBlock.innerHTML = '<div class="placeholder-text"><i class="fas fa-images"></i><p>去锁屏相册添加照片</p></div>';
        return;
    }

    // 3. 如果有照片，就清空占位符，准备开始轮播
    photoBlock.innerHTML = ''; 
    currentPhotoIndex = 0; // 每次都从第一张开始

    // 4. 定义一个切换图片的函数
    const changePhoto = () => {
        // 计算下一张照片的索引，如果到了最后一张，就循环回第一张
        currentPhotoIndex = (currentPhotoIndex + 1) % photos.length;
        // 设置背景图
        photoBlock.style.backgroundImage = `url(${photos[currentPhotoIndex].base64})`;
    };

    // 5. 立刻显示第一张照片
    photoBlock.style.backgroundImage = `url(${photos[0].base64})`;

    // 6. 启动定时器，每5秒切换一次照片
    // (如果之前有定时器在跑，先清除掉)
    if (photoCarouselInterval) clearInterval(photoCarouselInterval);
    photoCarouselInterval = setInterval(changePhoto, 5000); // 5000毫秒 = 5秒
}
// ==========================================================
// V-Final 新增: 自动锁屏计时器逻辑
// ==========================================================
let autoLockDelay = 0; // 默认禁用

// 函数：重置并启动计时器
function resetInactivityTimer() {
    // 先清除上一个计时器
    if (inactivityTimer) {
        clearTimeout(inactivityTimer);
    }
    // 如果设置的延迟大于0，则启动一个新的计时器
    if (autoLockDelay > 0) {
        inactivityTimer = setTimeout(() => {
            // 时间到了，就显示锁屏
            showLockScreen();
        }, autoLockDelay * 1000); // 将秒转换为毫秒
    }
}

// 监听用户的各种操作事件，只要有操作，就重置计时器
window.addEventListener('mousemove', resetInactivityTimer);
window.addEventListener('mousedown', resetInactivityTimer);
window.addEventListener('keypress', resetInactivityTimer);
window.addEventListener('touchstart', resetInactivityTimer);
// ==========================================================
// =========== ▼▼▼ 地图功能核心逻辑 (V2 多地图版) ▼▼▼ ========
// ==========================================================
let currentMapData = null; // 用于存储当前正在编辑的地图数据
let editingLocationId = null;
let editingMapId = null;

// 函数：显示地图管理中心
async function showMapManagementScreen() {
    hideAllScreens();
    document.getElementById('map-management-screen').style.display = 'flex';
    await renderMapList();
}

// 函数：渲染地图管理列表
async function renderMapList() {
    const maps = await kokoMemory.getAll('maps');
    const listEl = document.getElementById('map-list');
    listEl.innerHTML = '';

    if (maps.length === 0) {
        listEl.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><p>还没有创建任何地图。</p><p>点击右上角“+”来创建你的第一个世界吧！</p></div>`;
        return;
    }

    maps.forEach(map => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        item.dataset.mapId = map.id;
        item.innerHTML = `
            <div class="preset-info">
                <div class="preset-name">${map.name}</div>
                <div class="preset-desc">${map.description ? map.description.substring(0, 50) + '...' : '暂无描述'}</div>
            </div>
            <div class="preset-actions">
                <span class="preset-action-btn edit-map-btn" title="编辑地图宏观信息"><i class="fas fa-edit"></i></span>
                <span class="preset-action-btn delete delete-map-btn" title="删除地图"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        // 点击整个条目进入地图编辑器
        item.querySelector('.preset-info').addEventListener('click', () => openMapScreen(map.id));
        listEl.appendChild(item);
    });
}

// 函数：打开并渲染指定的地图编辑器
async function openMapScreen(mapId) {
    const mapData = await kokoMemory.get('maps', mapId);
    if (!mapData) {
        alert('找不到地图数据！');
        return;
    }
    currentMapData = mapData;

    hideAllScreens();
    document.getElementById('map-screen').style.display = 'flex';
    document.getElementById('map-title').textContent = currentMapData.name;

    renderMapIcons();
}

// 函数：在地图上渲染所有地点图标
function renderMapIcons() {
    const container = document.getElementById('map-grid-container');
    container.innerHTML = ''; // 清空旧图标

    if (currentMapData && currentMapData.locations) {
        currentMapData.locations.forEach(loc => {
            const iconEl = document.createElement('div');
            iconEl.className = 'map-icon';
            iconEl.dataset.locationId = loc.id;
            iconEl.classList.add('tier-' + (loc.tier || 2)); // 如果旧数据没有tier，默认为2级
            iconEl.style.left = `${loc.x}px`;
            iconEl.style.top = `${loc.y}px`;
            iconEl.style.color = loc.color || '#333';
            iconEl.innerHTML = `
                <i class="${loc.icon || 'fas fa-map-marker-alt'}"></i>
                <span class="map-icon-label">${loc.name}</span>
            `;
            container.appendChild(iconEl);
        });
    }
}

// 函数：打开地点编辑/添加弹窗
function openLocationModal(config) {
    const modal = document.getElementById('map-location-modal');
    const titleEl = document.getElementById('map-location-modal-title');
    const deleteBtn = document.getElementById('delete-map-location-btn');

    document.getElementById('location-id-input').value = '';
    document.getElementById('location-name-input').value = '';
    document.getElementById('location-icon-input').value = 'fas fa-map-marker-alt';
    document.getElementById('location-description-input').value = '';

    if (config.isEditing) {
        titleEl.textContent = '编辑地点';
        editingLocationId = config.location.id;
        document.getElementById('location-id-input').value = config.location.id;
        document.getElementById('location-x-input').value = config.location.x;
        document.getElementById('location-y-input').value = config.location.y;
        document.getElementById('location-name-input').value = config.location.name;
        document.getElementById('location-icon-input').value = config.location.icon;
        document.getElementById('location-description-input').value = config.location.description;
        document.getElementById('location-tier-input').value = config.location.tier || 2; // 如果旧数据没有tier，则默认为2级
        deleteBtn.style.display = 'block';
    } else {
        titleEl.textContent = '在地图上添加新地点';
        editingLocationId = null;
        document.getElementById('location-x-input').value = config.x;
        document.getElementById('location-y-input').value = config.y;
        deleteBtn.style.display = 'none';
        document.getElementById('location-tier-input').value = 2;
    }
    modal.style.display = 'flex';
}

// 函数：打开地图宏观信息编辑弹窗
function openMapDetailsModal(map = null) {
    const modal = document.getElementById('map-details-modal');
    if (map) {
        // 编辑模式
        editingMapId = map.id;
        document.getElementById('map-details-modal-title').textContent = '编辑地图信息';
        document.getElementById('map-id-input').value = map.id;
        document.getElementById('map-name-input').value = map.name;
        document.getElementById('map-description-input').value = map.description || '';
    } else {
        // 创建模式
        editingMapId = null;
        document.getElementById('map-details-modal-title').textContent = '创建新地图';
        document.getElementById('map-id-input').value = '';
        document.getElementById('map-name-input').value = '';
        document.getElementById('map-description-input').value = '';
    }
    modal.style.display = 'flex';
}

// 函数：更新联系人设置里的地图下拉菜单
async function updateContactMapSelector() {
    const maps = await kokoMemory.getAll('maps');
    const selectEl = document.getElementById('contact-map-select');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!selectEl || !contact) return;

    selectEl.innerHTML = '<option value="">-- 不关联任何地图 --</option>';
    maps.forEach(map => {
        const option = document.createElement('option');
        option.value = map.id;
        option.textContent = map.name;
        if (contact.mapId === map.id) {
            option.selected = true;
        }
        selectEl.appendChild(option);
    });
}
async function openLocationPicker(mapId) {
    const modal = document.getElementById('send-location-modal');
    const listEl = document.getElementById('location-picker-list');
    listEl.innerHTML = '<p>加载中...</p>'; // 提示用户正在加载

    const mapData = await kokoMemory.get('maps', mapId);

    if (!mapData || !mapData.locations || mapData.locations.length === 0) {
        listEl.innerHTML = '<p style="color: #888; text-align: center;">这张地图上还没有设定任何地点。</p>';
    } else {
        listEl.innerHTML = ''; // 清空加载提示
        mapData.locations.forEach(location => {
            const item = document.createElement('div');
            item.className = 'discover-item'; // 复用一个看起来不错的现有样式
            item.style.marginBottom = '8px';
            item.innerHTML = `
                <div class="discover-icon"><i class="${location.icon || 'fas fa-map-marker-alt'}"></i></div>
                <div class="discover-info">
                    <div class="discover-name">${location.name}</div>
                    <div class="discover-desc">${location.description.substring(0, 30)}...</div>
                </div>
            `;
            // 【核心】为每个地点条目绑定点击事件
            item.addEventListener('click', async () => {
                // 创建并发送位置消息
                await createAndAddMessage({
                    type: 'location_share',
                    content: {
                        mapId: mapId,
                        locationId: location.id,
                        name: location.name,
                        icon: location.icon,
                        x: location.x,
                        y: location.y
                    }
                });
                modal.style.display = 'none'; // 发送后关闭弹窗
            });
            listEl.appendChild(item);
        });
    }

    modal.style.display = 'flex';
    // 绑定关闭按钮
    document.getElementById('close-location-picker-modal').addEventListener('click', () => {
        modal.style.display = 'none';
    }, { once: true });
}
// ▼▼▼ 把下面所有新函数，完整地粘贴到你的JS代码区 ▼▼▼

// --- V-新功能：日程与事件模块 ---

let editingScheduleId = null;
let editingEventId = null;

// 函数：显示课程表页面
function showScheduleScreen() {
    hideAllScreens();
    document.getElementById('schedule-screen').style.display = 'flex';
    renderSchedule();
}

// 函数：渲染课程表内容
function renderSchedule() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const container = document.getElementById('schedule-content-list');
    container.innerHTML = '';

    if (!contact || !contact.schedule || contact.schedule.length === 0) {
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-calendar-alt" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有添加任何课程安排。</p><p>点击右上角“+”来添加第一条记录吧！</p></div>`;
        return;
    }

    const days = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
    const dayNames = { monday: '星期一', tuesday: '星期二', wednesday: '星期三', thursday: '星期四', friday: '星期五', saturday: '星期六', sunday: '星期日' };

    days.forEach(day => {
        const itemsForDay = contact.schedule.filter(item => item.dayOfWeek === day).sort((a,b) => a.startTime.localeCompare(b.startTime));
        if (itemsForDay.length > 0) {
            const daySection = document.createElement('div');
            daySection.className = 'discover-section';
            daySection.style.marginBottom = '15px';
            
            let itemsHTML = itemsForDay.map(item => `
                <div class="discover-item" data-schedule-id="${item.id}" style="cursor:pointer;">
                    <div class="discover-icon" style="background-color:#e3f2fd; color:#42a5f5;"><i class="fas fa-book-open"></i></div>
                    <div class="discover-info">
                        <div class="discover-name">${item.startTime} - ${item.endTime}：${item.courseName}</div>
                        <div class="discover-desc">${item.location || '地点未定'}</div>
                    </div>
                </div>
            `).join('');

            daySection.innerHTML = `<div class="section-title" style="font-weight:bold; color:var(--text-dark);">${dayNames[day]}</div>${itemsHTML}`;
            container.appendChild(daySection);
        }
    });
}

// 函数：显示重要日子页面
function showEventsScreen() {
    hideAllScreens();
    document.getElementById('events-screen').style.display = 'flex';
    renderEvents();
}

// 函数：渲染重要日子内容 (V2 - 带置顶功能)
function renderEvents() {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    const container = document.getElementById('events-content-list');
    container.innerHTML = '';

    if (!contact || !contact.events || contact.events.length === 0) {
        container.innerHTML = `<div style="text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-heart" style="font-size: 48px; margin-bottom: 15px;"></i><p>还没有添加任何重要的日子。</p><p>点击右上角“+”来添加吧！</p></div>`;
        return;
    }

    const sortedEvents = [...contact.events].sort((a,b) => new Date(a.date) - new Date(b.date));
    
    const eventSection = document.createElement('div');
    eventSection.className = 'discover-section';
    
    // ▼▼▼ 核心改动在这里 ▼▼▼
    let itemsHTML = sortedEvents.map(event => {
        let icon = 'fa-star';
        let color = '#ffee58';
        if (event.type === 'anniversary') { icon = 'fa-gift'; color = '#ff8a80'; }
        if (event.type === 'period') { icon = 'fa-tint'; color = '#f06292'; }

        // 检查这个事件是否被置顶，并给按钮加上 'active' 样式
        const isActive = event.isPinned ? 'active' : '';

        return `
            <div class="discover-item" data-event-id="${event.id}">
                <div class="discover-icon" style="background-color:${color}20; color:${color};"><i class="fas ${icon}"></i></div>
                <div class="discover-info" style="cursor:pointer;">
                    <div class="discover-name">${event.date}：${event.eventName}</div>
                    <div class="discover-desc">${event.notes || '没有备注'}</div>
                </div>
                <button class="preset-action-btn pin-event-btn ${isActive}" data-event-id="${event.id}" title="在锁屏显示">
                    <i class="fas fa-thumbtack"></i>
                </button>
                <button class="preset-action-btn delete delete-event-btn" data-event-id="${event.id}" title="删除"><i class="fas fa-trash-alt"></i></button>
            </div>
        `;
    }).join('');
    // ▲▲▲ 改动结束 ▲▲▲

    eventSection.innerHTML = itemsHTML;
    container.appendChild(eventSection);
}
// 函数：打开课程编辑/添加弹窗
function openScheduleModal(scheduleItem = null) {
    const modal = document.getElementById('schedule-modal');
    if (scheduleItem) {
        // 编辑模式
        editingScheduleId = scheduleItem.id;
        document.getElementById('schedule-modal-title').textContent = '编辑课程';
        document.getElementById('schedule-item-id').value = scheduleItem.id;
        document.getElementById('schedule-name-input').value = scheduleItem.courseName;
        document.getElementById('schedule-day-select').value = scheduleItem.dayOfWeek;
        document.getElementById('schedule-start-input').value = scheduleItem.startTime;
        document.getElementById('schedule-end-input').value = scheduleItem.endTime;
        document.getElementById('schedule-location-input').value = scheduleItem.location;
    } else {
        // 添加模式
        editingScheduleId = null;
        document.getElementById('schedule-modal-title').textContent = '添加课程';
        document.getElementById('schedule-item-id').value = '';
        document.querySelector('#schedule-modal form')?.reset(); // 如果有form标签可以这么用，否则需要手动清空
    }
    modal.style.display = 'flex';
}

// 函数：打开事件编辑/添加弹窗
function openEventModal(eventItem = null) {
    const modal = document.getElementById('event-modal');
    if (eventItem) {
        // 编辑模式
        editingEventId = eventItem.id;
        document.getElementById('event-modal-title').textContent = '编辑重要日子';
        document.getElementById('event-item-id').value = eventItem.id;
        document.getElementById('event-name-input').value = eventItem.eventName;
        document.getElementById('event-date-input').value = eventItem.date;
        document.getElementById('event-type-select').value = eventItem.type;
        document.getElementById('event-notes-input').value = eventItem.notes;
    } else {
        // 添加模式
        editingEventId = null;
        document.getElementById('event-modal-title').textContent = '添加重要日子';
        document.getElementById('event-item-id').value = '';
         document.querySelector('#event-modal form')?.reset();
    }
    modal.style.display = 'flex';
}

// ▲▲▲ 把上面所有新函数，完整地粘贴到你的JS代码区 ▲▲▲
// ==========================================================
// =========== ▼▼▼ 新增：图片处理核心函数 ▼▼▼ ============
// ==========================================================
/**
 * 处理用户上传的图片文件，进行压缩并转换为Base64
 * @param {File} file - 用户选择的图片文件
 * @returns {Promise<string>} - 返回一个Promise，解析为压缩后的Base64字符串
 */
function handleImageUpload(file) {
    return new Promise((resolve, reject) => {
        const MAX_DIMENSION = 1024; // 设定图片最大尺寸为1024像素
        const reader = new FileReader();

        reader.onload = (event) => {
            const img = new Image();
            img.onload = () => {
                let { width, height } = img;

                // 如果图片尺寸大于最大值，则进行等比缩放
                if (width > MAX_DIMENSION || height > MAX_DIMENSION) {
                    if (width > height) {
                        height = Math.round((height * MAX_DIMENSION) / width);
                        width = MAX_DIMENSION;
                    } else {
                        width = Math.round((width * MAX_DIMENSION) / height);
                        height = MAX_DIMENSION;
                    }
                }

                // 使用 canvas 进行压缩
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);
                
                // 将压缩后的图片转换为Base64，这里使用JPEG格式并设置了压缩质量
                const compressedBase64 = canvas.toDataURL('image/jpeg', 0.8);
                resolve(compressedBase64);
            };
            img.onerror = reject;
            img.src = event.target.result;
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
    });
}
// ▼▼▼ 把下面所有新函数，都粘贴到你的 JS 代码区 ▼▼▼

// 函数1：显示分组选择弹窗 (核心)
async function showGroupSelectorModal(contactId) {
    const modal = document.getElementById('group-selector-modal');
    const listEl = document.getElementById('group-selector-list');
    listEl.innerHTML = ''; // 清空旧列表

    const contact = await kokoMemory.get('contacts', contactId);
    const allGroups = await kokoMemory.getAll('contactGroups');

    // 1. 添加一个“未分组”的选项
    const ungroupedItem = document.createElement('div');
    ungroupedItem.className = 'contact-picker-item';
    ungroupedItem.innerHTML = `<label style="width: 100%; cursor: pointer;"><input type="radio" name="group-select" value="null" ${!contact.groupId ? 'checked' : ''}> 未分组</label>`;
    ungroupedItem.addEventListener('click', () => moveContactToGroup(contactId, null));
    listEl.appendChild(ungroupedItem);

    // 2. 渲染所有已创建的分组
    allGroups.forEach(group => {
        const groupItem = document.createElement('div');
        groupItem.className = 'contact-picker-item';
        groupItem.innerHTML = `<label style="width: 100%; cursor: pointer;"><input type="radio" name="group-select" value="${group.id}" ${contact.groupId === group.id ? 'checked' : ''}> ${group.name}</label>`;
        groupItem.addEventListener('click', () => moveContactToGroup(contactId, group.id));
        listEl.appendChild(groupItem);
    });

    // 3. 绑定弹窗上的按钮事件 (使用克隆节点防止重复绑定)
    const oldCreateBtn = document.getElementById('create-new-group-btn');
    const newCreateBtn = oldCreateBtn.cloneNode(true);
    oldCreateBtn.parentNode.replaceChild(newCreateBtn, oldCreateBtn);
    newCreateBtn.addEventListener('click', () => createNewGroup(contactId));

    // (管理分组功能我们稍后实现，先放个提示)
    const oldManageBtn = document.getElementById('manage-groups-btn');
    const newManageBtn = oldManageBtn.cloneNode(true);
    oldManageBtn.parentNode.replaceChild(newManageBtn, oldManageBtn);
    newManageBtn.addEventListener('click', () => alert('管理分组功能待开发...'));

    document.getElementById('close-group-selector-modal').onclick = () => modal.style.display = 'none';
    
    // 4. 显示弹窗
    modal.style.display = 'flex';
}

// ▼▼▼ 使用这个【修正版】替换掉你原来的 moveContactToGroup 函数 ▼▼▼
async function moveContactToGroup(contactId, groupId) {
    // 1. 从数据库获取最新的联系人数据
    const contact = await kokoMemory.get('contacts', contactId);
    
    if (contact) {
        // 2. 更新它的 groupId
        contact.groupId = (groupId === 'null' || groupId === null) ? null : groupId;
        
        // 3. 把更新后的数据存回数据库
        await kokoMemory.put('contacts', contact);

        // 4. 【核心修复】在这里同步更新内存中的 state 对象！
        const contactInState = state.contacts.find(c => c.id === contactId);
        if (contactInState) {
            contactInState.groupId = contact.groupId;
        }

        // 5. 现在用更新后的 state 重新渲染列表，界面就会立刻变化了
        await renderContacts();
    }
    
    // 6. 关闭弹窗
    document.getElementById('group-selector-modal').style.display = 'none';
}

// 函数3：创建新分组
async function createNewGroup(contactIdForRefresh) {
    const newGroupName = await showCustomPrompt('创建新分组', '请输入分组名称');
    if (newGroupName && newGroupName.trim()) {
        const newGroup = {
            id: 'group_' + Date.now(),
            name: newGroupName.trim()
        };
        await kokoMemory.put('contactGroups', newGroup);
        // 创建成功后，刷新分组选择弹窗，以显示新创建的分组
        showGroupSelectorModal(contactIdForRefresh);
    }
}

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// --- 【全新】图片圆形裁剪器辅助函数 ---
function createCircularImage(imageUrl, size) {
    return new Promise((resolve, reject) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = size;
        canvas.height = size;

        const img = new Image();
        // 尝试解决跨域问题，不一定对所有外部图片生效，但对base64和大部分图床有效
        img.crossOrigin = 'Anonymous'; 
        
        img.onload = () => {
            // 1. 创建一个圆形的剪裁路径
            ctx.beginPath();
            ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2, true);
            ctx.closePath();
            ctx.clip(); // 应用剪裁

            // 2. 智能计算图片绘制尺寸，实现 object-fit: cover 的效果，防止拉伸
            const aspect = img.width / img.height;
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (canvas.width / canvas.height > aspect) {
                drawWidth = canvas.width;
                drawHeight = canvas.width / aspect;
                offsetX = 0;
                offsetY = (canvas.height - drawHeight) / 2;
            } else {
                drawHeight = canvas.height;
                drawWidth = canvas.height * aspect;
                offsetX = (canvas.width - drawWidth) / 2;
                offsetY = 0;
            }
            
            // 3. 将图片绘制到被剪裁的画布上
            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);

            // 4. 将画布内容导出为新的 base64 图片 URL
            resolve(canvas.toDataURL('image/png'));
        };
        
        img.onerror = () => {
            // 如果图片加载失败，直接返回原始URL，避免整个图表崩溃
            console.warn(`图片加载失败，无法裁剪: ${imageUrl}`);
            resolve(imageUrl); // 降级处理
        };

        img.src = imageUrl;
    });
}
// --- 【全新】关系网络功能模块 V2.0 ---

let editingCharacterId = null; // 用于跟踪正在编辑的角色

// 函数1：显示关系网页面 (不变)
async function showRelationshipScreen(contactId) {
    hideAllScreens();
    const screen = document.getElementById('relationship-network-screen');
    const contact = state.contacts.find(c => c.id === contactId);
    if (!contact) return;

    document.getElementById('relationship-network-title').textContent = `${contact.name} 的关系网`;
    screen.style.display = 'flex';
    screen.dataset.currentContactId = contactId;

    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId); 
}

// 函数2：渲染整个关系网编辑界面 (V2.0 大改版)
async function renderRelationshipNetwork(contactId) {
    const contact = state.contacts.find(c => c.id === contactId);
    let networkData = await kokoMemory.get('relationshipNetworks', contactId);

    // 【核心升级】如果旧数据没有nodes，就从现有关系中自动生成
    if (!networkData || !networkData.nodes) {
        networkData = { contactId: contactId, nodes: [], edges: networkData ? networkData.edges : [] };
        
        // 自动添加自己和用户
        networkData.nodes.push({ id: contact.id, name: contact.name, avatar: contact.avatar, isContact: true });
        networkData.nodes.push({ id: 'myProfile', name: state.myProfile.name + ' (你)', avatar: state.myProfile.avatar, isContact: true });
        
        // 从旧的edges里推断出其他联系人
        if(networkData.edges){
            networkData.edges.forEach(edge => {
                if(edge.target !== 'myProfile' && !networkData.nodes.some(n => n.id === edge.target)){
                    const targetContact = state.contacts.find(c => c.id === edge.target);
                    if(targetContact) {
                        networkData.nodes.push({ id: targetContact.id, name: targetContact.name, avatar: targetContact.avatar, isContact: true });
                    }
                }
            });
        }
        await kokoMemory.put('relationshipNetworks', networkData);
    }
    
    // 渲染角色名册列表
    const charListEl = document.getElementById('character-list');
    charListEl.innerHTML = '';
    networkData.nodes.forEach(node => {
        const item = document.createElement('div');
        item.className = 'preset-item';
        // 核心成员（自己和用户）不允许编辑和删除
        const isCoreMember = node.id === contactId || node.id === 'myProfile';
        const actionsHTML = isCoreMember ? '' : `
            <div class="preset-actions">
                <span class="preset-action-btn edit-character-btn" data-char-id="${node.id}" title="编辑角色"><i class="fas fa-edit"></i></span>
                <span class="preset-action-btn delete delete-character-btn" data-char-id="${node.id}" title="删除角色"><i class="fas fa-trash-alt"></i></span>
            </div>
        `;
        item.innerHTML = `
            <div class="preset-info" style="display: flex; align-items: center;">
                <img src="${node.avatar || 'https://via.placeholder.com/40'}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 15px;">
                <div class="preset-name">${node.name} ${node.isContact ? '' : '(NPC)'}</div>
            </div>
            ${actionsHTML}
        `;
        charListEl.appendChild(item);
    });

    // 填充“From”和“To”的下拉菜单
    const sourceSelect = document.getElementById('relation-source-select');
    const targetSelect = document.getElementById('relation-target-select');
    sourceSelect.innerHTML = '';
    targetSelect.innerHTML = '';
    networkData.nodes.forEach(node => {
        const option1 = new Option(node.name, node.id);
        const option2 = new Option(node.name, node.id);
        sourceSelect.appendChild(option1);
        targetSelect.appendChild(option2);
    });
    
    // 渲染已有关系列表 (V2.0 大改版)
    const listEl = document.getElementById('relationship-list');
    listEl.innerHTML = '';
    if (!networkData.edges || networkData.edges.length === 0) {
        listEl.innerHTML = '<p style="text-align: center; color: #888;">还没有任何关系，快添加一个吧！</p>';
    } else {
        networkData.edges.forEach(edge => {
            const sourceNode = networkData.nodes.find(n => n.id === edge.source);
            const targetNode = networkData.nodes.find(n => n.id === edge.target);
            if (!sourceNode || !targetNode) return; // 如果找不到节点，就跳过这条关系

            const item = document.createElement('div');
            item.className = 'preset-item';
            item.innerHTML = `
                <div class="preset-info">
                    <div class="preset-name">${sourceNode.name} → ${targetNode.name}: 【${edge.relationship}】</div>
                    <div class="preset-desc">${edge.detail || '暂无细节描述'}</div>
                </div>
                <div class="preset-actions">
                    <span class="preset-action-btn delete delete-relationship-btn" data-source-id="${edge.source}" data-target-id="${edge.target}" title="删除此关系">
                        <i class="fas fa-trash-alt"></i>
                    </span>
                </div>
            `;
            listEl.appendChild(item);
        });
    }
}

// 函数3：保存/更新一条关系 (V2.1 简化版)
async function saveRelationship() {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const sourceId = document.getElementById('relation-source-select').value;
    const targetId = document.getElementById('relation-target-select').value;
    // ▼▼▼ 核心修改：直接读取最终值，不再处理弹窗 ▼▼▼
    const relationshipType = document.getElementById('relation-type-select').value;
    const detail = document.getElementById('relation-detail-input').value.trim();

    if(sourceId === targetId) return alert('不能和自己建立关系！');
    // 如果关系类型还是“自定义”，说明用户没输入，就阻止保存
    if (relationshipType === '自定义') {
        return alert('请先在弹出的输入框中指定一个自定义关系类型！');
    }

    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    const existingEdgeIndex = networkData.edges.findIndex(e => e.source === sourceId && e.target === targetId);

    if (existingEdgeIndex > -1) {
        networkData.edges[existingEdgeIndex].relationship = relationshipType;
        networkData.edges[existingEdgeIndex].detail = detail;
    } else {
        networkData.edges.push({ source: sourceId, target: targetId, relationship: relationshipType, detail: detail });
    }

    await kokoMemory.put('relationshipNetworks', networkData);

    document.getElementById('relation-detail-input').value = '';
    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId);
}

// 函数4：删除一条关系 (V2.0 大改版)
async function deleteRelationship(sourceId, targetId) {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const confirmed = await showCustomConfirm('删除关系', '确定要删除这条关系吗？', true);
    if (confirmed) {
        const networkData = await kokoMemory.get('relationshipNetworks', contactId);
        if (networkData && networkData.edges) {
            networkData.edges = networkData.edges.filter(e => !(e.source === sourceId && e.target === targetId));
            await kokoMemory.put('relationshipNetworks', networkData);
            await renderRelationshipNetwork(contactId);
            await renderRelationshipGraph(contactId); // 刷新图表
        }
    }
}

// 函数5：打开角色编辑/添加弹窗 (V2.0 - 支持本地图片预览)
function openCharacterModal(character = null) {
    const modal = document.getElementById('character-modal');
    const preview = document.getElementById('character-avatar-preview');

    if (character) {
        // 编辑模式
        editingCharacterId = character.id;
        document.getElementById('character-modal-title').textContent = '编辑角色';
        document.getElementById('character-id-input').value = character.id;
        document.getElementById('character-name-input').value = character.name;
        // 如果有头像，就显示预览
        if (character.avatar) {
            preview.src = character.avatar;
            preview.style.display = 'block';
        } else {
            preview.style.display = 'none';
        }
    } else {
        // 添加模式 (NPC)
        editingCharacterId = null;
        document.getElementById('character-modal-title').textContent = '添加新角色 (NPC)';
        document.getElementById('character-id-input').value = '';
        document.getElementById('character-name-input').value = '';
        // 清空并隐藏预览
        preview.src = '';
        preview.style.display = 'none';
    }
    modal.style.display = 'flex';
}

// 函数6：保存一个角色 (NPC) (V2.0 - 支持本地图片保存)
async function saveCharacter() {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const name = document.getElementById('character-name-input').value.trim();
    if (!name) return alert('请输入角色姓名！');

    // ▼▼▼ 核心修改：从预览图片获取头像数据 ▼▼▼
    const avatar = document.getElementById('character-avatar-preview').src;
    // ▲▲▲ 修改结束 ▲▲▲

    const networkData = await kokoMemory.get('relationshipNetworks', contactId);

    if (editingCharacterId) {
        // 编辑
        const char = networkData.nodes.find(n => n.id === editingCharacterId);
        if (char) {
            char.name = name;
            char.avatar = avatar; // 保存Base64或旧的URL
        }
    } else {
        // 新增NPC
        networkData.nodes.push({
            id: 'npc_' + Date.now(),
            name: name,
            avatar: avatar, // 保存Base64
            isContact: false
        });
    }

    await kokoMemory.put('relationshipNetworks', networkData);
    document.getElementById('character-modal').style.display = 'none';
    await renderRelationshipNetwork(contactId);
    await renderRelationshipGraph(contactId);
}

// 函数7：删除一个角色 (NPC)
async function deleteCharacter(charId) {
    const screen = document.getElementById('relationship-network-screen');
    const contactId = screen.dataset.currentContactId;
    if (!contactId) return;

    const confirmed = await showCustomConfirm('删除角色', '确定要删除这个角色吗？\n所有与他/她相关的关系线也将被一并删除！', true);
    if (confirmed) {
        const networkData = await kokoMemory.get('relationshipNetworks', contactId);
        // 删除节点
        networkData.nodes = networkData.nodes.filter(n => n.id !== charId);
        // 删除所有与该节点相关的边
        networkData.edges = networkData.edges.filter(e => e.source !== charId && e.target !== charId);
        await kokoMemory.put('relationshipNetworks', networkData);
        await renderRelationshipNetwork(contactId);
        await renderRelationshipGraph(contactId); // 刷新图表
    }
}

// --- 【全新】V7.0 关系网络图表渲染函数 (Canvas终极兼容版) ---
async function renderRelationshipGraph(contactId) {
    const graphContainer = document.getElementById('relationship-graph-container');
    if (!graphContainer) return;
    const myChart = echarts.init(graphContainer);

    const contact = state.contacts.find(c => c.id === contactId);
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    // 如果没有任何数据（特别是nodes），就没必要画图了
    if(!networkData || !networkData.nodes || networkData.nodes.length === 0) {
        myChart.clear(); // 清空画布，防止显示旧图
        return;
    }

    // 1. 【核心修正】我们不再从头构建节点，而是直接使用 networkData.nodes 这个“官方名册”
    //    这样无论是联系人还是NPC，都能被正确处理
    const nodeInfos = networkData.nodes.map(node => {
        const isCenter = node.id === contactId;
        let finalName = node.name;
        // 自动给“你”加上后缀
        if(node.id === 'myProfile' && !node.name.includes('(你)')) {
            finalName = node.name + ' (你)';
        }
        return {
            id: node.id,
            name: finalName,
            avatar: node.avatar || `https://via.placeholder.com/${isCenter ? 60 : 45}/DDD/666?text=${node.name.substring(0,1)}`,
            size: isCenter ? 60 : 45
        }
    });

    // 2. 并行处理所有节点的图片，将它们裁剪成圆形 (这部分逻辑不变，但现在数据源对了)
    const imagePromises = nodeInfos.map(node => createCircularImage(node.avatar, node.size));
    const circularImageUrls = await Promise.all(imagePromises);

    // 3. 用裁剪好的图片数据，构建ECharts节点 (这部分逻辑不变)
    const nodesForGraph = nodeInfos.map((node, index) => ({
        id: node.id,
        name: node.name,
        symbolSize: node.size,
        symbol: 'image://' + circularImageUrls[index], 
        label: {
            show: true,
            position: 'bottom',
            color: '#333',
            fontWeight: 'bold'
        },
        itemStyle: {
            borderWidth: 2,
            borderColor: '#fff',
            shadowBlur: 6,
            shadowColor: 'rgba(0, 0, 0, 0.4)'
        }
    }));

    // 4. 配置图表 (不变)
    const option = {
        tooltip: {},
        series: [{
            type: 'graph',
            layout: 'force',
            roam: true,
            force: { repulsion: 250, edgeLength: 150, gravity: 0.05 },
            data: nodesForGraph,
            links: networkData.edges ? networkData.edges.map(edge => ({
                source: edge.source,
                target: edge.target,
                label: { show: true, formatter: edge.relationship },
                tooltip: { formatter: edge.detail }
            })) : [],
            lineStyle: { opacity: 0.9, width: 2, curveness: 0.1 }
        }]
    };

    // 5. 应用配置 (不变)
    myChart.setOption(option);
    window.addEventListener('resize', () => { myChart.resize(); });
}
// --- 【全新】打开“添加角色到名册”的选择模态框 ---
async function openAddToRosterModal() {
    const modal = document.getElementById('add-to-roster-modal');
    const selectEl = document.getElementById('import-contact-select');
    selectEl.innerHTML = '';

    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);

    // 1. 找出所有已经存在于名册中的角色ID
    const existingNodeIds = networkData.nodes.map(node => node.id);

    // 2. 筛选出那些还没有被加进名册的“联系人”
    const importableContacts = state.contacts.filter(contact => 
        !contact.isGroup && // 排除群聊
        !existingNodeIds.includes(contact.id) // 排除已在名册中的
    );

    // 3. 填充下拉菜单
    if (importableContacts.length > 0) {
        importableContacts.forEach(contact => {
            const option = new Option(contact.name, contact.id);
            selectEl.appendChild(option);
        });
        document.getElementById('confirm-import-contact-btn').style.display = 'block';
    } else {
        const option = new Option('没有其他可导入的联系人了', '');
        option.disabled = true;
        selectEl.appendChild(option);
        document.getElementById('confirm-import-contact-btn').style.display = 'none';
    }

    modal.style.display = 'flex';
}
// ▼▼▼ 把下面所有新函数，都粘贴到 initApp 函数的前面 ▼▼▼

// ==========================================================
// =========== ▼▼▼ 自动回复核心功能模块 ▼▼▼ ============
// ==========================================================

// 函数：显示自动回复设置页面
async function showAutomationScreen() {
    hideAllScreens();
    document.getElementById('automation-screen').style.display = 'flex';
    
    // 用当前保存的设置填充UI
    const settings = state.automationSettings;
    document.getElementById('automation-enabled-toggle').checked = settings.isEnabled;
    document.getElementById('automation-interval-input').value = settings.interval;
    document.getElementById('automation-min-replies-input').value = settings.minReplies;
    document.getElementById('automation-max-replies-input').value = settings.maxReplies;

    await renderAutomationContactList();
    updateAutomationStatusIndicator();
}

// 函数：渲染可供选择的联系人列表
async function renderAutomationContactList() {
    const listEl = document.getElementById('automation-contact-list');
    listEl.innerHTML = '';
    const selectedIds = new Set(state.automationSettings.selectedContactIds);

    state.contacts.forEach(contact => {
        if (contact.isGroup) return; // 自动回复不支持群聊

        const isChecked = selectedIds.has(contact.id);
        const item = document.createElement('div');
        item.className = 'world-book-item'; // 复用样式
        item.innerHTML = `
            <input type="checkbox" class="world-book-checkbox" id="auto-contact-${contact.id}" value="${contact.id}" ${isChecked ? 'checked' : ''}>
            <label for="auto-contact-${contact.id}" class="world-book-name">${contact.name}</label>
        `;
        listEl.appendChild(item);
    });
}

// 函数：保存自动回复的设置
async function saveAutomationSettings() {
    const newSettings = {
        isEnabled: document.getElementById('automation-enabled-toggle').checked,
        interval: parseInt(document.getElementById('automation-interval-input').value, 10) || 300,
        minReplies: parseInt(document.getElementById('automation-min-replies-input').value, 10) || 1,
        maxReplies: parseInt(document.getElementById('automation-max-replies-input').value, 10) || 2,
        selectedContactIds: Array.from(document.querySelectorAll('#automation-contact-list input:checked')).map(cb => cb.value)
    };
    
    state.automationSettings = newSettings;

    // 将设置保存到数据库
    const userSettings = await kokoMemory.get('userSettings', 'main') || { id: 'main' };
    userSettings.automationSettings = newSettings;
    await kokoMemory.put('userSettings', userSettings);

    alert('设置已保存！');

    // 根据新设置决定是开启还是关闭定时器
    if (newSettings.isEnabled) {
        startAutomationTimer();
    } else {
        stopAutomationTimer();
    }
    updateAutomationStatusIndicator();
}

// 函数：启动定时器
function startAutomationTimer() {
    stopAutomationTimer(); // 先停止旧的，防止重复
    
    if (!state.automationSettings.isEnabled || state.automationSettings.selectedContactIds.length === 0) {
        return;
    }

    const intervalSeconds = state.automationSettings.interval;
    automationTimer = setInterval(runAutomationCycle, intervalSeconds * 1000);
    
    // ✨ 新增：在这里手动设置下一次执行的时间戳
    nextAutomationTimestamp = Date.now() + intervalSeconds * 1000;
    
    console.log(`自动回复已启动，每 ${intervalSeconds} 秒检查一次。`);
}

// 函数：停止定时器
function stopAutomationTimer() {
    if (automationTimer) {
        clearInterval(automationTimer);
        automationTimer = null;
        nextAutomationTimestamp = 0;
        console.log("自动回复已停止。");
    }
    updateAutomationStatusIndicator();
}

// 函数：更新状态指示器（显示倒计时）
function updateAutomationStatusIndicator() {
    const indicator = document.getElementById('automation-status-indicator');
    if (!indicator) return;

    if (!state.automationSettings.isEnabled) {
        indicator.textContent = '当前已关闭';
        return;
    }
    
    if (nextAutomationTimestamp > 0) {
        const now = Date.now();
        const remainingSeconds = Math.round((nextAutomationTimestamp - now) / 1000);
        if (remainingSeconds > 0) {
            indicator.textContent = `运行中... 下次检查还剩 ${remainingSeconds} 秒`;
        } else {
            indicator.textContent = '正在检查中...';
        }
    } else {
        indicator.textContent = '运行中...';
    }
}

// ... 函数开头 ...
async function runAutomationCycle() {
    const settings = state.automationSettings;
    if (!settings.isEnabled || settings.selectedContactIds.length === 0) {
        stopAutomationTimer();
        return;
    }
    
    nextAutomationTimestamp = Date.now() + settings.interval * 1000;
    console.log("开始执行自动回复周期...");

    // 1. 筛选出所有“有资格”被自动回复的角色
    //    核心修改：过滤掉当前正在聊天的角色！
    const eligibleContacts = settings.selectedContactIds.filter(id => id !== state.activeChatId);

    if (eligibleContacts.length === 0) {
        console.log("没有符合条件的自动回复目标（可能正在与唯一的目标聊天），跳过本次周期。");
        return; // 如果过滤后没人可选了，就直接结束
    }

    // 2. 从“有资格”的角色中随机挑选“幸运儿”
    const shuffled = [...eligibleContacts].sort(() => 0.5 - Math.random());
    const replyCount = Math.floor(Math.random() * (settings.maxReplies - settings.minReplies + 1)) + settings.minReplies;
    const targets = shuffled.slice(0, replyCount);

    if (targets.length === 0) {
        console.log("本次没有选中任何目标，跳过。");
        return;
    }
    // ... 后续代码 ...
    
    // 2. 收集情报，构建“剧本”
    const myProfile = state.myProfile;
    let characterDossiers = '';
    const targetProfiles = [];

    for (const contactId of targets) {
        const contact = state.contacts.find(c => c.id === contactId);
        if (!contact) continue;
        targetProfiles.push(contact);

        let recentChatHistory = '(最近没有私聊记录)';
        if (contact.history && contact.history.length > 0) {
            recentChatHistory = contact.history
                .filter(msg => msg.type === 'text' && msg.sender !== 'system_instruction')
                .slice(-40) // 读取最近40条
                .map(msg => `    ${msg.sender === 'user' ? myProfile.name : contact.name}: ${msg.content}`)
                .join('\n');
        }
        
        // 核心新增：先获取当前角色对应的用户人设，如果没设置就给个默认值
const userPersonaForThisChar = contact.userPersona || '(用户未设置特定人设)';

// --- 核心新增：为当前角色单独检查时间感知 ---
let timeAwarenessPrompt = '';
if (contact.isTimeAware) {
    const currentTimeString = new Date().toLocaleString('zh-CN', { hour12: false });
    // 我们给它一个更明确的指令，告诉它要基于这个时间点发言
    timeAwarenessPrompt = `  - [当前时间感知]: ${currentTimeString} (你需要基于这个时间点来构思你的发言)\n`;
}
// --- 新增结束 ---

characterDossiers += `
- 角色名: ${contact.name}
  - 核心人设: ${contact.persona.replace(/\n/g, ' ')}
  - 用户“${myProfile.name}”在你眼中的人设: ${userPersonaForThisChar.replace(/\n/g, ' ')}
${timeAwarenessPrompt}  // <-- 把时间指令插入到档案里
  - [与“${myProfile.name}”的近期私聊参考 (重要)]
    \`\`\`
${recentChatHistory}
    \`\`\`
`;
    }

    if (targetProfiles.length === 0) return;

    // ✅ 正确的代码
const prompt = `[SYSTEM] 你是一个顶级的AI虚拟互动总监。
你的任务是：基于下方提供的角色档案和他们与用户的聊天记录，判断哪些角色现在最适合主动给用户发送一条消息，并为他们生成一段符合人设的、自然的回复。

[角色档案与聊天记录]
---
${characterDossiers}
---

[核心规则]
1.  **判断时机**: 仔细分析每个角色的聊天记录。如果对话刚刚结束，或者用户明显不想聊了，就不要生成回复。只有当对话处于暂停状态、或者有明显可以延续的话题时，才生成回复。
2.  **内容自然**: 回复必须像是角色“突然想起来”某件事，或者对之前的话题有了新的想法。避免生硬的问候。
3.  **允许多句话**: 你的回复可以包含多句话，模仿真实的人类聊天习惯。请使用换行符来分隔每一句话。
4.  **严格遵守格式**: 对于你决定要回复的每个角色，都必须严格使用以下格式。如果决定某个角色不回复，就不要为他生成任何内容。

// --- 核心新增部分 ---
[特殊指令格式]
除了纯文本，你还可以在 CONTENT 中使用以下指令来发送特殊消息：
- 语音: [voice:你想用语音说的文字内容]
- 图片: [picture:你想要发送的图片的文字描述]
- 表情包: [sticker:表情名]
// --- 新增结束 ---
// ✨ 新增一个“可用表情包列表”的区域 ✨
[可用表情包列表]
{{emoticon_list}}

[输出格式]
MESSAGE_START
SPEAKER: [角色名]
CONTENT: [该角色说的【可以包含换行的多句话】内容，也可以包含特殊指令]
MESSAGE_END
`;

    // ✨ 新增：把表情包列表填充到Prompt里
    const finalPrompt = prompt.replace('{{emoticon_list}}', state.emoticons.map(e => `'${e.name}'`).join('， ') || '（无）');

    // 3. 调用AI大脑 (注意：这里要用我们新创建的 finalPrompt)
    const rawResponse = await generateAiResponse(null, [], finalPrompt, false, 'chat');

    // 4. 解析剧本，精准投递
    const messageRegex = /MESSAGE_START\s*SPEAKER:\s*(.*?)\s*CONTENT:\s*([\s\S]*?)\s*MESSAGE_END/g;
    const matches = Array.from(rawResponse.matchAll(messageRegex));

    for (const match of matches) {
        const speakerName = match[1].trim();
        const content = match[2].trim();
        
        const speakerProfile = targetProfiles.find(p => p.name === speakerName);
        
// ✅✅✅ 最终的、完美的正确代码 ✅✅✅
if (speakerProfile && content) {
    console.log(`为 ${speakerName} 生成回复: ${content}`);
    
    // 1. 仍然是按换行符分割消息
    const messages = content.split('\n').filter(line => line.trim() !== '');

    // 2. 使用 forEach 循环，这样我们可以拿到句子的索引 (index)
    messages.forEach(async (line, index) => {
        // 3. 判断当前是不是第一句话，这个逻辑保留
        const isFirstLine = (index === 0);

        // 4. 【核心新增】把 processAndDisplayAiResponse 的菜谱搬到这里来！
        let processed = false;
        const commandRegex = /\[(sticker|voice|picture|red_packet|transfer|transfer_to|music|spin_wheel|claim_red_packet|location|create_location)(?::([^\]]*))?\]/;
        const commandMatch = line.match(commandRegex);

        if (commandMatch) {
            processed = true;
            const command = commandMatch[1];
            const value = commandMatch[2] || '';
            switch (command) {
                case 'voice': {
                    const duration = Math.max(1, Math.round(value.length / 4));
                    await createAndAddMessage({ type: 'voice', content: { text: value, duration: duration } }, speakerProfile.id, speakerProfile, isFirstLine);
                    break;
                }
// ... 省略了其他case ...
case 'sticker':
    const emoticon = state.emoticons.find(e => e.name === value.trim());
    if (emoticon) {
        // 正确的版本：明确指定发送者是 speakerProfile.id，目标窗口是 speakerProfile
        await createAndAddMessage({ type: 'image', url: emoticon.url, isEmoticon: true, emoticonName: emoticon.name }, speakerProfile.id, speakerProfile, isFirstLine);
    } else {
        // 这里也一并修正
        await createAndAddMessage({ type: 'text', content: `[发送表情失败: ${value}]` }, speakerProfile.id, speakerProfile, isFirstLine);
    }
    break;
// ... 省略了其他case ...
                case 'picture': {
                    await createAndAddMessage({ type: 'picture_description', content: { description: value } }, speakerProfile.id, speakerProfile, isFirstLine);
                    break;
                }
                // 你可以根据需要，把 processAndDisplayAiResponse 里的其他 case (如 sticker, music 等) 也复制到这里
                // 来让自动回复支持更多功能！
            }
        }

        // 5. 如果不是任何特殊指令，就当作普通文本处理
        if (!processed) {
            await createAndAddMessage({ type: 'text', content: line }, speakerProfile.id, speakerProfile, isFirstLine);
        }

        // 6. 加入延迟，让对话看起来更自然
        await sleep(800 + Math.random() * 500);
    });
}
    }
}

// ==========================================================
// =========== ▲▲▲ 自动回复核心功能模块 END ▲▲▲ =========
// 全局变量，用于管理语音播放队列
let isPlayingVoice = false;
const voiceQueue = [];

/**
 * 将语音任务添加到队列，并触发处理
 */
async function playNextInQueue(text, contact) { // 将 voiceId 改为 contact
    voiceQueue.push({ text, contact }); // 保存整个 contact 对象
    if (!isPlayingVoice) {
        processVoiceQueue();
    }
}

/**
 * 递归处理语音队列，确保一次只播放一个
 */
async function processVoiceQueue() {
    if (voiceQueue.length === 0) {
        isPlayingVoice = false;
        return;
    }

    isPlayingVoice = true;
    const { text, contact } = voiceQueue.shift(); // 将 voiceId 改为 contact // 取出队列的第一个任务

    try {
        // 等待 playVoiceMessage 函数播放完成
        await playVoiceMessage(text, contact); // 传入整个 contact 对象
    } catch (error) {
        console.error("视频通话语音播放失败:", error);
    } finally {
        // 不管成功或失败，都继续处理队列里的下一个任务
        processVoiceQueue();
    }
}
/**
 * 调用 MiniMax API 将文本转换为语音并返回一个 Promise，该 Promise 在播放结束时解析
 * @param {string} textToSpeak - 要转换的文字
 * @param {string} voiceId - MiniMax 的音色 ID
 * @returns {Promise<void>}
 */
// ▼▼▼ 使用这个【修正版】，完整替换旧的 playVoiceMessage 函数 ▼▼▼
function playVoiceMessage(textToSpeak, contact) {
    return new Promise((resolve, reject) => {
        // 安全检查：如果联系人对象不存在，则直接成功返回
        if (!contact) {
            console.warn("playVoiceMessage 收到无效的 contact 对象，跳过播放。");
            return resolve();
        }

        // 如果连 voiceId 都没有，那肯定无法播放
        if (!contact.voiceId) {
            console.warn(`角色 ${contact.name} 未配置音色ID，跳过语音播放。`);
            return resolve();
        }

        const audioPlayer = document.getElementById('voice-message-player');
        
        // --- 调度中心 (已修正兼容逻辑) ---
        // 核心修正：如果 voiceProvider 是 'minimax' 或者 **根本不存在 (undefined)**，都走 MiniMax 逻辑
        if (contact.voiceProvider === 'minimax' || !contact.voiceProvider) {
            
            const { minimaxGroupId, minimaxApiKey } = state.apiSettings;
            if (!minimaxGroupId || !minimaxApiKey) {
                console.warn("MiniMax Group ID 或 API Key 未配置，无法播放语音。");
                return resolve();
            }

            fetch(`https://api.minimax.chat/v1/text_to_speech?GroupId=${minimaxGroupId}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${minimaxApiKey}` },
                body: JSON.stringify({
                    "voice_id": contact.voiceId,
                    "text": textToSpeak,
                    "model": "speech-01", "speed": 1.0, "vol": 1.0, "pitch": 0
                })
            })
            .then(response => {
                if (!response.ok) return response.json().then(err => { throw new Error(err.base_resp?.status_msg || 'MiniMax TTS API请求失败') });
                return response.arrayBuffer();
            })
            .then(getAudioAndPlay)
            .catch(handleAudioError);

        } else if (contact.voiceProvider === 'siliconflow') {
            const { siliconflowApiKey } = state.apiSettings;
            if (!siliconflowApiKey) {
                console.warn("SiliconFlow API Key 未配置，无法播放语音。");
                return resolve();
            }

            fetch(`https://api.siliconflow.cn/v1/audio/speech`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${siliconflowApiKey}` },
                body: JSON.stringify({
                    "model": "FunAudioLLM/CosyVoice2-0.5B",
                    "voice": contact.voiceId,
                    "input": textToSpeak,
                    "response_format": "mp3"
                })
            })
            .then(response => {
                if (!response.ok) return response.json().then(err => { throw new Error(err.error?.message || 'SiliconFlow TTS API请求失败') });
                return response.arrayBuffer();
            })
            .then(getAudioAndPlay)
            .catch(handleAudioError);
        } else {
            // 如果设置了 provider 但不是以上任何一种
            console.warn(`未知的语音服务商: ${contact.voiceProvider}`);
            resolve();
        }

        // --- 辅助函数 (保持不变) ---
        function getAudioAndPlay(audioData) {
            const blob = new Blob([audioData], { type: 'audio/mpeg' });
            const audioUrl = URL.createObjectURL(blob);
            audioPlayer.src = audioUrl;
            audioPlayer.play();
            audioPlayer.onended = () => { URL.revokeObjectURL(audioUrl); resolve(); };
            audioPlayer.onerror = (e) => { URL.revokeObjectURL(audioUrl); reject(e); };
        }

        function handleAudioError(error) {
            console.error('播放语音消息失败:', error);
            reject(error);
        }
    });
}
// ==========================================================

// ▲▲▲ 粘贴到这里结束 ▲▲▲
        async function initApp() {
            await kokoMemory.init();
            await loadDataFromDB();
            await loadAppearanceSettings();
            await renderMyProfile(); 
            await renderContacts(); 
            await renderWorldBooks(); 
            await updateWorldBookSelectors(); 
            await renderUserPersonaPresets();
            await renderThoughtPresets();
            updateNotificationDots();
            renderAttachmentMenu();
            if (state.posts.length === 0 && isInitialPostLoad) {
                await showFeedScreen();
            }
            await showMainScreen();
            // ▼▼▼ 在函数的最后，添加这两行代码 ▼▼▼
            if (state.automationSettings.isEnabled) {
                startAutomationTimer();
            }
            showLockScreen();
            // ▲▲▲ 新代码添加结束 ▲▲▲
        }

        function renderPet(contact) {
            const container = document.getElementById('pet-container-wrapper');
            if (!contact) {
                container.innerHTML = '';
                return;
            }

            if (!contact.pet) {
                container.innerHTML = `
                    <div id="pet-container">
                        <div class="pet-header" style="justify-content:center;">我们的小窝</div>
                        <button class="form-button" id="adopt-pet-btn">领养一只史莱姆</button>
                    </div>`;
                return;
            }
            
            const now = Date.now();
            const elapsedHours = (now - contact.pet.lastUpdated) / (1000 * 60 * 60);
            const decayAmount = Math.floor(elapsedHours * 5); 
            
            if (decayAmount > 0) {
                contact.pet.hunger = Math.max(0, contact.pet.hunger - decayAmount);
                contact.pet.happiness = Math.max(0, contact.pet.happiness - decayAmount);
                contact.pet.cleanliness = Math.max(0, contact.pet.cleanliness - decayAmount);
                contact.pet.lastUpdated = now;
                kokoMemory.put('contacts', contact);
            }

            let isWorking = false;
            let workCooldownText = '';
            if (contact.pet.workFinishTimestamp && now < contact.pet.workFinishTimestamp) {
                isWorking = true;
                const remainingMinutes = Math.ceil((contact.pet.workFinishTimestamp - now) / (1000 * 60));
                workCooldownText = `工作中... (剩余${remainingMinutes}分钟)`;
            }

            container.innerHTML = `
                <div id="pet-container">
                    <div class="pet-header">
                        <span id="pet-name">${contact.pet.name} (LV.${contact.pet.level})</span>
                        <span id="pet-gold-display">💰 ${contact.gold_coins}</span>
                    </div>
                    <div class="pet-visual-area">
                        <div>
                            <div class="slime">
                                <div class="blush left"></div>
                                <div class="blush right"></div>
                            </div>
                            <div class="slime-shadow"></div>
                        </div>
                    </div>
                    <div class="pet-stats">
                        <div class="stat-bar-container" title="经验值: ${contact.pet.xp} / 100">
                            <span class="stat-bar-label">成长</span>
                            <div class="stat-bar"><div id="xp-bar" class="stat-bar-inner" style="background-color: #ffcc80;"></div></div>
                        </div>
                        <div class="stat-bar-container">
                            <span class="stat-bar-label">饱食度</span>
                            <div class="stat-bar"><div id="hunger-bar" class="stat-bar-inner"></div></div>
                        </div>
                        <div class="stat-bar-container">
                            <span class="stat-bar-label">开心值</span>
                            <div class="stat-bar"><div id="happiness-bar" class="stat-bar-inner"></div></div>
                        </div>
                         <div class="stat-bar-container">
                            <span class="stat-bar-label">清洁度</span>
                            <div class="stat-bar"><div id="cleanliness-bar" class="stat-bar-inner"></div></div>
                        </div>
                    </div>
                    <div class="pet-actions">
                        <button id="feed-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>喂食 (-5💰)</button>
                        <button id="play-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>玩耍</button>
                        <button id="clean-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>清洁</button>
                        <button id="work-pet-btn" class="pet-action-btn" ${isWorking ? 'disabled' : ''}>${isWorking ? workCooldownText : '打工 (1小时)'}</button>
                    </div>
                </div>`;
            
            document.getElementById('xp-bar').style.width = `${contact.pet.xp}%`;
            document.getElementById('hunger-bar').style.width = `${contact.pet.hunger}%`;
            document.getElementById('happiness-bar').style.width = `${contact.pet.happiness}%`;
            document.getElementById('cleanliness-bar').style.width = `${contact.pet.cleanliness}%`;

            const slimeEl = container.querySelector('.slime');
            slimeEl.className = 'slime'; 
            if (contact.pet.form) {
                slimeEl.classList.add(`${contact.pet.form}-form`);
            }
            if (contact.pet.hunger < 40) slimeEl.classList.add('hungry');
            if (contact.pet.cleanliness < 40) slimeEl.classList.add('dirty');
        }

        function updateChatPetVisuals(contact) {
            const chatPetEl = document.querySelector('#chat-pet-container .slime');
            if (!chatPetEl || !contact || !contact.pet) return;
            
            chatPetEl.className = 'slime'; 
            if (contact.pet.form) {
                chatPetEl.classList.add(`${contact.pet.form}-form`);
            }
            if (contact.pet.hunger < 40) chatPetEl.classList.add('hungry');
            if (contact.pet.cleanliness < 40) chatPetEl.classList.add('dirty');
        }


        async function updatePetStats(stat, value, contact, isCharAction = false) {
            if (!contact || !contact.pet) return;
            contact.pet[stat] = Math.min(100, Math.max(0, contact.pet[stat] + value));
            if (!isCharAction) {
                contact.pet.lastUpdated = Date.now();
            }
            await kokoMemory.put('contacts', contact);
        }

        function findMentionsInComment(comment) {
            const mentionedContacts = new Set();
            if (!comment || !comment.content) return [];
            
            const mentionRegex = /@([\w\u4e00-\u9fa5]+)/g;
            let match;

            while ((match = mentionRegex.exec(comment.content)) !== null) {
                const username = match[1];
                const contact = state.contacts.find(c => c.name === username);
                if (contact) {
                    mentionedContacts.add(contact);
                }
            }
            return Array.from(mentionedContacts);
        }
        
        function handleAvatarUpload(callback) {
            const uploader = document.getElementById('avatar-uploader');
            uploader.click();

            uploader.onchange = function(e) {
                const file = e.target.files[0];
                if (!file) return;

                if (file.size > 2 * 1024 * 1024) {
                    alert('图片太大了！请选择一张小于 2MB 的图片。');
                    return;
                }

                const reader = new FileReader();
                reader.onload = function(event) {
                    const base64String = event.target.result;
                    callback(base64String);
                };
                
                reader.readAsDataURL(file);
                e.target.value = ''; 
            };
        }
        // 用这个新版本 替换掉 旧的 attachGroupSettingsListeners 函数
function attachGroupSettingsListeners() {
    // 用下面这行正确的代码替换它
document.getElementById('back-from-group-settings').addEventListener('click', () => {
    // 首先隐藏当前的设置屏幕
    document.getElementById('group-settings-screen').style.display = 'none';
    // 然后重新打开当前激活的聊天窗口（也就是你刚才所在的群聊）
    openChat(state.activeChatId); 
});
    
    // ▼▼▼ 新增：为“用户面具预设”下拉框添加功能 ▼▼▼
    document.getElementById('group-select-user-persona-preset').addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('group-user-mask-textarea').value = preset ? preset.description : '';
    });

    // ▼▼▼ 新增：为全新的“保存”按钮添加功能 ▼▼▼
    document.getElementById('save-group-settings-btn').addEventListener('click', async () => {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;

        // 读取所有设置项的当前值
        group.userPersona = document.getElementById('group-user-mask-textarea').value.trim();
        group.memoryShared = document.getElementById('group-memory-share-toggle').checked;
        group.isTimeAware = document.getElementById('group-time-awareness-toggle').checked;
        group.worldBooks = Array.from(document.querySelectorAll('#group-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);

        // 保存到数据库
        await kokoMemory.put('contacts', group);
        alert('群聊设置已保存！');
        showCharProfileScreen(); // 保存后返回上一页
    });

    // 解散群聊 (不变)
    document.getElementById('disband-group-btn').addEventListener('click', async () => {
        // ... 这部分代码和之前完全一样，不用动 ...
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;
        const confirmed = await showCustomConfirm('确认操作', `确定要解散群聊“${group.name}”吗？\n此操作会删除群聊及所有聊天记录，无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== group.id);
            await kokoMemory.delete('contacts', group.id);
            state.activeChatId = null;
            alert('群聊已解散。');
            await showMainScreen();
        }
    });
}
        // --- NEW: V7.0 开始/停止听歌计时器 ---
        function startListenTimeTracker() {
            if (listenTimeInterval) clearInterval(listenTimeInterval); // 清除旧的计时器
            
            listenTimeInterval = setInterval(async () => {
                const contact = state.contacts.find(c => c.id === state.activeChatId);
                if (contact && !globalAudioPlayer.paused) {
                    contact.totalListenTime += 1; // 每秒加1
                    // 为避免频繁写数据库，可以设计成每10秒或30秒保存一次
                    if (contact.totalListenTime % 10 === 0) {
                        await kokoMemory.put('contacts', contact);
                    }
                }
            }, 1000);
        }

        async function stopListenTimeTracker() {
            clearInterval(listenTimeInterval);
            listenTimeInterval = null;
            // 停止时，确保最后的数据被保存
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if(contact) {
                await kokoMemory.put('contacts', contact);
            }
        }

// 把这段新代码，粘贴到 attachEventListeners 函数的【内部】

// --- 新增：打开“添加群成员”弹窗的逻辑 ---
function openAddGroupMemberModal(group) {
    const modal = document.getElementById('add-group-member-modal');
    const memberListEl = document.getElementById('add-member-picker-list');
    memberListEl.innerHTML = '';

    // 筛选出还不是群成员的联系人
    const availableContacts = state.contacts.filter(c => !c.isGroup && !group.members.includes(c.id));

    if (availableContacts.length === 0) {
        memberListEl.innerHTML = '<p style="color: #888; text-align: center;">没有其他可以添加的联系人了。</p>';
    } else {
        availableContacts.forEach(contact => {
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <input type="checkbox" id="add-member-check-${contact.id}" value="${contact.id}">
                <label for="add-member-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                    <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                    <span>${contact.name}</span>
                </label>
            `;
            memberListEl.appendChild(item);
        });
    }

    modal.style.display = 'flex';
    
    // 为确认按钮绑定一次性事件
    const confirmBtn = document.getElementById('confirm-add-group-members-btn');
    const newConfirmBtn = confirmBtn.cloneNode(true);
    confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
    
    newConfirmBtn.addEventListener('click', async () => {
        const selectedIds = Array.from(document.querySelectorAll('#add-member-picker-list input:checked')).map(input => input.value);
        if (selectedIds.length === 0) {
            return;
        }

        const addedMemberNames = selectedIds.map(id => state.contacts.find(c => c.id === id)?.name).filter(Boolean);

        // 更新群成员列表
        group.members.push(...selectedIds);
        await kokoMemory.put('contacts', group);

        // 在群聊中发送系统通知
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = group.id;
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `你邀请 "${addedMemberNames.join('", "')}" 加入了群聊`
        });
        state.activeChatId = tempActiveChatId;

        modal.style.display = 'none';
        openGroupSettingsScreen(group); // 刷新设置页面
    });
}

// --- 新增：为群聊设置页面的各种按钮绑定事件 ---
document.getElementById('group-settings-screen').addEventListener('click', async (e) => {
    const group = state.contacts.find(c => c.id === state.activeChatId);
    if (!group) return;

    // 处理“添加成员”按钮点击
    if (e.target.closest('#add-group-member-btn')) {
        openAddGroupMemberModal(group);
    }
    
    // 处理“踢出成员”按钮点击
    const removeButton = e.target.closest('.remove-member-btn');
    if (removeButton) {
        const memberId = removeButton.dataset.memberId;
        const member = state.contacts.find(c => c.id === memberId);
        if (!member) return;

        const confirmed = await showCustomConfirm('移出成员', `确定要将 "${member.name}" 移出群聊吗？`, true);
        if (confirmed) {
            // 从成员列表中移除
            group.members = group.members.filter(id => id !== memberId);
            // 如果在禁言列表中，也一并移除
            if (group.mutedMembers) {
                group.mutedMembers = group.mutedMembers.filter(id => id !== memberId);
            }

            await kokoMemory.put('contacts', group);
            
            // 发送系统通知
            const tempActiveChatId = state.activeChatId;
            state.activeChatId = group.id;
            await createAndAddMessage({
                type: 'system_notification',
                sender: 'system',
                content: `你将 "${member.name}" 移出了群聊`
            });
            state.activeChatId = tempActiveChatId;

            openGroupSettingsScreen(group); // 刷新设置页面
        }
    }
    // ==========================================================
// ▼▼▼ 请将这段【新代码】粘贴到这里 ▼▼▼
// ==========================================================
const muteButton = e.target.closest('.mute-member-btn');
if (muteButton) {
    const memberId = muteButton.dataset.memberId;

    // 确保禁言列表存在
    group.mutedMembers = group.mutedMembers || [];

    const memberIndex = group.mutedMembers.indexOf(memberId);

    // 核心：切换禁言状态
    if (memberIndex > -1) {
        // 如果已经在列表里，就解除禁言
        group.mutedMembers.splice(memberIndex, 1);
    } else {
        // 如果不在列表里，就加入禁言
        group.mutedMembers.push(memberId);
    }

    // 保存更新后的群聊数据
    await kokoMemory.put('contacts', group);

    // 关键一步：重新渲染整个设置页面来立即更新UI
    openGroupSettingsScreen(group);
}
// ==========================================================
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ==========================================================
// ▼▼▼ 在这个事件监听器的末尾，添加我们新的逻辑 ▼▼▼
    if (e.target.id === 'clear-group-chat-history-btn' || e.target.closest('#clear-group-chat-history-btn')) {
        const group = state.contacts.find(c => c.id === state.activeChatId);
        if (!group) return;

        // 弹出确认框，防止误操作
        const confirmed = await showCustomConfirm(
            '清空记录', 
            `确定要清空群聊“${group.name}”的所有聊天记录吗？\n此操作不可恢复。`, 
            true // true表示这是一个危险操作，确认按钮会是红色
        );

        if (confirmed) {
            // 核心操作：清空 history 数组
            group.history = [];
            
            // 保存更改到数据库
            await kokoMemory.put('contacts', group);
            
            alert('群聊记录已清空。');
            
            // 操作完成后，关闭设置页面，并重新打开聊天窗口，用户就能看到空空如也的聊天界面了
            document.getElementById('group-settings-screen').style.display = 'none';
            openChat(group.id);
        }
    }
});

// --- 新增：为“添加成员”弹窗的关闭按钮绑定事件 ---
document.getElementById('close-add-group-member-modal').addEventListener('click', () => {
    document.getElementById('add-group-member-modal').style.display = 'none';
});
// ==========================================================
    // =========== ▼▼▼ 购物中心功能逻辑 V3 (预加载版) ▼▼▼ ===
    // ==========================================================
    let activeShoppingTab = 'taobao'; // 默认选中的标签页
    let currentProductData = {}; // 用于暂存当前要操作的商品信息

    // 函数：显示商品详情页面
    function showProductDetailScreen(productData) {
        currentProductData = productData; // 将当前商品信息存入全局，方便分享
        hideAllScreens();
        const detailScreen = document.getElementById('product-detail-screen');
        const mainInfoEl = document.getElementById('product-main-info');
        const commentsListEl = document.getElementById('buyer-comments-list');
        
        // 填充商品核心信息
        mainInfoEl.innerHTML = `
            <h1 style="font-size: 20px; font-weight: 700; margin-bottom: 10px;">${productData.name}</h1>
            <div class="product-price" style="font-size: 24px; margin-bottom: 10px;"><span>¥</span>${productData.price}</div>
            <div class="product-shop" style="margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid #eee;">${productData.shop}</div>
            <div class="product-description">${productData.description.replace(/\n/g, '<br>')}</div>
        `;

        // 渲染预先加载好的评论
        commentsListEl.innerHTML = '';
        if (productData.comments && productData.comments.length > 0) {
            // 这是修复后的新代码块
productData.comments.forEach(comment => {
    const commentEl = document.createElement('div');
    commentEl.className = 'post-comment-item'; // 复用论坛评论样式
    commentEl.innerHTML = `
        <div style="display: flex; gap: 10px;">
            <img src="${STRANGER_AVATARS[Math.floor(Math.random() * STRANGER_AVATARS.length)]}" style="width: 35px; height: 35px; border-radius: 50%;">
            <div style="flex-grow: 1;">
                <span class="comment-author">${comment.username}</span>
                <div class="comment-content">${comment.content}</div>
            </div>
        </div>
    `;
    commentsListEl.appendChild(commentEl);
});
        } else {
            commentsListEl.innerHTML = `<div style="text-align: center; color: #999; padding: 20px;">暂无评价</div>`;
        }
        
        detailScreen.style.display = 'flex';
    }

    // 函数：显示购物中心页面
    async function showShoppingScreen() {
        hideAllScreens();
        document.getElementById('shopping-screen').style.display = 'flex';
        activeShoppingTab = 'taobao';
        renderShoppingTabs();
        
        const savedProducts = await kokoMemory.get('userSettings', 'shopping_products_' + activeShoppingTab);
        if (savedProducts && savedProducts.data.length > 0) {
            renderProducts(savedProducts.data);
        } else {
            const productList = document.getElementById('product-list');
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">这里空空如也~<br>请点击右上角的刷新按钮生成商品</div>`;
        }
    }

    // 函数：渲染顶部的标签页
    async function renderShoppingTabs() {
        const tabsContainer = document.getElementById('shopping-tabs-container');
        tabsContainer.innerHTML = `
            <button class="feed-tab-btn ${activeShoppingTab === 'taobao' ? 'active' : ''}" data-tab="taobao">🍑宝</button>
            <button class="feed-tab-btn ${activeShoppingTab === 'meituan' ? 'active' : ''}" data-tab="meituan">丑团</button>
            <button class="feed-tab-btn ${activeShoppingTab === 'pinduoduo' ? 'active' : ''}" data-tab="pinduoduo">拼夕夕</button>
        `;
    }
    
    // 函数：创建单个商品卡片的HTML元素
    function createProductItem(product) {
        const item = document.createElement('div');
        item.className = 'product-item';
        item.dataset.product = JSON.stringify(product); 

        item.innerHTML = `
            <div class="product-details">
                <div class="product-title">${product.name}</div>
                <div class="product-description">${product.description}</div>
                <div class="product-shop">${product.shop}</div>
                <div class="product-footer">
                    <div class="product-price"><span>¥</span>${product.price}</div>
                    <button class="product-share-btn" title="分享给...">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>
        `;
        return item;
    }

    // 函数：将AI生成的商品渲染到页面上
    function renderProducts(products) {
        const productList = document.getElementById('product-list');
        productList.innerHTML = ''; 
        if (products.length === 0) {
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">AI没有生成任何商品，请再试一次。</div>`;
            return;
        }
        products.forEach(p => {
            const productElement = createProductItem(p);
            productList.appendChild(productElement);
        });
    }
    
    // 函数：调用AI刷新或搜索商品 (V3核心改动：一次性生成所有信息)
    async function refreshProductsAI(isSearch = false) {
        const productList = document.getElementById('product-list');
        productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;"><i class="fas fa-spinner fa-spin" style="font-size: 24px;"></i><p style="margin-top: 10px;">AI正在生成包含详情和评论的商品...</p></div>`;

        const platformStyles = {
            taobao: "高端、昂贵、有品牌调性",
            pinduoduo: "价格非常低廉、极具性价比、充满“百亿补贴”风格",
            meituan: "看起来很美味的菜品、套餐或饮品"
        };
        const platformName = {
            taobao: "淘宝",
            pinduoduo: "拼多多",
            meituan: "美团外卖"
        };

        const keyword = document.getElementById('product-search-input').value.trim();
        const coreTask = (isSearch && keyword) 
            ? `请根据关键词“[${keyword}]”，为[${platformName[activeShoppingTab]}]平台生成5个相关的、风格为[${platformStyles[activeShoppingTab]}]的商品。`
            : `请为[${platformName[activeShoppingTab]}]平台生成5个随机的、风格为[${platformStyles[activeShoppingTab]}]的商品。`;

        const prompt = `${coreTask}对于每个商品，都必须严格遵循以下格式块，并重复5次：
PRODUCT_START
名称：...
价格：...
店铺：...
商品描述：(20-40字的生动描述)
--COMMENTS--
(在这里为该商品生成3条风格各异的买家评论，每条评论都使用 '用户名：... | 评论内容：...' 的格式并换行)
PRODUCT_END`;
        
        try {
            const rawResponse = await generateAiResponse(null, [], prompt, false, 'square');
            const productBlocks = rawResponse.split('PRODUCT_END');
            const products = productBlocks.map(block => {
                if (!block.includes('PRODUCT_START')) return null;

                const nameMatch = block.match(/名称：(.*?)\n/);
                const priceMatch = block.match(/价格：(.*?)\n/);
                const shopMatch = block.match(/店铺：(.*?)\n/);
                const descMatch = block.match(/商品描述：(.*?)\n/);
                
                const commentsBlock = block.split('--COMMENTS--')[1] || '';
                const commentLines = commentsBlock.trim().split('\n');
                // 这是修复后的新代码块
const comments = commentLines.map(line => {
    const parts = line.split('|');
    if (parts.length < 2) return null; // 必须要有'|'分隔符

    // 智能地清理前后缀，无论AI给没给，都能正确提取
    const username = parts[0].replace('用户名：', '').trim();
    const content = parts[1].replace('评论内容：', '').trim();
    
    // 确保提取后内容不为空
    if (!username || !content) return null; 

    return { username: username, content: content };
}).filter(Boolean);

                return {
                    name: nameMatch ? nameMatch[1].trim() : '未知商品',
                    price: priceMatch ? priceMatch[1].trim() : '0.00',
                    shop: shopMatch ? shopMatch[1].trim() : '官方旗舰店',
                    description: descMatch ? descMatch[1].trim() : '一件很棒的商品。',
                    comments: comments,
                    platform: activeShoppingTab
                };
            }).filter(Boolean);

            await kokoMemory.put('userSettings', { id: 'shopping_products_' + activeShoppingTab, data: products });
            renderProducts(products);

        } catch (error) {
            console.error("AI商品生成失败:", error);
            productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: var(--soft-red);">商品生成失败，请检查API设置或网络。</div>`;
        }
    }

    // 函数：打开分享弹窗
    function openShareProductModal(product) {
    currentProductData = product;
    const modal = document.getElementById('share-product-modal');
    const infoEl = document.getElementById('share-product-info');
    const recipientListEl = document.getElementById('share-product-recipient-list');
    
    document.getElementById('share-product-message-input').value = '';
    infoEl.innerHTML = `即将分享: <strong>${product.name}</strong><br><span style="color: #888;">价格: ¥${product.price}</span>`;
    
    // ▼▼▼ 核心新增逻辑 ▼▼▼
    recipientListEl.innerHTML = ''; // 先清空旧列表
    state.contacts.forEach(contact => {
        if (contact.isGroup) return; // 不允许分享到群聊
        const item = document.createElement('div');
        item.className = 'contact-picker-item';
        // 使用 radio 按钮确保一次只能选一个人
        item.innerHTML = `
            <input type="radio" id="share-recipient-${contact.id}" name="share-recipient" value="${contact.id}">
            <label for="share-recipient-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                <span>${contact.name}</span>
            </label>
        `;
        recipientListEl.appendChild(item);
    });
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    modal.style.display = 'flex';
}
    
    // 注意：函数参数发生了变化
async function handleShareProduct(intent, contactId) { 
    // 使用传入的 contactId 查找联系人
    const contact = state.contacts.find(c => c.id === contactId); 
    if (!contact) {
        // 理论上这里不会再报错，但保留以防万一
        alert('错误：选择的联系人无效！'); 
        return;
    }
    const message = document.getElementById('share-product-message-input').value.trim();
    if (intent === 'gift') {
        const price = parseFloat(currentProductData.price.replace(/[^\d.-]/g, ''));
        if (state.myProfile.balance < price) {
            alert('钱包余额不足，无法送出礼物！');
            return;
        }
        state.myProfile.balance -= price;
        await addTransaction('expense', price, `送给 ${contact.name} 的礼物：${currentProductData.name}`, contact.id);
        await kokoMemory.put('myProfile', state.myProfile);
        renderMyProfile();
    }
    
    // ▼▼▼ 核心修改：临时切换上下文来发送消息 ▼▼▼
    const originalActiveChatId = state.activeChatId; // 保存原始状态
    state.activeChatId = contact.id; // 临时设为目标联系人
    
    await createAndAddMessage({
        type: 'product_share',
        content: {
            productDetails: currentProductData,
            intent: intent,
            accompanyingMessage: message
        }
    });

    state.activeChatId = originalActiveChatId; // 恢复原始状态
    // ▲▲▲ 修改结束 ▲▲▲

    document.getElementById('share-product-modal').style.display = 'none';
    // 分享后只给提示，不再跳转页面，让用户可以继续浏览
    alert(`已成功分享给 ${contact.name}！`); 
}
// ✨✨✨ 开始粘贴新函数 ✨✨✨
async function renderForumSettingsUI() {
    // 1. 填充用户面具下拉菜单
    const personaSelect = document.getElementById('forum-persona-select');
    personaSelect.innerHTML = '<option value="">-- 不使用特定身份 --</option>';
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if (state.forumSettings.personaId === preset.id) {
            option.selected = true;
        }
        personaSelect.appendChild(option);
    });

    // 2. 填充世界书多选列表
    const worldBookList = document.getElementById('forum-worldbook-list');
    worldBookList.innerHTML = '';
    if (state.worldBooks.length > 0) {
        state.worldBooks.forEach(book => {
            const isChecked = state.forumSettings.worldBookIds.includes(book.id);
            const bookItem = document.createElement('div');
            bookItem.className = 'world-book-item';
            bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="forum-book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="forum-book-${book.id}" class="world-book-name">${book.name}</label>`;
            worldBookList.appendChild(bookItem);
        });
    } else {
        worldBookList.innerHTML = '<p style="color: #888; text-align: center;">还没有创建任何世界书。</p>';
    }

    // 3. 填充风格描述
    document.getElementById('forum-style-description').value = state.forumSettings.styleDescription || '';
// 在 renderForumSettingsUI 函数的末尾，添加下面这段代码

    // ▼▼▼ 开始添加新代码 ▼▼▼
    // 4. 填充允许发帖的角色列表
    const postersList = document.getElementById('forum-allowed-posters-list');
    postersList.innerHTML = ''; // 先清空

    // 筛选出所有非群聊的联系人
    const characters = state.contacts.filter(c => !c.isGroup);

    if (characters.length > 0) {
        characters.forEach(char => {
            // 检查这个角色是否已经在我们的“白名单”里了
            const isChecked = state.forumSettings.allowedPosterIds && state.forumSettings.allowedPosterIds.includes(char.id);
            const charItem = document.createElement('div');
            charItem.className = 'world-book-item'; // 复用现有样式
            charItem.innerHTML = `
                <input type="checkbox" class="world-book-checkbox poster-checkbox" id="poster-char-${char.id}" value="${char.id}" ${isChecked ? 'checked' : ''}>
                <label for="poster-char-${char.id}" class="world-book-name">${char.name}</label>
            `;
            postersList.appendChild(charItem);
        });
    } else {
        postersList.innerHTML = '<p style="color: #888; text-align: center;">你还没有创建任何角色联系人。</p>';
    }
    // ▲▲▲ 新代码添加结束 ▲▲▲
}
// ✨✨✨ 新函数粘贴结束 ✨✨✨
// ==========================================================
// =========== ▼▼▼ 全新：自由外观设置功能逻辑 ▼▼▼ ==========
// ==========================================================

let userSettings = {
    id: 'main',
    chatBackground: null, 
    customBubbleCss: '',  
    customFontUrl: '',    
    customFontName: '',
    customThemeCss: '',    // <-- 新增这一行
    customNarrativeCss: '',
    customFontSize: null
};

// 函数：动态更新自定义字体
function updateCustomFont(fontUrl, fontName) {
    let styleTag = document.getElementById('custom-font-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-font-style';
        document.head.appendChild(styleTag);
    }

    if (fontUrl && fontName) {
        // 创建 @font-face 规则来加载外部字体，并应用它
        const fontFaceRule = `
            @font-face {
                font-family: '${fontName}';
                src: url('${fontUrl}');
            }
        `;
        // 更新 --main-font 变量
        document.documentElement.style.setProperty('--main-font', `'${fontName}', 'Nunito', sans-serif`);
        styleTag.textContent = fontFaceRule;
    } else {
        // 如果URL或名称为空，则恢复默认字体并清空style标签
        document.documentElement.style.setProperty('--main-font', `'Nunito', sans-serif`);
        styleTag.textContent = '';
    }
}

// 函数：动态更新自定义气泡CSS
function updateCustomBubbles(cssString) {
    let styleTag = document.getElementById('custom-bubble-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-bubble-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; // 如果CSS字符串为空，则清空样式
}
// 函数：动态更新自定义叙事模式CSS
function updateCustomNarrative(cssString) {
    let styleTag = document.getElementById('custom-narrative-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-narrative-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; 
}
// 函数：动态更新全局字体大小
function updateCustomFontSize(size) {
    let styleTag = document.getElementById('custom-font-size-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-font-size-style';
        document.head.appendChild(styleTag);
    }

    if (size && !isNaN(size) && size >= 12) {
        // 为应用内的主要文字元素生成覆盖样式
        styleTag.textContent = `
            /* 全局基础字号 */
            body, .form-input, .form-textarea, .detail-value {
                font-size: ${size}px !important;
            }
            /* 聊天气泡字号 */
            .message {
                font-size: ${size}px !important;
            }
            /* 输入框字号 */
            #message-input, #comment-input {
                font-size: ${size}px !important;
            }
            /* 论坛和日记正文字号 */
            .post-text, .comment-content, .diary-entry-content {
                font-size: ${size}px !important;
                line-height: 1.6 !important; /* 相应调整行高 */
            }
        `;
    } else {
        // 如果没有设置或值无效，则清空样式，恢复默认
        styleTag.textContent = '';
    }
}
// 函数：动态更新自定义主题CSS
function updateCustomTheme(cssString) {
    let styleTag = document.getElementById('custom-theme-style');
    if (!styleTag) {
        styleTag = document.createElement('style');
        styleTag.id = 'custom-theme-style';
        document.head.appendChild(styleTag);
    }
    styleTag.textContent = cssString || ''; 
}

// 函数：应用所有保存的设置
function applyAppearanceSettings() {
    // 1. 应用背景
    const chatScreen = document.getElementById('chat-screen');
    if (userSettings.chatBackground) {
        chatScreen.style.backgroundImage = `url(${userSettings.chatBackground})`;
    } else {
        // 恢复到CSS文件中的默认样式
        chatScreen.style.backgroundImage = ''; 
    }

    // 2. 应用自定义气泡样式
    updateCustomBubbles(userSettings.customBubbleCss);
    // 3. 应用自定义主题样式
updateCustomTheme(userSettings.customThemeCss);
// 4. 应用自定义叙事样式
updateCustomNarrative(userSettings.customNarrativeCss);
// 5. 应用自定义字体大小 (新加)
updateCustomFontSize(userSettings.customFontSize);
    
    // 3. 应用自定义字体
    updateCustomFont(userSettings.customFontUrl, userSettings.customFontName);
}

async function loadAppearanceSettings() {
    const savedSettings = await kokoMemory.get('userSettings', 'main');
    if (savedSettings) {
        userSettings = { ...userSettings, ...savedSettings };
    }
    
    // ▼▼▼ 新增下面这2行 ▼▼▼
    autoLockDelay = userSettings.autoLockDelay || 0; // 加载延迟设置
    document.getElementById('auto-lock-delay-input').value = autoLockDelay > 0 ? autoLockDelay : '';

    applyAppearanceSettings();
}

// 函数：保存当前设置到数据库
async function saveAppearanceSettings() {
    // 从UI控件读取当前用户的输入
    userSettings.customBubbleCss = document.getElementById('bubble-css-input').value.trim();
    userSettings.customThemeCss = document.getElementById('theme-css-input').value.trim();
userSettings.customNarrativeCss = document.getElementById('narrative-css-input').value.trim();
// 新增下面这行：将输入框的值转为数字，如果为空则存为 null
userSettings.customFontSize = parseFloat(document.getElementById('font-size-input').value) || null; // <-- 新增这一行
    userSettings.customFontUrl = document.getElementById('font-url-input').value.trim();
    userSettings.customFontName = document.getElementById('font-name-input').value.trim().replace(/[^a-zA-Z0-9]/g, ''); // 只保留字母和数字作为字体名
    userSettings.autoLockDelay = parseInt(document.getElementById('auto-lock-delay-input').value, 10) || 0;
    autoLockDelay = userSettings.autoLockDelay; // 更新全局变量
    
    // 背景图在上传时已实时保存到 userSettings.chatBackground
    
    if (userSettings.customFontUrl && !userSettings.customFontName) {
        alert("请输入一个CSS字体名称！");
        return;
    }
    
    await kokoMemory.put('userSettings', userSettings);
    alert('外观设置已应用并保存！');
    applyAppearanceSettings(); // 再次应用以确保所有更改都生效
}
// 请将下面这个完整的函数，粘贴到刚才删除代码的位置
function attachEventListeners() {
// ▼▼▼ 使用这个【逻辑反转版】的完整函数，替换掉旧的 openGroupSettingsScreen 函数 ▼▼▼

function openGroupSettingsScreen(group) {
    hideAllScreens();
    const screen = document.getElementById('group-settings-screen');
    screen.style.display = 'flex';

    // 1. 填充基本信息
    document.getElementById('group-user-mask-textarea').value = group.userPersona || '';
    document.getElementById('group-memory-share-toggle').checked = group.memoryShared;
    document.getElementById('group-time-awareness-toggle').checked = group.isTimeAware;
    
    const memberCountEl = document.getElementById('group-member-count');
    if(memberCountEl) memberCountEl.textContent = group.members.length;

    // 2. 填充并选中世界书
    const worldBookList = document.getElementById('group-world-book-selector-list');
    worldBookList.innerHTML = '';
    state.worldBooks.forEach(book => {
        const isChecked = group.worldBooks && group.worldBooks.includes(book.id);
        const bookItem = document.createElement('div');
        bookItem.className = 'world-book-item';
        bookItem.innerHTML = `<input type="checkbox" class="world-book-checkbox" id="group-book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}><label for="group-book-${book.id}" class="world-book-name">${book.name}</label>`;
        worldBookList.appendChild(bookItem);
    });

    // 3. 填充并选中用户面具预设
    const personaSelect = document.getElementById('group-select-user-persona-preset');
    personaSelect.innerHTML = '<option value="">-- 选择或输入自定义面具 --</option>';
    state.userPersonaPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        if(group.userPersona === preset.description) {
            option.selected = true;
        }
        personaSelect.appendChild(option);
    });

    // 4. 填充成员列表
    const membersListEl = document.getElementById('group-members-list');
    membersListEl.innerHTML = '';
    group.members.forEach(memberId => {
        const profile = (memberId === 'myProfile') ? state.myProfile : state.contacts.find(c => c.id === memberId);
        if (profile) {
            const isMuted = (group.mutedMembers || []).includes(memberId);
            const item = document.createElement('div');
            item.className = 'contact-picker-item';
            item.innerHTML = `
                <img src="${profile.avatar}" alt="${profile.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                <span style="flex-grow: 1;">${profile.name} ${memberId === 'myProfile' ? '(你)' : ''}</span>
                ${memberId !== 'myProfile' ? `
                    
                    <button class="preset-action-btn mute-member-btn ${!isMuted ? 'active' : ''}" data-member-id="${memberId}" title="${isMuted ? '解除禁言' : '禁言'}">
                        <i class="fas ${isMuted ? 'fa-bell-slash' : 'fa-bell'}"></i>
                    </button>
                    
                    <button class="preset-action-btn delete remove-member-btn" data-member-id="${memberId}" title="移出群聊">
                        <i class="fas fa-times"></i>
                    </button>
                ` : ''}
            `;
            membersListEl.appendChild(item);
        }
    });

    // 5. 为页面上的按钮绑定一次性事件监听器
    const oldSaveBtn = document.getElementById('save-group-settings-btn');
    const newSaveBtn = oldSaveBtn.cloneNode(true);
    oldSaveBtn.parentNode.replaceChild(newSaveBtn, oldSaveBtn);
    newSaveBtn.addEventListener('click', async () => {
        group.userPersona = document.getElementById('group-user-mask-textarea').value.trim();
        group.memoryShared = document.getElementById('group-memory-share-toggle').checked;
        group.isTimeAware = document.getElementById('group-time-awareness-toggle').checked;
        group.worldBooks = Array.from(document.querySelectorAll('#group-world-book-selector-list .world-book-checkbox:checked')).map(cb => cb.value);
        await kokoMemory.put('contacts', group);
        alert('群聊设置已保存！');
        showCharProfileScreen();
    }, { once: true });
    
    const oldDisbandBtn = document.getElementById('disband-group-btn');
    const newDisbandBtn = oldDisbandBtn.cloneNode(true);
    oldDisbandBtn.parentNode.replaceChild(newDisbandBtn, oldDisbandBtn);
    newDisbandBtn.addEventListener('click', async () => {
        const confirmed = await showCustomConfirm('确认操作', `确定要解散群聊“${group.name}”吗？\n此操作会删除群聊及所有聊天记录，无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== group.id);
            await kokoMemory.delete('contacts', group.id);
            state.activeChatId = null;
            alert('群聊已解散。');
            await showMainScreen();
        }
    }, { once: true });
    
    const oldBackBtn = document.getElementById('back-from-group-settings');
    const newBackBtn = oldBackBtn.cloneNode(true);
    oldBackBtn.parentNode.replaceChild(newBackBtn, oldBackBtn);
    newBackBtn.addEventListener('click', () => {
        screen.style.display = 'none';
        openChat(state.activeChatId);
    }, { once: true });

    const oldPersonaSelect = document.getElementById('group-select-user-persona-preset');
    const newPersonaSelect = oldPersonaSelect.cloneNode(true);
    oldPersonaSelect.parentNode.replaceChild(newPersonaSelect, oldPersonaSelect);
    newPersonaSelect.addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('group-user-mask-textarea').value = preset ? preset.description : '';
    });
}

// ==========================================================
    // =========== ▼▼▼ 全新：群聊功能核心逻辑 ▼▼▼ ==========
    // ==========================================================
    const createGroupBtn = document.getElementById('create-group-btn');
    if (createGroupBtn) {
        createGroupBtn.addEventListener('click', () => {
            const modal = document.getElementById('create-group-modal');
            const memberListEl = document.getElementById('group-member-picker-list');
            const groupNameInput = document.getElementById('group-name-input');
            groupNameInput.value = '';
            memberListEl.innerHTML = '';

            // 动态加载可选的群成员
            state.contacts.forEach(contact => {
                if (contact.isGroup) return; // 不能把群聊加到群聊里
                const item = document.createElement('div');
                item.className = 'contact-picker-item';
                item.innerHTML = `
                    <input type="checkbox" id="member-check-${contact.id}" value="${contact.id}">
                    <label for="member-check-${contact.id}" style="display: flex; align-items: center; width: 100%; cursor: pointer;">
                        <img src="${contact.avatar}" alt="${contact.name}" style="width: 40px; height: 40px; border-radius: 50%; margin-right: 10px;">
                        <span>${contact.name}</span>
                    </label>
                `;
                memberListEl.appendChild(item);
            });
            
            modal.style.display = 'flex';
        });
    }

    document.getElementById('close-create-group-modal').addEventListener('click', () => {
        document.getElementById('create-group-modal').style.display = 'none';
    });

    document.getElementById('confirm-create-group-btn').addEventListener('click', async () => {
        const groupName = document.getElementById('group-name-input').value.trim();
        if (!groupName) {
            return alert('请给你的群聊起个名字！');
        }

        const selectedMemberIds = Array.from(document.querySelectorAll('#group-member-picker-list input:checked')).map(input => input.value);
        if (selectedMemberIds.length < 2) {
            return alert('群聊至少需要2位AI成员哦！');
        }
        
        // ✨ 核心改动：新增 mutedMembers: [] 属性，为禁言功能做准备
        const newGroup = {
            id: 'group_' + Date.now(),
            name: groupName,
            avatar: '',
            isGroup: true,
            members: ['myProfile', ...selectedMemberIds],
            history: [],
            memoryShared: true,
            mutedMembers: [], // 初始化禁言列表
        };

        state.contacts.push(newGroup);
        await kokoMemory.put('contacts', newGroup);
        
        // 临时切换 activeChatId 来正确添加第一条系统消息
        const tempActiveChatId = state.activeChatId;
        state.activeChatId = newGroup.id;
        await createAndAddMessage({
            type: 'system_notification',
            sender: 'system',
            content: `你创建了群聊`
        });
        state.activeChatId = tempActiveChatId;

        await renderContacts();
        document.getElementById('create-group-modal').style.display = 'none';
        openChat(newGroup.id);
    });
    // ==========================================================
    // V9.0 新增：悬浮播放器拖动逻辑 (支持鼠标和触摸)
    // ==========================================================
    const card = document.getElementById('music-player-card');
    const header = document.getElementById('player-header');
    let isDragging = false,
        cardX = 50,
        cardY = 50,
        dragStartX = 0,
        dragStartY = 0;
    card.style.left = `${cardX}px`;
    card.style.top = `${cardY}px`;

    function dragStart(e) {
        isDragging = true;
        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        dragStartX = clientX;
        dragStartY = clientY;
        card.style.transition = 'none';
    }

    function dragMove(e) {
        if (isDragging) {
            if (e.type === 'touchmove') e.preventDefault();
            const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
            const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
            const deltaX = clientX - dragStartX;
            const deltaY = clientY - dragStartY;
            card.style.left = `${cardX + deltaX}px`;
            card.style.top = `${cardY + deltaY}px`;
        }
    }

    function dragEnd(e) {
        if (isDragging) {
            isDragging = false;
            const clientX = e.type === 'touchend' ? e.changedTouches[0].clientX : e.clientX;
            const clientY = e.type === 'touchend' ? e.changedTouches[0].clientY : e.clientY;
            cardX += (clientX - dragStartX);
            cardY += (clientY - dragStartY);
            card.style.transition = 'all 0.4s ease-in-out';
        }
    }
    header.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', dragMove);
    document.addEventListener('mouseup', dragEnd);
    header.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', dragMove, {
        passive: false
    });
    document.addEventListener('touchend', dragEnd);

    let currentlyPlayingMsgId = null;
    
 // --- 原有功能：数据导入导出 ---
document.getElementById('export-data-btn').addEventListener('click', exportData);

// ▼▼▼ 在这里添加新的一行代码 ▼▼▼
document.getElementById('export-light-data-btn').addEventListener('click', exportLightData);
// ▲▲▲ 添加结束 ▲▲▲

document.getElementById('import-data-btn').addEventListener('click', () => {
    document.getElementById('import-file-input').click();
});
    document.getElementById('import-file-input').addEventListener('change', importData);

    // --- 原有功能：头像更换 ---
    document.getElementById('change-avatar-btn').addEventListener('click', function() {
        handleAvatarUpload(async (base64String) => {
            state.myProfile.avatar = base64String;
            await kokoMemory.put('myProfile', state.myProfile);
            renderMyProfile();
        });
    });
    document.getElementById('change-char-avatar-btn').addEventListener('click', () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        handleAvatarUpload(async (base64String) => {
            contact.avatar = base64String;
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
            renderContacts();
        });
    });

    // --- 原有功能：底部导航栏 ---
    document.querySelectorAll('#nav-chat, #nav-chat-2, #nav-chat-discover').forEach(el => el.addEventListener('click', showMainScreen));
    document.querySelectorAll('#nav-discover, #nav-discover-2, #nav-discover-discover').forEach(el => el.addEventListener('click', showDiscoverScreen));
    document.querySelectorAll('#nav-profile, #nav-profile-2, #nav-profile-discover').forEach(el => el.addEventListener('click', showProfileScreen));

    // --- 原有功能：发现页跳转 ---
    document.getElementById('user-persona-presets-btn').addEventListener('click', showUserPersonaManagementScreen);
    document.getElementById('emoticon-library-btn').addEventListener('click', showEmoticonLibraryScreen);
    document.getElementById('music-library-btn').addEventListener('click', showMusicLibraryScreen);
    document.getElementById('thought-presets-btn').addEventListener('click', showThoughtPresetManagementScreen);
    document.getElementById('world-book-btn').addEventListener('click', () => {
        hideAllScreens();
        document.getElementById('world-book-screen').style.display = 'flex';
        renderWorldBooks();
    });
document.getElementById('api-settings-btn').addEventListener('click', async () => {
    hideAllScreens();
    document.getElementById('api-settings-screen').style.display = 'flex';
    document.getElementById('api-key-input').value = state.apiSettings.apiKey;
    document.getElementById('api-endpoint-input').value = state.apiSettings.endpoint;
    document.getElementById('context-length-input').value = state.apiSettings.contextLength;
    document.getElementById('long-term-memory-length-input').value = state.apiSettings.longTermMemoryLength;

    // ▼▼▼ 新增这两行 ▼▼▼
    document.getElementById('minimax-group-id-input').value = state.apiSettings.minimaxGroupId || '';
    document.getElementById('minimax-api-key-input').value = state.apiSettings.minimaxApiKey || '';
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增这一行 ▼▼▼
document.getElementById('siliconflow-api-key-input').value = state.apiSettings.siliconflowApiKey || '';

    updateModelDropdown([state.apiSettings.model], document.getElementById('model-select'), state.apiSettings.model);

    await renderApiPresetDropdown(); 
});
    document.getElementById('square-api-settings-btn').addEventListener('click', async () => {
        hideAllScreens();
        document.getElementById('square-api-settings-screen').style.display = 'flex';
        document.getElementById('square-api-key-input').value = state.squareApiSettings.apiKey;
        document.getElementById('square-api-endpoint-input').value = state.squareApiSettings.endpoint;
        updateModelDropdown([state.squareApiSettings.model], document.getElementById('square-model-select'), state.squareApiSettings.model);
        await renderForumSettingsUI();
    });
    document.getElementById('moments-btn').addEventListener('click', showFeedScreen);

    // --- 原有功能：各页面返回按钮 ---
    document.getElementById('back-from-user-persona-management').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-emoticon-library').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-music-library').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-thought-presets').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-world-book').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-api').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-square-api').addEventListener('click', showDiscoverScreen);
    // ✅✅✅ 最终的正确代码 ✅✅✅
document.getElementById('back-from-chat').addEventListener('click', async () => {
    if (editModeState.active) await exitEditMode();
    document.getElementById('chat-pet-container').style.display = 'none';
    currentlyPlayingMsgId = null;
    
    // <-- 核心修复：回到主列表时，必须告诉程序你没有在任何聊天里了！
    state.activeChatId = null; 
    
    await showMainScreen();
});
    document.getElementById('back-from-contact-settings').addEventListener('click', () => {
        document.getElementById('contact-settings-screen').style.display = 'none';
        showCharProfileScreen();
    });
    document.getElementById('back-from-moments').addEventListener('click', showDiscoverScreen);
    document.getElementById('back-from-char-profile').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact && contact.isChatPetVisible && batchedPetActions.length > 0) {
            const summary = batchedPetActions.join('，');
            const systemPrompt = `[角色后台指令：用户刚刚在宠物界面进行了一系列操作：“${summary}”。你的任务是，不要逐条复述这些操作日志，而是对此事发表一句连贯、自然的口语化评论来衔接对话。例如，你可以问：“刚刚去照顾咱们的史莱姆啦？”或者说：“看你把它喂得饱饱的，真好。”]`;
            await requestAiReply(systemPrompt);
        }
        batchedPetActions = [];
        document.getElementById('char-profile-screen').style.display = 'none';
        document.getElementById('chat-screen').style.display = 'flex';
    });
    document.getElementById('back-from-diary').addEventListener('click', showCharProfileScreen);
    document.getElementById('back-from-post-detail').addEventListener('click', showFeedScreen);
    document.getElementById('back-from-trending-topic').addEventListener('click', showFeedScreen);
    // ▼▼▼ 这整段代码在新版本中都缺失了 ▼▼▼
document.getElementById('refresh-post-comments-btn').addEventListener('click', async () => {
    const post = state.posts.find(p => p.id === state.activePostId);
    if (!post) return;

    showFeedStatus('正在加载新评论...');
    try {
        await generateMoreCommentsForPost(post);
        await kokoMemory.put('posts', post);
        await renderPostDetail();

    } catch(e) {
        console.error("刷新评论失败:", e);
        alert("刷新评论失败: " + e.message);
    } finally {
        hideFeedStatus();
    }
});
    const backFromMemoryAlbumBtn = document.getElementById('back-from-memory-album');
    if (backFromMemoryAlbumBtn) {
        backFromMemoryAlbumBtn.addEventListener('click', showCharProfileScreen);
    }

    document.getElementById('send-btn').addEventListener('click', sendMessage);
    document.getElementById('request-reply-btn').addEventListener('click', () => requestAiReply());
    document.getElementById('message-input').addEventListener('keypress', e => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendMessage();
        }
    });
    
    document.getElementById('cancel-edit-btn').addEventListener('click', exitEditMode);
    document.getElementById('delete-selected-btn').addEventListener('click', async () => {
    if (editModeState.selectedMessageIds.size === 0) {
        return alert('请先选择要删除的消息。');
    }
    const confirmed = await showCustomConfirm('删除消息', `确定要删除选中的 ${editModeState.selectedMessageIds.size} 条消息吗？`, true);
    if (confirmed) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (contact) {
            const createKey = (song) => `${(song.title || '').trim()}|${(song.artist || '').trim()}`;
            const librarySongKeys = new Set(state.musicLibrary.map(createKey));

            const deletedTempMusicMessages = contact.history.filter(msg =>
                editModeState.selectedMessageIds.has(msg.id) &&
                msg.type === 'music_share' &&
                !librarySongKeys.has(createKey(msg.content))
            );

            if (deletedTempMusicMessages.length > 0) {
                const deletedTempSongKeys = new Set(deletedTempMusicMessages.map(msg => createKey(msg.content)));
                const currentTrack = contact.sharedPlaylist.tracks[contact.sharedPlaylist.currentIndex];
                
                if (currentTrack && deletedTempSongKeys.has(createKey(currentTrack))) {
                    globalAudioPlayer.pause();
                    globalAudioPlayer.src = '';
                    contact.sharedPlaylist.currentIndex = 0;
                    closeMusicPlayer();
                }
            }
            
            contact.history = contact.history.filter(msg => !editModeState.selectedMessageIds.has(msg.id));
            
            await kokoMemory.put('contacts', contact);
            await renderContacts();

            const musicPlayerCard = document.getElementById('music-player-card');
            if (musicPlayerCard.style.display === 'flex' && state.musicSessionContactId === contact.id) {
                renderPlaylist();
            }
        }
        await exitEditMode();
    }
});

// --- 用这个新版本，替换掉旧的 'char-more-info-btn' 事件监听代码 ---

document.getElementById('char-more-info-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    if (contact.isGroup) {
        openGroupSettingsScreen(contact);
    } else {
        const avatarPreview = document.getElementById('custom-user-avatar-preview');
        if (contact.customUserAvatar) {
            avatarPreview.src = contact.customUserAvatar;
            avatarPreview.style.display = 'block';
        } else {
            avatarPreview.style.display = 'none';
        }

        document.getElementById('char-mask-textarea').value = contact.persona;
        document.getElementById('user-mask-textarea').value = contact.userPersona || '';
        const currentPersonaPreset = state.userPersonaPresets.find(p => p.description === contact.userPersona);
        document.getElementById('select-user-persona-preset').value = currentPersonaPreset ? currentPersonaPreset.id : '';
        
        // ▼▼▼ 核心修复从这里开始 ▼▼▼
        // ✨✨✨ 在这里加上下面这行新代码！ ✨✨✨
await populateThoughtPresetSelect();

        const thoughtPresetSelect = document.getElementById('thought-preset-select');
        const savedThoughtPresetId = contact.thoughtPreset;

        // 检查联系人保存的预设ID是否仍然存在于预设列表中
        const thoughtPresetExists = state.thoughtPresets.some(p => p.id === savedThoughtPresetId);

        if (savedThoughtPresetId && thoughtPresetExists) {
            // 如果预设确实还存在，就正常选中它
            thoughtPresetSelect.value = savedThoughtPresetId;
        } else {
            // 如果预设不存在（说明已被删除），就重置为空，并顺便清理掉角色身上的无效ID
            thoughtPresetSelect.value = ""; // 在界面上选中“无预设”
            contact.thoughtPreset = ""; // 清理掉角色数据里的无效ID
        }
        // ▲▲▲ 核心修复到这里结束 ▲▲▲

        document.querySelectorAll('.world-book-checkbox').forEach(cb => {
            cb.checked = (contact.worldBooks || []).includes(cb.value);
        });
        document.getElementById('narrative-mode-toggle').checked = contact.isNarrativeMode;
        document.getElementById('time-awareness-toggle').checked = contact.isTimeAware ?? false;
        document.getElementById('hide-avatar-toggle').checked = contact.isAvatarHidden;
        // ▼▼▼ 使用这两行替换上面那一行 ▼▼▼
document.getElementById('char-voice-provider-select').value = contact.voiceProvider || '';
document.getElementById('char-voice-id-input').value = contact.voiceId || '';
        
        document.getElementById('char-profile-screen').style.display = 'none';
        document.getElementById('contact-settings-screen').style.display = 'flex';
        await updateContactMapSelector();
    }
});
        // ▲▲▲ 替换结束 ▲▲▲

        // ▼▼▼ 把这段全新的代码，完整地粘贴到 attachEventListeners 函数的【末尾】 ▼▼▼
        // --- 新增：为联系人设置页面的新按钮绑定事件 ---
        document.getElementById('upload-contact-background-btn').addEventListener('click', () => {
            const uploader = document.getElementById('contact-background-uploader');
            uploader.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const contact = state.contacts.find(c => c.id === state.activeChatId);
                    if (!contact) return;
                    contact.customChatBackground = event.target.result;
                    await kokoMemory.put('contacts', contact);
                    alert('专属聊天背景已更新！');
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            };
            uploader.click();
        });

        document.getElementById('reset-contact-background-btn').addEventListener('click', async () => {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            contact.customChatBackground = null;
            await kokoMemory.put('contacts', contact);
            alert('背景已恢复默认。');
        });

        document.getElementById('upload-contact-user-avatar-btn').addEventListener('click', () => {
            const uploader = document.getElementById('contact-user-avatar-uploader');
            uploader.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const contact = state.contacts.find(c => c.id === state.activeChatId);
                    if (!contact) return;
                    const base64 = event.target.result;
                    contact.customUserAvatar = base64;
                    await kokoMemory.put('contacts', contact);
                    document.getElementById('custom-user-avatar-preview').src = base64;
                    document.getElementById('custom-user-avatar-preview').style.display = 'block';
                    alert('专属头像已更新！');
                };
                reader.readAsDataURL(file);
                e.target.value = '';
            };
            uploader.click();
        });
        
        document.getElementById('reset-contact-user-avatar-btn').addEventListener('click', async () => {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if (!contact) return;
            contact.customUserAvatar = null;
            await kokoMemory.put('contacts', contact);
            document.getElementById('custom-user-avatar-preview').style.display = 'none';
            alert('头像已恢复为你的全局默认头像。');
        });
        // ▲▲▲ 新增代码粘贴到这里结束 ▲▲▲
    document.getElementById('view-char-diary-btn').addEventListener('click', showDiaryScreen);
    // ▼▼▼ 将这段完整的代码粘贴到 attachEventListeners 函数中 ▼▼▼
document.getElementById('diary-content-list').addEventListener('click', async (e) => {
    // 检查点击的是不是删除按钮
    if (e.target.closest('.diary-delete-btn')) {
        const diaryId = e.target.closest('.diary-delete-btn').dataset.diaryId;
        const confirmed = await showCustomConfirm('删除日记', '确定要删除这条日记吗？', true);
        if (confirmed) {
            const contact = state.contacts.find(c => c.id === state.activeChatId);
            if(contact && contact.diary) {
                // 从联系人的日记数组中过滤掉要删除的条目
                contact.diary = contact.diary.filter(entry => entry.id !== diaryId);
                // 保存更改到数据库
                await kokoMemory.put('contacts', contact);
                // 重新渲染日记列表，让界面刷新
                renderDiary();
            }
        }
    }
});
    document.getElementById('delete-contact-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const confirmed = await showCustomConfirm('删除联系人', `⚠️ 警告：确定要永久删除联系人 "${contact.name}" 吗？\n\n此操作将删除其所有聊天记录和日记，且无法恢复！`, true);
        if (confirmed) {
            state.contacts = state.contacts.filter(c => c.id !== state.activeChatId);
            await kokoMemory.delete('contacts', state.activeChatId);
            state.activeChatId = null;
            alert(`联系人 "${contact.name}" 已被删除。`);
            await showMainScreen();
        }
    });
    document.getElementById('clear-chat-history-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const confirmed = await showCustomConfirm('清空记录', `确定要清空与 "${contact.name}" 的所有聊天记录吗？\n此操作不可恢复。`, true);
        if (confirmed) {
            contact.history = [];
            await kokoMemory.put('contacts', contact);
            alert('聊天记录已清空。');
            document.getElementById('contact-settings-screen').style.display = 'none';
            showCharProfileScreen();
        }
    });
    document.getElementById('char-profile-screen').addEventListener('click', async (e) => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        if (e.target.id === 'adopt-pet-btn') {
            contact.pet = {
                name: '史莱姆',
                stage: 1,
                happiness: 80,
                hunger: 80,
                cleanliness: 100,
                lastUpdated: Date.now(),
                workFinishTimestamp: null,
                xp: 0,
                level: 1,
                form: 'baby'
            };
            await kokoMemory.put('contacts', contact);
            renderPet(contact);
            await requestAiReply(`[SYSTEM: 我们刚刚领养了一只宠物史莱姆！请开心地和我说这件事。]`);
        } else if (e.target.id === 'feed-pet-btn') {
            if (contact.gold_coins >= 5) {
                contact.gold_coins -= 5;
                await updatePetStats('hunger', 20, contact);
                renderPet(contact);
                batchedPetActions.push(`你喂食了它`);
                triggerPetAnimation('blush');
            } else {
                alert('金币不足！快去打工吧！');
            }
        } else if (e.target.id === 'play-pet-btn') {
            await updatePetStats('happiness', 20, contact);
            renderPet(contact);
            batchedPetActions.push(`你陪它玩耍了`);
            triggerPetAnimation('jiggle');
        } else if (e.target.id === 'clean-pet-btn') {
            await updatePetStats('cleanliness', 40, contact);
            renderPet(contact);
            batchedPetActions.push(`你帮它打扫干净了`);
        } else if (e.target.id === 'work-pet-btn') {
            contact.pet.workFinishTimestamp = Date.now() + (1000 * 60 * 60); // 1 hour
            await kokoMemory.put('contacts', contact);
            renderPet(contact);
            setTimeout(async () => {
                const currentContact = await kokoMemory.get('contacts', contact.id);
                if (currentContact && currentContact.pet) {
                    currentContact.gold_coins += 50;
                    currentContact.pet.workFinishTimestamp = null;
                    await kokoMemory.put('contacts', currentContact);
                    state.contacts = await kokoMemory.getAll('contacts');
                    await createAndAddMessage({
                        type: 'system_notification',
                        sender: 'system',
                        content: `你们的史莱姆'${currentContact.pet.name}'打工回来啦！赚了50金币！`
                    });
                    if (state.activeChatId === currentContact.id && document.getElementById('char-profile-screen').style.display === 'flex') {
                        renderPet(currentContact);
                    }
                }
            }, 1000 * 60 * 60);
        } else if (e.target.id === 'view-memory-album-btn' || e.target.closest('#view-memory-album-btn')) {
            showMemoryAlbum(contact);
        } else if (e.target.id === 'pet-name') {
            const newName = await showCustomPrompt('给你的史莱姆起一个新名字吧：', contact.pet.name);
            if (newName && newName.trim()) {
                contact.pet.name = newName.trim();
                await kokoMemory.put('contacts', contact);
                renderPet(contact);
            }
        }
    });
    document.getElementById('edit-char-name-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const newName = await showCustomPrompt('设置备注名', contact.name);
        if (newName !== null && newName.trim() !== '') {
            contact.name = newName.trim();
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
            document.getElementById('chat-contact-name').textContent = contact.name;
            await renderContacts();
        }
    });
    document.getElementById('edit-char-signature-btn').addEventListener('click', async () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const newSignature = await showCustomPrompt('设置签名', contact.signature || '');
        if (newSignature !== null) {
            contact.signature = newSignature.trim();
            await kokoMemory.put('contacts', contact);
            showCharProfileScreen();
        }
    });

    // --- 原有功能：我的资料页编辑按钮 ---
    document.querySelectorAll('.profile-details .edit-btn[data-field]').forEach(button => {
        button.addEventListener('click', async function() {
            const field = this.dataset.field;
            const currentValue = state.myProfile[field];
            const title = `修改 ${fieldNameToChinese(field)}`;
            const newValue = await showCustomPrompt(title, currentValue);
            if (newValue !== null) {
                state.myProfile[field] = newValue.trim();
                renderMyProfile();
                await kokoMemory.put('myProfile', state.myProfile);
            }
        });
    });
    document.getElementById('edit-status-btn').addEventListener('click', async () => {
        const currentStatus = state.myProfile.status;
        const newStatus = await showCustomPrompt('修改我的状态', currentStatus);
        if (newStatus !== null) {
            state.myProfile.status = newStatus.trim();
            await kokoMemory.put('myProfile', state.myProfile);
            renderMyProfile();
        }
    });
    document.getElementById('initialize-app-btn').addEventListener('click', async function() {
        const confirmed = await showCustomConfirm('初始化应用', '警告：这会清空所有保存的数据（联系人、世界书、论坛帖子、API设置等）并恢复到初始状态。确定要继续吗？', true);
        if (confirmed) {
            await kokoMemory.deleteDatabase();
            window.location.reload();
        }
    });
  // ==========================================================
  // --- 音乐分享弹窗 - 新增的事件监听 ---
document.getElementById('music-share-tabs').addEventListener('click', (e) => {
    if (e.target.classList.contains('feed-tab-btn')) {
        switchMusicShareTab(e.target.dataset.tab);
    }
});

document.getElementById('confirm-manual-share-btn').addEventListener('click', () => {
    const songData = {
        url: document.getElementById('manual-music-url-input').value.trim(),
        title: document.getElementById('manual-music-title-input').value.trim(),
        artist: document.getElementById('manual-music-artist-input').value.trim(),
        lrc: document.getElementById('manual-music-lrc-input').value.trim().replace(/\\n/g, '\n')
    };
    shareSongToChat(songData);
});

// 为在线搜索的按钮和输入框绑定事件（确保即使弹窗被重新创建也能正常工作）
document.getElementById('send-music-modal').addEventListener('click', (e) => {
    if (e.target.id === 'online-music-search-btn' || e.target.closest('#online-music-search-btn')) {
        searchMusicInModal();
    }
});
document.getElementById('send-music-modal').addEventListener('keypress', (e) => {
    if (e.target.id === 'online-music-search-input' && e.key === 'Enter') {
        searchMusicInModal();
    }
});
    // =========== ▼▼▼ 购物中心事件连接 V3 ▼▼▼ ===================
    // ==========================================================
    document.getElementById('shopping-center-btn').addEventListener('click', showShoppingScreen);
    // 新增：为购物中心主页的返回按钮添加事件
document.getElementById('back-from-shopping').addEventListener('click', showDiscoverScreen);
    // V3新增：详情页返回按钮的事件连接
document.getElementById('back-from-product-detail').addEventListener('click', () => {
    hideAllScreens();
    document.getElementById('shopping-screen').style.display = 'flex';
});


    document.getElementById('shopping-tabs-container').addEventListener('click', async (e) => {
        if (e.target.classList.contains('feed-tab-btn')) {
            activeShoppingTab = e.target.dataset.tab;
            renderShoppingTabs();
            // V3改动：切换标签页时，优先从数据库加载
            const savedProducts = await kokoMemory.get('userSettings', 'shopping_products_' + activeShoppingTab);
            if (savedProducts && savedProducts.data.length > 0) {
                renderProducts(savedProducts.data);
            } else {
                 const productList = document.getElementById('product-list');
                productList.innerHTML = `<div style="grid-column: 1 / -1; text-align: center; padding: 50px 20px; color: #888;">这里空空如也~<br>请点击右上角的刷新按钮生成商品</div>`;
            }
        }
    });

    document.getElementById('refresh-products-btn').addEventListener('click', () => refreshProductsAI(false));
    document.getElementById('product-search-btn').addEventListener('click', () => refreshProductsAI(true));
    document.getElementById('product-search-input').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            refreshProductsAI(true);
        }
    });

    // V3改动：事件委托现在需要处理两种点击：分享和进入详情
    document.getElementById('product-list').addEventListener('click', (e) => {
        const productItem = e.target.closest('.product-item');
        if (!productItem) return;

        const productData = JSON.parse(productItem.dataset.product);

        // 如果点击的是分享按钮
        if (e.target.closest('.product-share-btn')) {
            e.stopPropagation(); // 阻止事件冒泡触发详情页
            openShareProductModal(productData);
        } else { // 否则就是点击卡片本身，进入详情
            showProductDetailScreen(productData);
        }
    });
    
    // V3新增：详情页底部分享按钮的事件
    document.getElementById('share-from-detail-btn').addEventListener('click', () => {
        // currentProductData 已在 showProductDetailScreen 中被赋值
        if (currentProductData) {
            openShareProductModal(currentProductData);
        }
    });

    // 分享弹窗的按钮事件 (不变)
    document.getElementById('close-share-product-modal').addEventListener('click', () => {
        document.getElementById('share-product-modal').style.display = 'none';
    });
    document.getElementById('gift-product-btn').addEventListener('click', () => {
    const selectedRadio = document.querySelector('input[name="share-recipient"]:checked');
    if (!selectedRadio) {
        return alert('请先选择一位要分享的联系人！');
    }
    handleShareProduct('gift', selectedRadio.value);
});

document.getElementById('request-payment-btn').addEventListener('click', () => {
    const selectedRadio = document.querySelector('input[name="share-recipient"]:checked');
    if (!selectedRadio) {
        return alert('请先选择一位要分享的联系人！');
    }
    handleShareProduct('request_payment', selectedRadio.value);
});


    // ==========================================================
    // =========== ▲▲▲ 购物中心事件连接 END ▲▲▲ =================
    // ==========================================================

    // --- 原有功能：各类弹窗的逻辑 ---
    document.getElementById('add-contact-btn').addEventListener('click', () => {
        document.getElementById('add-contact-modal').style.display = 'flex';
    });
    document.getElementById('close-contact-modal').addEventListener('click', () => {
        document.getElementById('add-contact-modal').style.display = 'none';
    });
    document.getElementById('save-contact-btn').addEventListener('click', async () => {
        const name = document.getElementById('contact-name-input').value.trim();
        const persona = document.getElementById('contact-persona-input').value.trim();
        if (!name || !persona) return alert('请填写姓名和人设');
        const avatar = document.getElementById('contact-avatar-input').value.trim();
        const selectedBooks = Array.from(document.getElementById('world-book-select').selectedOptions).map(opt => opt.value);
        // ...
const newContact = {
    id: 'contact_' + Date.now(),
    name: name,
    persona: persona,
    avatar: avatar || `https://via.placeholder.com/50/${Math.floor(Math.random() * 16777215).toString(16)}/FFFFFF?text=${name.substring(0, 1).toUpperCase()}`,
    voiceId: '',
    worldBooks: JSON.parse(JSON.stringify(selectedBooks)),
    isPinned: false,
    groupId: null,
    history: [],
    diary: [],
    userPersona: '',
    thoughtPreset: 'deep_roleplay_regex',
    signature: '',
    isNarrativeMode: false,
    apiCallCounter: 0,
    pet: null,
    gold_coins: 50,
    memories: [],
    isChatPetVisible: false,
    sharedPlaylist: {
        tracks: [],
        currentIndex: 0,
        playbackMode: 'list',
        isPlaying: false
    },
    totalListenTime: 0,
    firstChatDate: Date.now(),
    
    // ▼▼▼ 在这里添加下面这两行新代码 ▼▼▼
    schedule: [], // 存放你的课程表
    events: []    // 存放重要的日子（纪念日、生理期等）
    // ▲▲▲ 添加结束 ▲▲▲
};
// ...
        state.contacts.push(newContact);
        await kokoMemory.put('contacts', newContact);
        await renderContacts();
        document.getElementById('add-contact-modal').style.display = 'none';
    });
document.getElementById('save-contact-settings-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const oldNarrativeModeState = contact.isNarrativeMode;
    contact.persona = document.getElementById('char-mask-textarea').value;
    contact.userPersona = document.getElementById('user-mask-textarea').value;
    contact.thoughtPreset = document.getElementById('thought-preset-select').value;
    contact.worldBooks = Array.from(document.querySelectorAll('.world-book-checkbox:checked')).map(cb => cb.value);
    const newNarrativeModeState = document.getElementById('narrative-mode-toggle').checked;
    contact.isNarrativeMode = newNarrativeModeState;
    contact.isTimeAware = document.getElementById('time-awareness-toggle').checked;
    contact.isAvatarHidden = document.getElementById('hide-avatar-toggle').checked;
    contact.mapId = document.getElementById('contact-map-select').value;

    // ▼▼▼ 新增这一行 ▼▼▼
    // ▼▼▼ 使用这两行替换上面那一行 ▼▼▼
contact.voiceProvider = document.getElementById('char-voice-provider-select').value;
contact.voiceId = document.getElementById('char-voice-id-input').value.trim();
    // ▲▲▲ 新增结束 ▲▲▲

    if (oldNarrativeModeState === true && newNarrativeModeState === false) {
        contact.needsNarrativeModeExitPrompt = true;
    }
    await kokoMemory.put('contacts', contact);
    document.getElementById('contact-settings-screen').style.display = 'none';
    showCharProfileScreen();
    alert('联系人设置已保存！');
});
    document.getElementById('select-user-persona-preset').addEventListener('change', function() {
        const selectedPresetId = this.value;
        const preset = state.userPersonaPresets.find(p => p.id === selectedPresetId);
        document.getElementById('user-mask-textarea').value = preset ? preset.description : '';
    });
    document.getElementById('fetch-models-btn').addEventListener('click', (e) => {
        const apiKey = document.getElementById('api-key-input').value;
        const endpoint = document.getElementById('api-endpoint-input').value.trim();
        fetchModels(endpoint, apiKey, document.getElementById('model-select'), e.currentTarget);
    });
    document.getElementById('fetch-square-models-btn').addEventListener('click', (e) => {
        const apiKey = document.getElementById('square-api-key-input').value;
        const endpoint = document.getElementById('square-api-endpoint-input').value.trim();
        fetchModels(endpoint, apiKey, document.getElementById('square-model-select'), e.currentTarget);
    });
document.getElementById('save-api-settings-btn').addEventListener('click', async () => {
    state.apiSettings.apiKey = document.getElementById('api-key-input').value;
    state.apiSettings.model = document.getElementById('model-select').value;
    state.apiSettings.endpoint = document.getElementById('api-endpoint-input').value.trim();
    state.apiSettings.contextLength = parseInt(document.getElementById('context-length-input').value, 10) || 20;
    state.apiSettings.longTermMemoryLength = parseInt(document.getElementById('long-term-memory-length-input').value, 10) || 30;

    // ▼▼▼ 新增这两行 ▼▼▼
    state.apiSettings.minimaxGroupId = document.getElementById('minimax-group-id-input').value.trim();
    state.apiSettings.minimaxApiKey = document.getElementById('minimax-api-key-input').value.trim();
    // ▲▲▲ 新增结束 ▲▲▲
    // ▼▼▼ 新增这一行 ▼▼▼
state.apiSettings.siliconflowApiKey = document.getElementById('siliconflow-api-key-input').value.trim();

    await kokoMemory.put('apiSettings', {
        id: 'main',
        ...state.apiSettings
    });
    alert('聊天API设置已保存！');
    showDiscoverScreen();
});
// ✨✨✨ 这是修复后的新代码，请复制并替换上面那段旧代码 ✨✨✨
document.getElementById('save-square-api-settings-btn').addEventListener('click', async () => {
    // --- 1. 【新增】保存论坛专用的API设置 ---
    state.squareApiSettings.apiKey = document.getElementById('square-api-key-input').value;
    state.squareApiSettings.endpoint = document.getElementById('square-api-endpoint-input').value.trim();
    state.squareApiSettings.model = document.getElementById('square-model-select').value;
    await kokoMemory.put('squareApiSettings', { id: 'main', ...state.squareApiSettings });

    // --- 2. 读取用户输入的风格、世界观等设置 ---
    const newSettings = {
        personaId: document.getElementById('forum-persona-select').value,
        worldBookIds: Array.from(document.querySelectorAll('#forum-worldbook-list .world-book-checkbox:checked')).map(cb => cb.value),
        styleDescription: document.getElementById('forum-style-description').value.trim(),
        allowedPosterIds: Array.from(document.querySelectorAll('#forum-allowed-posters-list .poster-checkbox:checked')).map(cb => cb.value)
    };

    // --- 3. 检查与当前设置是否有变化 (这部分逻辑不变) ---
    const currentSettings = state.forumSettings;
    const isChanged = JSON.stringify(newSettings.worldBookIds.sort()) !== JSON.stringify((currentSettings.worldBookIds || []).sort()) ||
                    newSettings.styleDescription !== (currentSettings.styleDescription || '');

    // --- 4. 根据是否变化，执行存档逻辑 (这部分逻辑不变) ---
    if (isChanged && state.activeForumArchiveId === 'default' && state.posts.some(p => p.archiveId === 'default')) {
        const userChoice = await showCustomConfirm(
            '世界观已变更',
            '检测到核心世界观已修改。是否要将当前论坛存档，并开启一条新的世界线？\n\n- 选择【确定】将存档并开启新世界。\n- 选择【取消】将仅覆盖当前设定。',
            false
        );

        if (userChoice) { 
            const archiveName = await showCustomPrompt('为当前世界线命名', `存档 ${new Date().toLocaleDateString()}`);
            if (archiveName) {
                const newArchive = {
                    id: 'archive_' + Date.now(),
                    name: archiveName,
                    timestamp: Date.now(),
                    settings: JSON.parse(JSON.stringify(currentSettings))
                };
                state.forumArchives.push(newArchive);
                await kokoMemory.put('forumArchives', newArchive);
                const defaultPosts = state.posts.filter(p => p.archiveId === 'default');
                defaultPosts.forEach(p => p.archiveId = newArchive.id);
                await kokoMemory.bulkPut('posts', defaultPosts);
                state.trendingTopics = [];
                await kokoMemory.clear('trendingTopics');
                alert(`存档“${archiveName}”创建成功！即将开启新世界线...`);
            }
        }
    }

    // --- 5. 无论如何，都应用并保存新的风格设置 (这部分逻辑不变) ---
    state.forumSettings = { ...currentSettings, ...newSettings };
    await kokoMemory.put('forumSettings', { id: 'main', ...state.forumSettings });

    alert('论坛API及风格设置已保存！');
    showDiscoverScreen();
});
        
    document.getElementById('add-world-book-btn').addEventListener('click', () => {
        editingBookId = null;
        document.getElementById('world-book-modal-title').textContent = '添加世界书';
        document.getElementById('book-name-input').value = '';
        document.getElementById('book-content-input').value = '';
        document.getElementById('add-world-book-modal').style.display = 'flex';
    });
    document.getElementById('close-world-book-modal').addEventListener('click', () => {
        document.getElementById('add-world-book-modal').style.display = 'none';
    });
    // ✨✨✨ 用这个新版本，完整替换旧的 save-world-book-btn 事件监听函数 ✨✨✨

    document.getElementById('save-world-book-btn').addEventListener('click', async () => {
        const name = document.getElementById('book-name-input').value.trim();
        const content = document.getElementById('book-content-input').value.trim();
        // --- 新增代码：获取分类 ---
        const category = document.getElementById('book-category-input').value.trim() || '未分类';

        if (!name || !content) return alert('请填写书名和内容');

        if (editingBookId) {
            const book = state.worldBooks.find(b => b.id === editingBookId);
            if (book) {
                book.name = name;
                book.content = content;
                book.category = category; // --- 新增代码：更新分类 ---
                await kokoMemory.put('worldBooks', book);
            }
        } else {
            const newBook = {
                id: 'book_' + Date.now(),
                name,
                content,
                category // --- 新增代码：保存分类 ---
            };
            state.worldBooks.push(newBook);
            await kokoMemory.put('worldBooks', newBook);
        }

        // 后续逻辑保持不变
        await renderWorldBooks();
        await updateWorldBookSelectors();
        document.getElementById('add-world-book-modal').style.display = 'none';

        // 重新为删除按钮绑定事件（这一行很重要，确保新渲染的元素也能被删除）
        document.querySelectorAll('.delete-world-book-btn').forEach(btn => {
            btn.addEventListener('click', deleteWorldBook);
        });
    });
    document.getElementById('add-user-persona-preset-btn').addEventListener('click', () => {
        editingUserPersonaId = null;
        document.getElementById('user-persona-modal-title').textContent = '添加用户面具预设';
        document.getElementById('user-persona-name-input').value = '';
        document.getElementById('user-persona-description-input').value = '';
        document.getElementById('user-persona-preset-modal').style.display = 'flex';
    });
    document.getElementById('close-user-persona-preset-modal').addEventListener('click', () => {
        document.getElementById('user-persona-preset-modal').style.display = 'none';
    });
    document.getElementById('save-user-persona-preset-btn').addEventListener('click', async () => {
        const name = document.getElementById('user-persona-name-input').value.trim();
        const description = document.getElementById('user-persona-description-input').value.trim();
        if (!name || !description) return alert('请填写面具名称和描述！');
        if (editingUserPersonaId) {
            const preset = state.userPersonaPresets.find(p => p.id === editingUserPersonaId);
            if (preset) {
                preset.name = name;
                preset.description = description;
                await kokoMemory.put('userPersonaPresets', preset);
            }
        } else {
            const newPreset = {
                id: 'user_persona_' + Date.now(),
                name,
                description
            };
            state.userPersonaPresets.push(newPreset);
            await kokoMemory.put('userPersonaPresets', newPreset);
        }
        await renderUserPersonaPresets();
        document.getElementById('user-persona-preset-modal').style.display = 'none';
    });
    document.getElementById('add-thought-preset-btn').addEventListener('click', () => {
        editingThoughtPresetId = null;
        document.getElementById('thought-preset-modal-title').textContent = '添加思维预设';
        document.getElementById('thought-preset-name-input').value = '';
        document.getElementById('thought-preset-prompt-input').value = '';
        document.getElementById('thought-preset-modal').style.display = 'flex';
    });
    document.getElementById('close-thought-preset-modal').addEventListener('click', () => {
        document.getElementById('thought-preset-modal').style.display = 'none';
    });
    document.getElementById('save-thought-preset-btn').addEventListener('click', async () => {
        const name = document.getElementById('thought-preset-name-input').value.trim();
        const prompt = document.getElementById('thought-preset-prompt-input').value.trim();
        if (!name || !prompt) return alert('请填写预设名称和指令！');
        if (editingThoughtPresetId) {
            const preset = state.thoughtPresets.find(p => p.id === editingThoughtPresetId);
            if (preset) {
                preset.name = name;
                preset.prompt = prompt;
                await kokoMemory.put('thoughtPresets', preset);
            }
        } else {
            const newPreset = {
                id: `tp_${Date.now()}`,
                name,
                prompt
            };
            state.thoughtPresets.push(newPreset);
            await kokoMemory.put('thoughtPresets', newPreset);
        }
        await renderThoughtPresets();
        document.getElementById('thought-preset-modal').style.display = 'none';
    });
    document.getElementById('add-emoticon-btn').addEventListener('click', () => {
        const modal = document.getElementById('add-emoticon-modal');
        const modalBody = modal.querySelector('.modal-body');
        modal.querySelector('#close-emoticon-modal').addEventListener('click', () => modal.style.display = 'none');
        modal.querySelector('.modal-title').textContent = '批量添加表情包';
        modalBody.innerHTML = `<div class="form-group"><label class="form-label">表情包列表 (每行一个)</label><textarea class="form-textarea" id="emoticon-batch-input" placeholder="支持格式:\n1. URL\n2. 名字 URL\n3. URL 名字" style="height: 180px;"></textarea></div><button class="form-button" id="save-emoticon-batch-btn">导入表情</button>`;
        modal.style.display = 'flex';
        const saveBtn = document.getElementById('save-emoticon-batch-btn');
        const newSaveBtn = saveBtn.cloneNode(true);
        saveBtn.parentNode.replaceChild(newSaveBtn, saveBtn);
        newSaveBtn.addEventListener('click', async () => {
            const text = document.getElementById('emoticon-batch-input').value.trim();
            if (!text) return;
            const lines = text.split('\n');
            const newEmoticons = [];
            let importedCount = 0;
            lines.forEach((line, index) => {
                line = line.trim();
                if (!line) return;
                const parts = line.split(/\s+/);
                let url = '',
                    name = '';
                const urlIndex = parts.findIndex(p => p.startsWith('http'));
                if (urlIndex !== -1) {
                    url = parts[urlIndex];
                    parts.splice(urlIndex, 1);
                    name = parts.join(' ').trim();
                } else {
                    return;
                }
                if (!name) {
                    name = `表情${state.emoticons.length + newEmoticons.length + 1}`;
                }
                newEmoticons.push({
                    id: `emo_${Date.now()}_${index}`,
                    name,
                    url
                });
                importedCount++;
            });
            if (newEmoticons.length > 0) {
                state.emoticons = [...state.emoticons, ...newEmoticons];
                await kokoMemory.bulkPut('emoticons', newEmoticons);
                await renderEmoticonLibrary();
            }
            modal.style.display = 'none';
            alert(`成功导入 ${importedCount} 个表情包！`);
        });
    });
    // ▼▼▼ 这是全新的“添加/编辑歌曲”逻辑 (修正版) ▼▼▼
            document.getElementById('add-music-btn').addEventListener('click', () => {
                const modal = document.getElementById('add-music-modal');
                // 重置表单
                document.getElementById('add-music-modal-title').textContent = '添加歌曲';
                document.getElementById('add-music-title-input').value = '';
                document.getElementById('add-music-artist-input').value = '';
                document.getElementById('add-music-url-input').value = '';
                document.getElementById('add-music-lrc-input').value = '';
                modal.style.display = 'flex';

                // 移除旧的事件监听器，防止重复绑定
                const oldSaveBtn = document.getElementById('save-music-btn');
                const newSaveBtn = oldSaveBtn.cloneNode(true); // <-- 已修正
                oldSaveBtn.parentNode.replaceChild(newSaveBtn, oldSaveBtn); // <-- 已修正

                // 为新的保存按钮添加事件
            newSaveBtn.addEventListener('click', async () => {
                const title = document.getElementById('add-music-title-input').value.trim();
                const artist = document.getElementById('add-music-artist-input').value.trim();
                const url = document.getElementById('add-music-url-input').value.trim();
                let lrcInput = document.getElementById('add-music-lrc-input').value.trim();
                
                let finalLrc = lrcInput;
                // 智能解析逻辑
                if (lrcInput.startsWith('{') && lrcInput.endsWith('}')) {
                    try {
                        const parsedData = JSON.parse(lrcInput);
                        if (parsedData && parsedData.lrc && parsedData.lrc.lyric) {
                            finalLrc = parsedData.lrc.lyric;
                            console.log("成功从JSON中提取LRC歌词！");
                        }
                    } catch (e) {
                        console.log("尝试解析歌词JSON失败，将按原文处理。");
                    }
                }

                // ▼▼▼ 在这里添加关键的修复代码 ▼▼▼
                // 将文本 "\\n" 替换为真正的换行符 "\n"
                finalLrc = finalLrc.replace(/\\n/g, '\n');
                // ▲▲▲ 修复代码结束 ▲▲▲

                if (!title || !artist || !url) {
                    alert('歌曲名、歌手和URL是必填项！');
                    return;
                }

                const newSong = {
                    id: `music_${Date.now()}`,
                    title,
                    artist,
                    url,
                    lrc: finalLrc // 使用处理后的歌词
                };

                state.musicLibrary.push(newSong);
                await kokoMemory.put('musicLibrary', newSong);
                await renderMusicLibrary();
                
                modal.style.display = 'none';
                alert(`歌曲“${title}”已成功添加到音乐库！`);
            });
            });

            document.getElementById('close-add-music-modal').addEventListener('click', () => {
                document.getElementById('add-music-modal').style.display = 'none';
            });
    document.getElementById('emoji-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        const emoticonPicker = document.getElementById('emoticon-picker');
        document.getElementById('attachment-menu').classList.remove('active');
        emoticonPicker.classList.toggle('active');
        if (emoticonPicker.classList.contains('active')) {
            renderEmoticonPicker();
        }
    });
// 在 attachEventListeners 函数中...

// 新的、智能的附件按钮逻辑
document.getElementById('attachment-btn').addEventListener('click', (e) => {
    e.stopPropagation();
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return; // 安全检查

    const menu = document.getElementById('attachment-menu');

    // 基础项目：这些是所有聊天都具备的功能
    let menuHTML = `
        <div class="attachment-menu-item" data-action="send-picture">
            <div class="icon-wrapper"><i class="fas fa-image"></i></div>
            <div class="label">图片</div>
        </div>
        <div class="attachment-menu-item" data-action="upload-image">
            <div class="icon-wrapper"><i class="fas fa-upload"></i></div>
            <div class="label">上传图片</div>
        </div>
        <div class="attachment-menu-item" data-action="send-voice">
            <div class="icon-wrapper"><i class="fas fa-microphone"></i></div>
            <div class="label">语音</div>
        </div>
        <div class="attachment-menu-item" data-action="send-red-packet">
            <div class="icon-wrapper"><i class="fas fa-wallet"></i></div>
            <div class="label">红包</div>
        </div>
    `;

    // 核心判断：如果当前不是群聊（即私聊），才添加那些特殊的一对一功能
    if (!contact.isGroup) {
        menuHTML += `
            <div class="attachment-menu-item" data-action="send-transfer">
                <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
                <div class="label">转账</div>
            </div>
            <div class="attachment-menu-item" data-action="share-music">
                <div class="icon-wrapper"><i class="fas fa-music"></i></div>
                <div class="label">音乐</div>
            </div>
            <div class="attachment-menu-item" data-action="game-wheel"> <div class="icon-wrapper"><i class="fas fa-bullseye"></i></div> <div class="label">转盘游戏</div>
            </div>
            <div class="attachment-menu-item" data-action="start-video-call">
                <div class="icon-wrapper"><i class="fas fa-video"></i></div>
                <div class="label">视频通话</div>
            </div>
            <div class="attachment-menu-item" data-action="send-location"> <div class="icon-wrapper"><i class="fas fa-map-marker-alt"></i></div> <div class="label">位置</div> </div>
        `;
    } else {
        // 如果是群聊，单独添加群聊转账功能
        menuHTML += `
            <div class="attachment-menu-item" data-action="send-group-transfer">
                <div class="icon-wrapper"><i class="fas fa-exchange-alt"></i></div>
                <div class="label">转账</div>
            </div>
        `;
    }


    menu.innerHTML = menuHTML; // 将构建好的HTML设置到菜单中

    document.getElementById('emoticon-picker').classList.remove('active');
    menu.classList.toggle('active');
});
    document.getElementById('attachment-menu').addEventListener('click', (e) => {
        const menuItem = e.target.closest('.attachment-menu-item');
        if (menuItem) {
            const action = menuItem.dataset.action;
            if (action) {
                handleAttachmentAction(action);
            }
        }
    });
    document.body.addEventListener('click', () => {
        document.getElementById('emoticon-picker').classList.remove('active');
        document.getElementById('attachment-menu').classList.remove('active');
    });
    document.getElementById('chat-screen').addEventListener('click', (e) => {
        if (!e.target.closest('#emoji-btn') && !e.target.closest('#emoticon-picker')) {
            document.getElementById('emoticon-picker').classList.remove('active');
        }
        if (!e.target.closest('#attachment-btn') && !e.target.closest('#attachment-menu')) {
            document.getElementById('attachment-menu').classList.remove('active');
        }
    });

    // --- 核心修改：聊天消息区的总事件代理 ---
    // --- 请将下面这个【完整代码块】粘贴到 attachEventListeners 函数中 ---

// 在 attachEventListeners 函数中...

// ▼▼▼ 用下面这个【最终完整无省略版】的代码块，替换掉您现有的 'chat-messages' 事件监听器 ▼▼▼
// ▼▼▼ 使用这个【最终完整版】，替换掉你现有的 'chat-messages' 事件监听器 ▼▼▼
document.getElementById('chat-messages').addEventListener('click', async (e) => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    // 逻辑1：处理回复按钮和引用跳转 (保持不变)
    const replyBtn = e.target.closest('.reply-btn');
    const quoteBox = e.target.closest('.message-quote');
    const clickedWrapper = e.target.closest('.message-wrapper');

    if (replyBtn) {
        e.stopPropagation();
        const msgId = replyBtn.closest('.message-wrapper').dataset.messageId;
        const msgToReply = contact.history.find(m => m.id === msgId);
        if (msgToReply) {
            let contentToQuote = msgToReply.content;
            if (msgToReply.type === 'voice') contentToQuote = '[语音] ' + msgToReply.content.text;
            else if (msgToReply.type === 'picture_description') contentToQuote = '[图片]';
            else if (msgToReply.type === 'red_packet') contentToQuote = '[红包] ' + msgToReply.content.blessing;
            else if (msgToReply.type !== 'text') contentToQuote = `[${msgToReply.type}]`;
            activeReplyTarget = { ...msgToReply, content: contentToQuote.substring(0, 100) };
            showReplyPreview(activeReplyTarget);
            document.getElementById('message-input').focus();
        }
        return;
    }

    if (quoteBox) {
        e.stopPropagation();
        const quotedId = quoteBox.dataset.quotedId;
        const targetMessage = document.querySelector(`.message-wrapper[data-message-id="${quotedId}"]`);
        if (targetMessage) {
            targetMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetMessage.classList.add('highlighted');
            setTimeout(() => targetMessage.classList.remove('highlighted'), 1500);
        } else {
            alert('原始消息已不在当前加载的聊天记录中。');
        }
        return;
    }

    // 逻辑2：处理消息气泡本身的点击，以显示/隐藏回复按钮 (保持不变)
    if (clickedWrapper) {
        document.querySelectorAll('.message-wrapper.show-reply-btn').forEach(wrapper => {
            if (wrapper !== clickedWrapper) {
                wrapper.classList.remove('show-reply-btn');
            }
        });
        clickedWrapper.classList.toggle('show-reply-btn');
    }

    // 如果是编辑模式，则不执行后续的点击交互
    if (editModeState.active) return;

    // 逻辑3：处理其他交互（帖子分享、转盘、红包、音乐等，保持不变）
    const postShareCard = e.target.closest('.post-share-card');
    if (postShareCard) {
        const postId = postShareCard.dataset.postId;
        showPostDetailScreen(postId);
        return;
    }

    const wrapper = e.target.closest('.message-wrapper');
    if (!wrapper) return;
    const msgId = wrapper.dataset.messageId;
    const msg = contact.history.find(m => m.id === msgId);
    if (!msg) return;

    const spinButton = e.target.closest('.spin-btn');
    if (spinButton) {
        e.stopPropagation();
        if (msg && msg.type === 'game_wheel') {
            const player = spinButton.dataset.player;
            if (player === 'user' && !msg.content.results.user) {
                const wheel = msg.content;
                const weightedOptions = wheel.options.flatMap(opt => Array(opt.weight).fill(opt.text));
                const result = weightedOptions[Math.floor(Math.random() * weightedOptions.length)];
                msg.content.results.user = result;
                await kokoMemory.put('contacts', contact);
                await openChat(contact.id);
                const systemInstruction = `[SYSTEM: 在“${wheel.name}”游戏中，我转出的结果是“${result}”。现在轮到你了，请使用 [spin_wheel:1] 指令来转动你的转盘。]`;
                await createAndAddMessage({ type: 'text', content: systemInstruction }, 'system_instruction');
            }
        }
        return;
    }

    if (msg.type === 'music_share') {
        const card = wrapper.querySelector('.music-share-card');
        if (!card) return;
        state.musicSessionContactId = state.activeChatId;
        if (e.target.closest('.music-card-play-btn')) {
            e.stopPropagation();
            if (currentlyPlayingMsgId !== msg.id || globalAudioPlayer.paused) {
                if (currentlyPlayingMsgId !== msg.id) {
                    globalAudioPlayer.src = msg.content.url;
                    currentlyPlayingMsgId = msg.id;
                    const songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === msg.content.url && t.title === msg.content.title);
                    if (songIndex !== -1) {
                       contact.sharedPlaylist.currentIndex = songIndex;
                       switchSong(songIndex, false);
                    }
                }
                globalAudioPlayer.play().catch(err => {
                    console.error("音频播放失败:", err);
                    alert("无法播放此音频链接。");
                });
            } else {
                globalAudioPlayer.pause();
            }
        } else {
            openMusicPlayer();
            const songIndex = contact.sharedPlaylist.tracks.findIndex(t => t.url === msg.content.url && t.title === msg.content.title);
            if (songIndex !== -1) {
                switchSong(songIndex);
            } else {
                contact.sharedPlaylist.tracks.unshift(msg.content);
                kokoMemory.put('contacts', contact);
                switchSong(0);
            }
        }
        return;
    }

    const locationCard = e.target.closest('.location-share-card');
    if (locationCard) {
        const wrapper = locationCard.closest('.message-wrapper');
        const msgId = wrapper.dataset.messageId;
        const msg = contact.history.find(m => m.id === msgId);
    
        if (msg && msg.type === 'location_share') {
            const loc = msg.content;
            openMapScreen(loc.mapId);
            alert(`正在跳转到地图“${loc.mapId}”上的“${loc.name}”`);
        }
        return;
    }

    if (msg.type === 'red_packet') {
        let senderProfile;
        if (msg.sender === 'user') {
            senderProfile = state.myProfile;
        } else {
            senderProfile = state.contacts.find(c => c.id === msg.sender);
        }
        if (!senderProfile) senderProfile = { name: '未知用户', avatar: '' };
        showRedPacketModal(msg, senderProfile);
        return; // 处理完红包后结束
    }
    
    if (msg.type === 'transfer') {
        let senderProfile;
        if (msg.sender === 'user') {
            senderProfile = state.myProfile;
        } else {
            senderProfile = state.contacts.find(c => c.id === msg.sender);
        }
        if (!senderProfile) senderProfile = { name: '未知用户', avatar: '' };
        showTransferModal(msg, senderProfile);
        return; // 处理完转账后结束
    }

// ▼▼▼ 核心修改部分：统一处理语音和图片描述的点击 (已修正) ▼▼▼
   if (msg.type === 'voice' || msg.type === 'picture_description') {
        const transcribedTextEl = wrapper.querySelector('.transcribed-text');
        const isCurrentlyVisible = transcribedTextEl.classList.contains('visible');

        // --- 1. 声音播放逻辑 (已修正) ---
        if (msg.type === 'voice' && !isCurrentlyVisible) {
            const senderProfile = state.contacts.find(c => c.id === msg.sender);
            
            // 核心修正：直接传入 senderProfile 对象，而不是它的 voiceId
            if (senderProfile) {
                playVoiceMessage(msg.content.text, senderProfile).catch(err => {
                    console.error("点击播放语音失败:", err.message);
                });
            }
        }
        // ... 后续代码保持不变 ...

        // --- 2. 文字显示/隐藏逻辑 (永远有效) ---
        // a. 先关闭所有其他已打开的文字气泡。
        document.querySelectorAll('.transcribed-text.visible').forEach(el => {
            if (el !== transcribedTextEl) {
                el.classList.remove('visible');
                el.textContent = '';
            }
        });

        // b. 切换当前点击的气泡的文字显示状态。
        if (isCurrentlyVisible) {
            // 如果当前是可见的，就隐藏它。
            transcribedTextEl.classList.remove('visible');
            transcribedTextEl.textContent = '';
        } else {
            // 如果当前是隐藏的，就用正确的文字内容显示它。
            const textToShow = (msg.type === 'voice') ? msg.content.text : msg.content.description;
            transcribedTextEl.textContent = textToShow;
            transcribedTextEl.classList.add('visible');
        }
    }
    // ▲▲▲ 核心修改结束 ▲▲▲
});

// ▲▲▲ 替换到这里结束 ▲▲▲

    // 新增：点击聊天屏幕的其他地方，隐藏所有回复按钮
    document.getElementById('chat-screen').addEventListener('click', (e) => {
        if (!e.target.closest('.message-wrapper')) {
            document.querySelectorAll('.message-wrapper.show-reply-btn').forEach(wrapper => {
                wrapper.classList.remove('show-reply-btn');
            });
        }
    });

    // --- V9.0 新增: 播放器内部按钮事件 ---
    document.getElementById('player-play-btn').addEventListener('click', () => {
        if (globalAudioPlayer.paused) globalAudioPlayer.play();
        else globalAudioPlayer.pause();
    });
    document.getElementById('player-collapse-btn').addEventListener('click', () => {
        card.classList.toggle('collapsed');
        document.getElementById('player-collapse-btn').classList.toggle('fa-chevron-down');
        document.getElementById('player-collapse-btn').classList.toggle('fa-chevron-up');
    });
    // ▼▼▼ 在这里添加新的事件监听 ▼▼▼
    document.getElementById('player-close-btn').addEventListener('click', closeMusicPlayer);
    document.getElementById('player-playlist-btn').addEventListener('click', () => {
        document.getElementById('player-playlist-view').classList.toggle('active');
    });
    document.getElementById('player-mode-btn').addEventListener('click', () => {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        const modes = ['repeat-all', 'repeat-one', 'off'];
        const icons = ['fa-repeat', 'fa-1', 'fa-power-off'];
        const titles = ['列表循环', '单曲循环', '播放完暂停'];
        let currentIndex = modes.indexOf(contact.sharedPlaylist.playbackMode || 'repeat-all');
        currentIndex = (currentIndex + 1) % modes.length;
        contact.sharedPlaylist.playbackMode = modes[currentIndex];
        const modeBtn = document.getElementById('player-mode-btn');
        modeBtn.className = `fas ${icons[currentIndex]} player-control-btn`;
        modeBtn.title = titles[currentIndex];
        kokoMemory.put('contacts', contact);
    });
    document.getElementById('player-next-btn').addEventListener('click', () => switchSong(currentSongIndex + 1, true, true));
document.getElementById('player-prev-btn').addEventListener('click', () => switchSong(currentSongIndex - 1, true, true));
    document.getElementById('player-progress-bar').addEventListener('click', function(e) {
        if (globalAudioPlayer.duration) {
            const rect = this.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            globalAudioPlayer.currentTime = (clickX / rect.width) * globalAudioPlayer.duration;
        }
    });

    document.getElementById('close-send-picture-modal').addEventListener('click', () => {
        document.getElementById('send-picture-modal').style.display = 'none';
    });
    document.getElementById('close-send-voice-modal').addEventListener('click', () => {
        document.getElementById('send-voice-modal').style.display = 'none';
    });
    document.getElementById('close-send-red-packet-modal').addEventListener('click', () => {
        document.getElementById('send-red-packet-modal').style.display = 'none';
    });
    document.getElementById('close-send-transfer-modal').addEventListener('click', () => {
        document.getElementById('send-transfer-modal').style.display = 'none';
    });
    document.getElementById('close-send-music-modal').addEventListener('click', () => {
        document.getElementById('send-music-modal').style.display = 'none';
    });

   // --- 新增：为红包详情弹窗的关闭按钮绑定事件 --- 
   document.getElementById('close-red-packet-details-modal').addEventListener('click', () => { document.getElementById('red-packet-details-modal').style.display = 'none'; });
    
      // --- 原有功能：论坛事件 ---
    document.getElementById('feed-tabs-container').addEventListener('click', (e) => {
        if (e.target.classList.contains('feed-tab-btn')) {
            state.activeFeedTab = e.target.dataset.tab;
            renderFeed();
        }
    });
    document.getElementById('feed-sub-tabs-container').addEventListener('click', (e) => {
        if (e.target.classList.contains('feed-sub-tab-btn')) {
            state.activeFeedSubTab = e.target.dataset.subtab;
            renderFeed();
        }
    });
    document.getElementById('moments-content').addEventListener('click', async (e) => {
        const repostBtn = e.target.closest('.repost-btn');
        if (repostBtn) {
            e.stopPropagation();
            openRepostModal(repostBtn.dataset.postId);
            return;
        }
        const redPacketCard = e.target.closest('.forum-red-packet-card');
        if (redPacketCard) {
            e.stopPropagation();
            openForumRedPacketModal(redPacketCard.dataset.postId);
            return;
        }
        const postItem = e.target.closest('.post-item');
        const trendingItem = e.target.closest('.trending-item');
        const deleteBtn = e.target.closest('.post-delete-btn');
        if (deleteBtn) {
            e.stopPropagation();
            const confirmed = await showCustomConfirm('删除帖子', '确定要删除这条帖子吗？', true);
            if (confirmed) {
                const postId = deleteBtn.dataset.postId;
                state.posts = state.posts.filter(p => p.id !== postId);
                await kokoMemory.delete('posts', postId);
                await renderFeed();
            }
            return;
        }
        if (postItem) {
            showPostDetailScreen(postItem.dataset.postId);
        } else if (trendingItem) {
    const title = trendingItem.dataset.topicTitle;
    const description = trendingItem.dataset.description;

    // 直接调用新函数，并把标题和描述都传进去
    showTrendingTopicScreen(title, description); 
}
    });
    document.getElementById('trending-topic-screen').addEventListener('click', (e) => {
        const postItem = e.target.closest('.post-item');
        if (postItem) {
            showPostDetailScreen(postItem.dataset.postId);
        }
    });
    document.getElementById('refresh-feed-btn').addEventListener('click', async () => {
        const apiConfig = getApiFor('square');
        if (!apiConfig.apiKey || !apiConfig.endpoint) {
            alert('请先在“发现 -> 论坛API设置”中配置API。');
            return;
        }
        try {
            if (state.activeFeedTab === 'trending') {
                showFeedStatus('正在刷新热搜榜...');
                await generateRandomTrendingTopicsAI();
            } else if (state.activeFeedTab === 'recommended') {
                showFeedStatus('正在刷新推荐内容...');
                await generatePostsForRecommendedTab(5);
            } else {
                showFeedStatus('正在刷新关注内容...');
                await generatePostsForRecommendedTab(2);
            }
            await renderFeed();
        } catch (e) {
            console.error("刷新失败:", e);
            alert("刷新失败: " + e.message);
        } finally {
            hideFeedStatus();
        }
    });
    const commentInput = document.getElementById('comment-input');
    commentInput.addEventListener('blur', () => {
        if (commentInput.value.trim() === '' && activeReplyTarget) {
            activeReplyTarget = null;
            commentInput.placeholder = '留下你的精彩评论吧...';
        }
    });
    document.getElementById('submit-comment-btn').addEventListener('click', async () => {
        const input = document.getElementById('comment-input');
        const content = input.value.trim();
        if (!content) return;
        const post = state.posts.find(p => p.id === state.activePostId);
        if (post) {
            const newComment = {
                id: `comment_${Date.now()}`,
                author: {
                    id: 'myProfile',
                    name: state.myProfile.name,
                    avatar: state.myProfile.avatar
                },
                content,
                timestamp: Date.now(),
                replyTo: activeReplyTarget ? activeReplyTarget.name : null
            };
            post.comments.push(newComment);
            input.value = '';
            activeReplyTarget = null;
            input.placeholder = '留下你的精彩评论吧...';
            await kokoMemory.put('posts', post);
            await renderPostDetail();
            await triggerAiCommentDiscussion(post, newComment);
        }
    });
    document.getElementById('comments-list').addEventListener('click', async (e) => {
        const commentItem = e.target.closest('.post-comment-item');
        if (!commentItem) return;
        const deleteBtn = e.target.closest('.comment-delete-btn');
        if (deleteBtn) {
            e.stopPropagation();
            const commentId = deleteBtn.dataset.commentId;
            const confirmed = await showCustomConfirm('删除评论', '确定要删除这条评论吗？', true);
            if (confirmed) {
                const post = state.posts.find(p => p.id === state.activePostId);
                if (post) {
                    post.comments = post.comments.filter(c => c.id !== commentId);
                    await kokoMemory.put('posts', post);
                    await renderPostDetail();
                }
            }
            return;
        }
        if (!e.target.closest('a, .mention, .comment-delete-btn')) {
            const authorName = commentItem.dataset.authorName;
            const authorId = commentItem.dataset.authorId;
            if (authorId === 'myProfile') return;
            activeReplyTarget = {
                name: authorName,
                id: authorId
            };
            const commentInput = document.getElementById('comment-input');
            commentInput.placeholder = `回复 @${authorName}`;
            commentInput.focus();
        }
    });
    document.getElementById('post-moment-btn').addEventListener('click', () => {
        pendingForumRedPacket = null;
        const modal = document.getElementById('post-moment-modal');
        modal.style.display = 'flex';
        document.getElementById('moment-content-input').value = '';
        const redPacketBtn = document.getElementById('add-post-red-packet-btn');
        redPacketBtn.classList.remove('active');
        const newRedPacketBtn = redPacketBtn.cloneNode(true);
        redPacketBtn.parentNode.replaceChild(newRedPacketBtn, redPacketBtn);
        newRedPacketBtn.addEventListener('click', () => {
            const rpModal = document.getElementById('create-forum-red-packet-modal');
            rpModal.style.display = 'flex';
            document.getElementById('close-forum-red-packet-modal').onclick = () => rpModal.style.display = 'none';
            const confirmRpBtn = document.getElementById('confirm-forum-red-packet-btn');
            const newConfirmRpBtn = confirmRpBtn.cloneNode(true);
            confirmRpBtn.parentNode.replaceChild(newConfirmRpBtn, confirmRpBtn);
            newConfirmRpBtn.addEventListener('click', () => {
                const amount = parseFloat(document.getElementById('forum-red-packet-amount-input').value);
                const count = parseInt(document.getElementById('forum-red-packet-count-input').value, 10);
                if (isNaN(amount) || amount <= 0 || isNaN(count) || count <= 0) {
                    return alert('请输入有效的金额和个数');
                }
                if (amount > state.myProfile.balance) {
                    return alert('钱包余额不足！');
                }
                pendingForumRedPacket = {
                    amount,
                    count,
                    blessing: document.getElementById('forum-red-packet-blessing-input').value.trim() || '恭喜发财，大吉大利！',
                };
                newRedPacketBtn.classList.add('active');
                rpModal.style.display = 'none';
            });
        });
    });
    document.getElementById('close-post-moment-modal').addEventListener('click', () => {
        document.getElementById('post-moment-modal').style.display = 'none';
    });
    document.getElementById('publish-moment-btn').addEventListener('click', async () => {
        const content = document.getElementById('moment-content-input').value.trim();
        if (!content && !pendingForumRedPacket) return alert('请输入帖子内容或添加红包！');
        const category = document.getElementById('post-category-select').value;
        const newPost = {
            id: 'post_' + Date.now(),
            author: {
                id: 'myProfile',
                name: state.myProfile.name,
                avatar: state.myProfile.avatar,
                signature: state.myProfile.signature
            },
            content: content || (pendingForumRedPacket ? pendingForumRedPacket.blessing : ''),
            timestamp: Date.now(),
            likes: [],
            comments: [],
            reposts: 0,
            category: category,
            archiveId: state.activeForumArchiveId
        };
        if (pendingForumRedPacket) {
            newPost.redPacket = { ...pendingForumRedPacket,
                claimers: []
            };
            state.myProfile.balance -= pendingForumRedPacket.amount;
            await addTransaction('expense', pendingForumRedPacket.amount, `在论坛中发红包`, null);
            await kokoMemory.put('myProfile', state.myProfile);
            await renderMyProfile();
        }
        state.posts.unshift(newPost);
        await kokoMemory.put('posts', newPost);
        state.activeFeedTab = 'recommended';
        state.activeFeedSubTab = category;
        await showFeedScreen();
        document.getElementById('post-moment-modal').style.display = 'none';
    });
    document.getElementById('screen').addEventListener('click', e => {
        const mentionSpan = e.target.closest('.mention');
        if (mentionSpan) {
            e.stopPropagation();
            const userName = mentionSpan.textContent.substring(1);
            alert(`Tapped on user: @${userName}`);
        }
    });
    document.getElementById('my-wallet-btn').addEventListener('click', () => {
        hideAllScreens();
        document.getElementById('wallet-screen').style.display = 'flex';
        renderWalletScreen();
    });
    document.getElementById('back-from-wallet').addEventListener('click', showProfileScreen);

    // --- ↓↓↓ 用这个新的代码块，替换掉你原来的所有 globalAudioPlayer.addEventListener(...) 代码 ↓↓↓ ---
globalAudioPlayer.addEventListener('play', () => {
    startListenTimeTracker();
    updateUI(); 
    document.getElementById('player-avatar-stack').classList.add('is-playing');

    document.querySelectorAll('.music-share-card').forEach(card => {
        const msgId = card.closest('.message-wrapper').dataset.messageId;
        if (msgId === currentlyPlayingMsgId) {
            card.querySelector('.music-card-cover').classList.add('playing');
            card.querySelector('.music-card-play-btn i').className = 'fas fa-pause';
        } else {
            card.querySelector('.music-card-cover').classList.remove('playing');
            card.querySelector('.music-card-play-btn i').className = 'fas fa-play';
        }
    });
});

globalAudioPlayer.addEventListener('pause', () => {
    stopListenTimeTracker();
    updateUI(); 
    document.getElementById('player-avatar-stack').classList.remove('is-playing');

    document.querySelectorAll('.music-share-card').forEach(card => {
        card.querySelector('.music-card-cover').classList.remove('playing');
        card.querySelector('.music-card-play-btn i').className = 'fas fa-play';
    });
});

globalAudioPlayer.addEventListener('timeupdate', () => {
    updateUI(); 
    if (currentlyPlayingMsgId) {
        const cardWrapper = document.querySelector(`.message-wrapper[data-message-id='${currentlyPlayingMsgId}']`);
        if (cardWrapper) {
            const card = cardWrapper.querySelector('.music-share-card');
            if (card && globalAudioPlayer.duration) {
                const progress = (globalAudioPlayer.currentTime / globalAudioPlayer.duration) * 100;
                card.querySelector('.music-card-progress').style.width = `${progress}%`;
                const formatTime = (s) => new Date(s * 1000).toISOString().substr(14, 5);
                card.querySelector('.music-card-time').textContent = formatTime(globalAudioPlayer.currentTime);
            }
        }
    }
});

globalAudioPlayer.addEventListener('loadedmetadata', updateUI);

globalAudioPlayer.addEventListener('ended', async () => {
    document.getElementById('player-avatar-stack').classList.remove('is-playing');
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const playlist = contact.sharedPlaylist;
    const mode = playlist.playbackMode || 'repeat-all';
    switch (mode) {
        case 'repeat-one':
            globalAudioPlayer.currentTime = 0;
            globalAudioPlayer.play();
            break;
        case 'repeat-all':
            switchSong(currentSongIndex + 1, true, true);
            break;
        case 'off':
            break;
    }
    await kokoMemory.put('contacts', contact);
});

// --- 新增：聊天消息长按编辑逻辑（允许编辑双方） ---
    let longPressTimer = null;
    const LONG_PRESS_DURATION = 700; // 700毫秒算作长按
    const chatMessagesContainer = document.getElementById('chat-messages');

    const startLongPress = (e) => {
        // 如果正在进行多选编辑，则禁用长按编辑
        if (editModeState.active) return;

        const wrapper = e.target.closest('.message-wrapper');
        if (!wrapper) return;

        const msgId = wrapper.dataset.messageId;
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact) return;
        // ▼▼▼ 把这行新代码粘贴到这里 ▼▼▼
        // 新增：如果当前聊天处于叙事模式，则禁止触发长按编辑
        if (contact.isNarrativeMode) return;
        // ▲▲▲ 新增代码结束 ▲▲▲
        
        const msg = contact.history.find(m => m.id === msgId);
        
// 关键判断：现在允许编辑 文本、HTML 和 语音 类型的消息
    if (!msg || (msg.type !== 'text' && msg.type !== 'html' && msg.type !== 'voice')) {
        return;
    }

        // 启动计时器，时间到了就执行编辑函数
        longPressTimer = setTimeout(() => {
            handleEditMessage(msgId);
        }, LONG_PRESS_DURATION);
    };

    const cancelLongPress = () => {
        // 如果在计时器触发前松开手指，则取消计时
        clearTimeout(longPressTimer);
    };

    // 为各种鼠标和触摸事件绑定监听器
    chatMessagesContainer.addEventListener('mousedown', startLongPress);
    chatMessagesContainer.addEventListener('mouseup', cancelLongPress);
    chatMessagesContainer.addEventListener('mouseleave', cancelLongPress);
    chatMessagesContainer.addEventListener('touchstart', startLongPress);
    chatMessagesContainer.addEventListener('touchend', cancelLongPress);
    chatMessagesContainer.addEventListener('touchcancel', cancelLongPress);

// ↓↓↓ 把这段新代码粘贴到 attachEventListeners 函数的末尾 ↓↓↓

// --- 游戏转盘弹窗逻辑 ---
document.getElementById('close-create-wheel-modal').addEventListener('click', () => {
    document.getElementById('create-wheel-modal').style.display = 'none';
});

document.getElementById('add-wheel-option-btn').addEventListener('click', () => addWheelOptionInput());

document.getElementById('confirm-send-wheel-btn').addEventListener('click', async () => {
    const wheelName = document.getElementById('wheel-name-input').value.trim();
    if (!wheelName) {
        return alert('请给你的转盘起个名字！');
    }

    const options = [];
    const optionElements = document.querySelectorAll('.wheel-option-item');
    for (const el of optionElements) {
        const text = el.querySelector('.wheel-option-text').value.trim();
        const weight = parseInt(el.querySelector('.wheel-option-weight').value, 10) || 1;
        if (text) {
            options.push({ text, weight });
        }
    }

    if (options.length < 2) {
        return alert('转盘至少需要2个有效的选项！');
    }

    await createAndAddMessage({
        type: 'game_wheel',
        content: {
            id: `wheel_${Date.now()}`,
            name: wheelName,
            options: options,
            results: { // 存储用户和AI的结果
                user: null, // 'user' 代表玩家自己
                contact: null // 'contact' 代表对方
            }
        }
    });

});
// ↑↑↑ 新增代码结束 ↑↑↑
// --- ▼▼▼ 把这段代码粘贴到 attachEventListeners 函数的内部 ---

    // 使用事件委托，为所有可折叠的列表添加交互功能
    document.body.addEventListener('click', function(e) {
        // 检查点击的是否是我们想要的可折叠标题
        if (e.target.matches('.collapsible-title, .collapsible-title *')) {
            const title = e.target.closest('.collapsible-title');
            if (!title) return;

            // 切换标题自身的 'collapsed' 状态，这会让CSS去旋转小箭头
            title.classList.toggle('collapsed');
            const isCollapsed = title.classList.contains('collapsed');

            // 开始遍历标题后面的所有同级元素
            let nextElement = title.nextElementSibling;
            while (nextElement) {
                // 如果遇到下一个分组标题，就停止遍历
                if (nextElement.matches('.section-title')) {
                    break;
                }
                
                // 根据折叠状态，显示或隐藏世界书条目
                nextElement.style.display = isCollapsed ? 'none' : ''; // '' 会恢复到默认的显示状态

                // 继续检查下一个元素
                nextElement = nextElement.nextElementSibling;
            }
        }
    });

// --- ▲▲▲ 粘贴到这里结束 ---
// 在 attachEventListeners 函数中找到并添加这些事件
document.getElementById('lock-screen-photos-btn').addEventListener('click', showLockScreenPhotosScreen);
document.getElementById('back-from-lock-screen-photos').addEventListener('click', showDiscoverScreen);

document.getElementById('add-lock-screen-photo-btn').addEventListener('click', () => {
    document.getElementById('lock-screen-photo-uploader').click();
});

document.getElementById('lock-screen-photo-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        const base64String = await handleImageUpload(file); // 复用我们已有的图片压缩函数
        const newPhoto = {
            id: 'ls_photo_' + Date.now(),
            base64: base64String
        };
        await kokoMemory.put('lockScreenPhotos', newPhoto);
        await renderLockScreenPhotos(); // 上传后立刻刷新列表
    } catch (error) {
        console.error('上传锁屏照片失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        e.target.value = ''; // 清空选择，方便下次上传
    }
});

document.getElementById('lock-screen-photos-grid').addEventListener('click', async (e) => {
    if (e.target.classList.contains('emoticon-delete-btn')) {
        const photoId = e.target.dataset.photoId;
        const confirmed = await showCustomConfirm('删除照片', '确定要从锁屏相册中删除这张照片吗？', true);
        if (confirmed) {
            await kokoMemory.delete('lockScreenPhotos', photoId);
            await renderLockScreenPhotos(); // 删除后刷新
        }
    }
});
// 在 attachEventListeners 函数的末尾追加
// --- V-新功能：日程与事件的事件监听 ---

// 资料页的入口按钮
document.getElementById('view-schedule-btn').addEventListener('click', showScheduleScreen);
document.getElementById('view-events-btn').addEventListener('click', showEventsScreen);

// 各自页面的返回按钮
document.getElementById('back-from-schedule').addEventListener('click', showCharProfileScreen);
document.getElementById('back-from-events').addEventListener('click', showCharProfileScreen);

// 添加按钮 -> 打开弹窗
document.getElementById('add-schedule-item-btn').addEventListener('click', () => openScheduleModal());
document.getElementById('add-event-item-btn').addEventListener('click', () => openEventModal());

// 弹窗的关闭按钮
document.getElementById('close-schedule-modal').addEventListener('click', () => { document.getElementById('schedule-modal').style.display = 'none'; });
document.getElementById('close-event-modal').addEventListener('click', () => { document.getElementById('event-modal').style.display = 'none'; });

// 弹窗的保存按钮
document.getElementById('save-schedule-item-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const newItem = {
        id: editingScheduleId || 'sched_' + Date.now(),
        courseName: document.getElementById('schedule-name-input').value.trim(),
        dayOfWeek: document.getElementById('schedule-day-select').value,
        startTime: document.getElementById('schedule-start-input').value,
        endTime: document.getElementById('schedule-end-input').value,
        location: document.getElementById('schedule-location-input').value.trim()
    };
    if (!newItem.courseName || !newItem.startTime || !newItem.endTime) return alert('请填写完整信息');
        // --- ▼▼▼ 在这里添加修复代码 ▼▼▼ ---
    if (!contact.schedule) {
        contact.schedule = []; // 如果篮子不存在，就先创建一个
    }
    // --- ▲▲▲ 修复代码结束 ▲▲▲
    
    if (editingScheduleId) {
        const index = contact.schedule.findIndex(i => i.id === editingScheduleId);
        contact.schedule[index] = newItem;
    } else {
        contact.schedule.push(newItem);
    }
    await kokoMemory.put('contacts', contact);
    renderSchedule();
    document.getElementById('schedule-modal').style.display = 'none';
});

document.getElementById('save-event-item-btn').addEventListener('click', async () => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;
    const newItem = {
        id: editingEventId || 'event_' + Date.now(),
        eventName: document.getElementById('event-name-input').value.trim(),
        date: document.getElementById('event-date-input').value,
        type: document.getElementById('event-type-select').value,
        notes: document.getElementById('event-notes-input').value.trim()
    };
    if (!newItem.eventName || !newItem.date) return alert('请填写事件名称和日期');
       // --- ▼▼▼ 在这里添加修复代码 ▼▼▼ ---
    if (!contact.events) {
        contact.events = []; // 如果篮子不存在，就先创建一个
    }
    // --- ▲▲▲ 修复代码结束 ▲▲▲

    if (editingEventId) {
        const index = contact.events.findIndex(i => i.id === editingEventId);
        contact.events[index] = newItem;
    } else {
        contact.events.push(newItem);
    }
    await kokoMemory.put('contacts', contact);
    renderEvents();
    document.getElementById('event-modal').style.display = 'none';
});

// 使用事件委托处理列表项的点击（编辑/删除）
document.getElementById('schedule-content-list').addEventListener('click', (e) => {
    const itemEl = e.target.closest('.discover-item');
    if (itemEl) {
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        const itemId = itemEl.dataset.scheduleId;
        const item = contact.schedule.find(i => i.id === itemId);
        openScheduleModal(item);
    }
});

// 使用事件委托处理列表项的点击（编辑/删除/置顶） (V2版)
document.getElementById('events-content-list').addEventListener('click', async (e) => {
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact) return;

    const itemEl = e.target.closest('.discover-item');
    if (!itemEl) return;

    const eventId = itemEl.dataset.eventId;

    // ▼▼▼ 新增的置顶按钮逻辑 ▼▼▼
    const pinBtn = e.target.closest('.pin-event-btn');
    if (pinBtn) {
        e.stopPropagation();
        
        const targetEvent = contact.events.find(i => i.id === eventId);
        if (!targetEvent) return;

        const isCurrentlyPinned = targetEvent.isPinned;

        // 核心逻辑：先取消所有事件的置顶
        contact.events.forEach(event => event.isPinned = false);

        // 如果刚才点击的不是一个已置顶的事件，那么就把它设为新的置顶
        if (!isCurrentlyPinned) {
            targetEvent.isPinned = true;
        }
        
        await kokoMemory.put('contacts', contact);
        renderEvents(); // 重新渲染列表，更新图钉颜色
        return;
    }
    // ▲▲▲ 新增逻辑结束 ▲▲▲

    const deleteBtn = e.target.closest('.delete-event-btn');
    if (deleteBtn) {
        e.stopPropagation();
        const confirmed = await showCustomConfirm('删除事件', '确定要删除这个重要的日子吗？', true);
        if (confirmed) {
            contact.events = contact.events.filter(i => i.id !== eventId);
            await kokoMemory.put('contacts', contact);
            renderEvents();
        }
    } else if (e.target.closest('.discover-info')) { // 只在点击信息区时才算编辑
        const item = contact.events.find(i => i.id === eventId);
        openEventModal(item);
    }
});
// ... 在 attachEventListeners 函数的任意位置 ...

// --- 新增：处理真实图片上传的事件 ---
document.getElementById('image-upload-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    try {
        // 调用我们刚才写的处理函数
        const base64String = await handleImageUpload(file);
        
        // 用新的消息类型发送
        await createAndAddMessage({
            type: 'uploaded_image',
            content: {
                base64: base64String
            }
        });

    } catch (error) {
        console.error('图片处理失败:', error);
        alert('图片处理失败，请稍后再试。');
    } finally {
        // 清空input的值，这样用户可以连续上传同一张图片
        e.target.value = '';
    }
});
// ==========================================================
// 1. 角色资料页的入口按钮
document.getElementById('view-relationship-network-btn').addEventListener('click', () => {
    showRelationshipScreen(state.activeChatId);
});

// 2. 关系网页面的返回按钮
document.getElementById('back-from-relationship-network').addEventListener('click', showCharProfileScreen);

// 在 attachEventListeners 函数的末尾添加：

// --- 【新增】关系网 V2.0 事件绑定 ---

// 在 attachEventListeners 函数中...

// 【修改】把原来 add-character-btn 的监听，改成 add-to-roster-btn
document.getElementById('add-to-roster-btn').addEventListener('click', () => {
    openAddToRosterModal(); // 点击后打开我们的“选择”模态框
});

// 【新增】为“选择”模态框的按钮绑定事件
document.getElementById('close-add-to-roster-modal').addEventListener('click', () => {
    document.getElementById('add-to-roster-modal').style.display = 'none';
});

// “导入选中联系人”按钮的逻辑
document.getElementById('confirm-import-contact-btn').addEventListener('click', async () => {
    const contactIdToImport = document.getElementById('import-contact-select').value;
    if (!contactIdToImport) return;

    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    const contactToImport = state.contacts.find(c => c.id === contactIdToImport);

    if (contactToImport && !networkData.nodes.some(n => n.id === contactToImport.id)) {
        // 将选中的联系人添加到nodes数组中
        networkData.nodes.push({
            id: contactToImport.id,
            name: contactToImport.name,
            avatar: contactToImport.avatar,
            isContact: true // 标记为这是一个真实联系人
        });
        await kokoMemory.put('relationshipNetworks', networkData);

        // 刷新UI并关闭模态框
        await renderRelationshipNetwork(contactId);
        await renderRelationshipGraph(contactId);
        document.getElementById('add-to-roster-modal').style.display = 'none';
    }
});

// “创建一个全新的NPC”按钮的逻辑
document.getElementById('switch-to-create-npc-btn').addEventListener('click', () => {
    document.getElementById('add-to-roster-modal').style.display = 'none'; // 先关掉选择框
    openCharacterModal(); // 再打开我们之前写的NPC创建框
});

// 角色编辑/删除（事件委托）
document.getElementById('character-list').addEventListener('click', async (e) => {
    const contactId = document.getElementById('relationship-network-screen').dataset.currentContactId;
    const networkData = await kokoMemory.get('relationshipNetworks', contactId);
    
    const editBtn = e.target.closest('.edit-character-btn');
    if (editBtn) {
        const char = networkData.nodes.find(n => n.id === editBtn.dataset.charId);
        if(char) openCharacterModal(char);
    }
    const deleteBtn = e.target.closest('.delete-character-btn');
    if (deleteBtn) {
        deleteCharacter(deleteBtn.dataset.charId);
    }
});


// 角色模态框的按钮
document.getElementById('close-character-modal').addEventListener('click', () => {
    document.getElementById('character-modal').style.display = 'none';
});
document.getElementById('save-character-btn').addEventListener('click', saveCharacter);

// 删除关系按钮（事件委托，V2.0版）
document.getElementById('relationship-list').addEventListener('click', (e) => {
    const deleteBtn = e.target.closest('.delete-relationship-btn');
    if (deleteBtn) {
        deleteRelationship(deleteBtn.dataset.sourceId, deleteBtn.dataset.targetId);
    }
});
// 在 attachEventListeners 函数的任意位置添加：

// --- 【新增】NPC头像本地上传事件绑定 ---
document.getElementById('upload-character-avatar-btn').addEventListener('click', () => {
    // 点击“上传”按钮时，去触发那个看不见的 <input type="file">
    document.getElementById('character-avatar-uploader').click();
});

document.getElementById('character-avatar-uploader').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;

    try {
        // 调用我们之前就写好的、带压缩功能的图片处理函数！完美复用！
        const base64String = await handleImageUpload(file);

        // 把处理好的图片显示在预览区
        const preview = document.getElementById('character-avatar-preview');
        preview.src = base64String;
        preview.style.display = 'block';

    } catch (error) {
        console.error('NPC头像处理失败:', error);
        alert('图片处理失败，请重试。');
    } finally {
        // 清空input的值，这样用户可以连续上传同一张图片
        e.target.value = '';
    }
});
// 在 attachEventListeners 函数中...

// 【新增】自定义关系类型选择的事件监听
document.getElementById('relation-type-select').addEventListener('change', async function() {
    if (this.value === '自定义') {
        const customType = await showCustomPrompt('自定义关系类型', '请输入关系名称（如：师徒）');

        if (customType && customType.trim()) {
            const newType = customType.trim();

            // 检查这个新类型是否已经存在
            let optionExists = false;
            for (let i = 0; i < this.options.length; i++) {
                if (this.options[i].value === newType) {
                    optionExists = true;
                    this.value = newType; // 如果已存在，直接选中它
                    break;
                }
            }

            // 如果不存在，就创建一个新的选项并选中它
            if (!optionExists) {
                const newOption = new Option(newType, newType, true, true);
                // 插入到“自定义”选项的前面
                this.insertBefore(newOption, this.options[this.options.length - 1]);
            }
        } else {
            // 如果用户取消了输入，就恢复到第一个选项（“朋友”）
            this.value = this.options[0].value;
        }
    }
});
document.getElementById('save-relationship-btn').addEventListener('click', saveRelationship);
// =========== ▼▼▼ 论坛档案馆 - 最终修正版事件监听 ▼▼▼ ========
// ==========================================================

// 1. 为“发现”页面的“档案馆”入口按钮绑定事件
document.getElementById('forum-archives-btn').addEventListener('click', async (e) => {
    e.preventDefault();
    await showForumArchivesScreen(); // 点击后打开档案馆页面
});

// 2. 为档案馆页面的“返回”按钮绑定独立的事件
document.getElementById('back-from-forum-archives').addEventListener('click', async (e) => {
    e.preventDefault();
    await showDiscoverScreen(); // 点击后返回“发现”页面
});

// 3. 使用事件委托，统一处理档案馆列表内部的所有点击操作
document.getElementById('forum-archives-list').addEventListener('click', async (e) => {
    e.preventDefault(); // 阻止默认行为

    // 检查点击的是否是“切换”按钮
    const switchBtn = e.target.closest('.switch-archive-btn');
    if (switchBtn) {
        const archiveItem = switchBtn.closest('.preset-item');
        if (archiveItem) {
            const archiveId = archiveItem.dataset.archiveId;
            // 调用我们重写过的、具备“设置恢复”功能的核心函数
            await switchForumArchive(archiveId); 
        }
        return; // 处理完后结束，避免冲突
    }

    // 检查点击的是否是“删除”按钮
    const deleteBtn = e.target.closest('.delete-archive-btn');
    if (deleteBtn) {
        const archiveItem = deleteBtn.closest('.preset-item');
        if (archiveItem) {
            const archiveId = archiveItem.dataset.archiveId;
            // 调用删除函数
            await deleteForumArchive(archiveId);
        }
    }
});
// ==========================================================
// =========== ▲▲▲ 论坛档案馆 - 最终修正版事件监听 END ▲▲▲ ======
// --- 把这段新代码，粘贴到 attachEventListeners 函数里 ---

// 使用事件委托，统一处理“思维预设”列表中的所有点击
document.getElementById('thought-presets-list').addEventListener('click', (event) => {
    // 检查被点击的元素是不是“编辑按钮”
    const editButton = event.target.closest('.edit-thought-preset-btn');
    if (editButton) {
        editThoughtPreset(event);
        return; 
    }

    // 检查被点击的元素是不是“删除按钮”
    const deleteButton = event.target.closest('.delete-thought-preset-btn');
    if (deleteButton) {
        deleteThoughtPreset(event);
    }
});
// ▼▼▼ 把下面这些代码，粘贴到 attachEventListeners 函数的【内部】任何位置 ▼▼▼

    // --- 自动回复功能的事件连接 ---
    document.getElementById('automation-btn').addEventListener('click', showAutomationScreen);
    document.getElementById('back-from-automation').addEventListener('click', showDiscoverScreen);
    document.getElementById('save-automation-settings-btn').addEventListener('click', saveAutomationSettings);

    // 启动一个每秒更新一次倒计时的迷你定时器
    setInterval(updateAutomationStatusIndicator, 1000);

// ▲▲▲ 粘贴到这里结束 ▲▲▲
// ==========================================================
// ▼▼▼ 把这段新代码完整地粘贴到 attachEventListeners 函数里 ▼▼▼

// --- 使用事件委托，统一处理“用户面具预设”列表中的所有点击 ---
document.getElementById('user-persona-presets-list').addEventListener('click', (event) => {
    // 检查被点击的元素是不是“编辑按钮”
    const editButton = event.target.closest('.edit-preset-btn');
    if (editButton) {
        // 如果是，就调用编辑函数
        editUserPersonaPreset(event);
        return; // 结束处理
    }

    // 检查被点击的元素是不是“删除按钮”
    const deleteButton = event.target.closest('.delete-preset-btn');
    if (deleteButton) {
        // 如果是，就调用我们之前修改好的删除函数
        deleteUserPersonaPreset(event);
    }
});

// ▲▲▲ 新代码粘贴到这里结束 ▲▲▲
// ==========================================================
// =========== ▼▼▼ 地图功能 - 事件绑定（缺失部分） ▼▼▼ ========
// ==========================================================
// 地图管理页的按钮
document.getElementById('back-from-map-management').addEventListener('click', showDiscoverScreen);
document.getElementById('create-new-map-btn').addEventListener('click', () => openMapDetailsModal());

// 地图详情弹窗的按钮 (创建/编辑地图本身)
document.getElementById('close-map-details-modal').addEventListener('click', () => {
    document.getElementById('map-details-modal').style.display = 'none';
});
document.getElementById('save-map-details-btn').addEventListener('click', async () => {
    const mapName = document.getElementById('map-name-input').value.trim();
    if (!mapName) {
        alert('请输入地图名称！');
        return;
    }
    const mapDescription = document.getElementById('map-description-input').value.trim();
    
    if (editingMapId) {
        // 编辑现有地图
        const map = await kokoMemory.get('maps', editingMapId);
        if (map) {
            map.name = mapName;
            map.description = mapDescription;
            await kokoMemory.put('maps', map);
        }
    } else {
        // 创建新地图
        const newMap = {
            id: 'map_' + Date.now(),
            name: mapName,
            description: mapDescription,
            locations: []
        };
        await kokoMemory.put('maps', newMap);
    }
    document.getElementById('map-details-modal').style.display = 'none';
    await renderMapList(); // 刷新列表
});

// 地图编辑器页面的按钮
document.getElementById('back-from-map-screen').addEventListener('click', showMapManagementScreen);
document.getElementById('add-map-location-btn').addEventListener('click', () => {
    // 默认在地图中心添加一个点
    openLocationModal({ isEditing: false, x: 500, y: 500 });
});

// 地图网格区域的点击事件 (添加/编辑地点)
document.getElementById('map-grid-container').addEventListener('click', (e) => {
    const icon = e.target.closest('.map-icon');
    if (icon) {
        // 如果点击的是一个已存在的图标，则进入编辑模式
        const locationId = icon.dataset.locationId;
        const location = currentMapData.locations.find(loc => loc.id === locationId);
        if (location) {
            openLocationModal({ isEditing: true, location: location });
        }
    } else {
        // 如果点击的是地图空白处，则进入添加模式
        const rect = e.currentTarget.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        openLocationModal({ isEditing: false, x: x, y: y });
    }
});

// 地点信息弹窗的按钮
document.getElementById('close-map-location-modal').addEventListener('click', () => {
    document.getElementById('map-location-modal').style.display = 'none';
});
document.getElementById('delete-map-location-btn').addEventListener('click', async () => {
    if (editingLocationId) {
        currentMapData.locations = currentMapData.locations.filter(loc => loc.id !== editingLocationId);
        await kokoMemory.put('maps', currentMapData);
        renderMapIcons();
        document.getElementById('map-location-modal').style.display = 'none';
    }
});
document.getElementById('save-map-location-btn').addEventListener('click', async () => {
    const name = document.getElementById('location-name-input').value.trim();
    if (!name) {
        alert('请输入地点名称！');
        return;
    }
    const tier = parseInt(document.getElementById('location-tier-input').value, 10); // 获取地点的级别
    const locationData = {
        name: name,
        icon: document.getElementById('location-icon-input').value.trim(),
        description: document.getElementById('location-description-input').value.trim(),
        x: parseInt(document.getElementById('location-x-input').value),
        y: parseInt(document.getElementById('location-y-input').value),
        tier: tier //  ◀◀◀ 把新获取的 tier 加到要保存的数据里
    };

    if (editingLocationId) {
        // 编辑
        const index = currentMapData.locations.findIndex(loc => loc.id === editingLocationId);
        if (index > -1) {
            currentMapData.locations[index] = { ...currentMapData.locations[index], ...locationData };
        }
    } else {
        // 新增
        if (!currentMapData.locations) {
            currentMapData.locations = [];
        }
        currentMapData.locations.push({
            id: 'loc_' + Date.now(),
            ...locationData
        });
    }
    await kokoMemory.put('maps', currentMapData);
    renderMapIcons();
    document.getElementById('map-location-modal').style.display = 'none';
});

// 地图管理列表的事件委托 (处理编辑和删除)
document.getElementById('map-list').addEventListener('click', async (e) => {
    const mapItem = e.target.closest('.preset-item');
    if (!mapItem) return;

    const mapId = mapItem.dataset.mapId;
    const map = await kokoMemory.get('maps', mapId);

    if (e.target.closest('.edit-map-btn')) {
        // 点击了编辑按钮
        openMapDetailsModal(map);
    } else if (e.target.closest('.delete-map-btn')) {
        // 点击了删除按钮
        const confirmed = await showCustomConfirm('删除地图', `确定要永久删除地图“${map.name}”及其所有地点吗？`, true);
        if (confirmed) {
            await kokoMemory.delete('maps', mapId);
            await renderMapList();
        }
    }
});
// ==========================================================
// ▼▼▼ 把这段新代码粘贴到 attachEventListeners 函数的内部 ▼▼▼

const chatContactNameEl = document.getElementById('chat-contact-name');
const heartVoicePanel = document.getElementById('heart-voice-panel');

chatContactNameEl.addEventListener('click', (e) => {
    e.stopPropagation(); // 阻止事件冒泡

    // 如果面板已经是显示的，就隐藏它
    if (heartVoicePanel.style.display === 'block') {
        heartVoicePanel.style.display = 'none';
        return;
    }
    
    const contact = state.contacts.find(c => c.id === state.activeChatId);
    if (!contact || !contact.history) return;

    // 从后往前查找最新的一条心声消息
    const lastHeartVoice = contact.history.slice().reverse().find(m => m.type === 'heart_voice');

    if (lastHeartVoice) {
        const data = lastHeartVoice.content;
        document.getElementById('hv-emotion').textContent = data.emotion || '...';
        document.getElementById('hv-thoughts').textContent = data.thoughts || '...';
        document.getElementById('hv-heart-rate').textContent = data.heartRate || '...';
        document.getElementById('hv-jealousy').textContent = data.jealousy || '无';
        
        // 显示面板
        heartVoicePanel.style.display = 'block';
    } else {
        // 如果没有找到心声记录，可以给个提示
        alert('还没有任何心声记录哦。');
    }
});

// 点击心声面板本身不会关闭它
heartVoicePanel.addEventListener('click', e => e.stopPropagation());

// 点击页面其他地方，关闭心声面板
document.addEventListener('click', (e) => {
    if (heartVoicePanel.style.display === 'block') {
        heartVoicePanel.style.display = 'none';
    }
});
// ▲▲▲ 粘贴到这里结束 ▲▲▲
// =========== ▲▲▲ 地图功能 - 事件绑定（缺失部分） END ▲▲▲ ========
// ==========================================================
// ... 在 attachEventListeners 函数中 ...

// 随便找个地方加上这行代码
document.getElementById('map-management-btn').addEventListener('click', showMapManagementScreen);
    // =========================================================
// ==========================================================
// V-Final 新增: 锁屏音乐播放器控制逻辑
// ==========================================================
const lockScreenMusicControls = document.querySelector('#lock-screen-music-widget .music-controls');
if (lockScreenMusicControls) {
    lockScreenMusicControls.addEventListener('click', (e) => {
        // 阻止事件冒泡，防止点击按钮时解锁屏幕
        e.stopPropagation();

        if (e.target.classList.contains('fa-play')) {
            if (globalAudioPlayer.src) {
                globalAudioPlayer.play();
            }
        } else if (e.target.classList.contains('fa-pause')) {
            globalAudioPlayer.pause();
        } else if (e.target.classList.contains('fa-forward-step')) {
            // 调用我们已有的下一首函数
            switchSong(currentSongIndex + 1, true, true);
        } else if (e.target.classList.contains('fa-backward-step')) {
            // 调用我们已有的上一首函数
            switchSong(currentSongIndex - 1, true, true);
        }
    });
}
// ==========================================================
// 最终修复版 V2：宠物互动逻辑 (拖动 + 点击)，兼容所有浏览器
// ==========================================================
const petContainer = document.getElementById('chat-pet-container');

if (petContainer) {
    // --- 拖动与点击判断逻辑 ---
    let isPetDragging = false;
    let petOffsetX = 0, petOffsetY = 0;
    
    // ▼▼▼ 新增变量，用于判断是否为点击 ▼▼▼
    let dragStartX = 0, dragStartY = 0;
    let hasMoved = false; 
    const dragThreshold = 5; // 移动超过5像素才算拖动

    function petDragStart(e) {
        isPetDragging = true;
        hasMoved = false; // 每次开始时，重置为“未移动”
        petContainer.style.transition = 'none';
        
        const clientX = e.type === 'touchstart' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchstart' ? e.touches[0].clientY : e.clientY;
        
        // 记录拖动起始点
        dragStartX = clientX;
        dragStartY = clientY;

        petOffsetX = clientX - petContainer.offsetLeft;
        petOffsetY = clientY - petContainer.offsetTop;

        // 注意：在触摸设备上，preventDefault 仍然是必要的，以防止页面滚动
        if (e.type === 'touchmove') {
            e.preventDefault();
        }
    }

    function petDragMove(e) {
        if (!isPetDragging) return;
        
        const clientX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const clientY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
        
        // ▼▼▼ 核心判断：检查移动距离 ▼▼▼
        const deltaX = Math.abs(clientX - dragStartX);
        const deltaY = Math.abs(clientY - dragStartY);
        if (deltaX > dragThreshold || deltaY > dragThreshold) {
            hasMoved = true; // 只要移动超过阈值，就标记为已移动
        }
        
        // 只有在确定是拖动时才移动位置
        if (hasMoved) {
            let newX = clientX - petOffsetX;
            let newY = clientY - petOffsetY;
            const screenWidth = window.innerWidth;
            const screenHeight = window.innerHeight;
            const petWidth = petContainer.offsetWidth;
            const petHeight = petContainer.offsetHeight;
            newX = Math.max(0, Math.min(newX, screenWidth - petWidth));
            newY = Math.max(0, Math.min(newY, screenHeight - petHeight));
            petContainer.style.left = `${newX}px`;
            petContainer.style.top = `${newY}px`;
            petContainer.style.bottom = 'auto';
        }

        if (e.type === 'touchmove') {
            e.preventDefault();
        }
    }

    function petDragEnd(e) {
        if (!isPetDragging) return;
        isPetDragging = false;
        
        // ▼▼▼ 核心逻辑：在拖动结束时判断 ▼▼▼
        if (!hasMoved) {
            // 如果从按下到松开，基本没移动过，就执行点击函数！
            petClickInteraction(e);
        }
    }

    function petClickInteraction(e) {
        const sound = document.getElementById('slime-sound');
        if (sound) {
            sound.currentTime = 0;
            sound.play();
        }

        const slimeEl = petContainer.querySelector('.slime');
        if (!slimeEl) return;

        slimeEl.classList.add('happy-jiggle');
        setTimeout(() => {
            slimeEl.classList.remove('happy-jiggle');
        }, 500);

        const allExpressions = ['expression-happy', 'expression-sad', 'expression-annoyed', 'expression-shocked', 'expression-pleased', 'expression-dizzy', 'expression-doubtful', 'expression-cat-face'];
        let currentExpression = '';
        
        for(const exp of allExpressions) {
            if (slimeEl.classList.contains(exp)) {
                currentExpression = exp;
                break;
            }
        }
        
        const nextPossibleExpressions = allExpressions.filter(exp => exp !== currentExpression);
        const randomExpression = nextPossibleExpressions[Math.floor(Math.random() * nextPossibleExpressions.length)];

        setTimeout(() => {
            allExpressions.forEach(exp => slimeEl.classList.remove(exp));
            if (randomExpression) {
                slimeEl.classList.add(randomExpression);
            }
        }, 100);
    }

    // --- 统一绑定所有事件 ---
    petContainer.addEventListener('mousedown', petDragStart);
    petContainer.addEventListener('touchstart', petDragStart, { passive: false });

    // ▲▲▲ 最重要的改动：删除了下面这行有问题的代码 ▲▲▲
    // petContainer.addEventListener('click', petClickInteraction); 

    document.addEventListener('mousemove', petDragMove);
    document.addEventListener('mouseup', petDragEnd);
    document.addEventListener('touchmove', petDragMove, { passive: false });
    document.addEventListener('touchend', petDragEnd);
}
// ▼▼▼ 把这段全新的代码粘贴到 attachEventListeners 函数里 ▼▼▼

// 第1个：替换掉你原来对 .contacts-container 的监听
document.querySelector('.contacts-container').addEventListener('click', function(e) {
    const optionsBtn = e.target.closest('.contact-options-btn');
    if (optionsBtn) {
        e.stopPropagation();
        const contactId = optionsBtn.dataset.contactId;
        showContactItemMenu(contactId, optionsBtn);
        return;
    }
    const contactItem = e.target.closest('.contact-item');
    if (contactItem) {
        openChat(contactItem.dataset.contactId);
    }
});

// 第2个：这是全新的，监听菜单项的点击
document.getElementById('contact-item-menu').addEventListener('click', async (e) => {
    const menuItem = e.target.closest('.menu-item');
    if (!menuItem) return;
    const contactId = document.getElementById('contact-item-menu').dataset.contactId;
    if (!contactId) return;

    switch (menuItem.id) {
        case 'menu-item-pin':
            await togglePinContact(contactId);
            break;
       case 'menu-item-group':
            // ▼▼▼ 核心修改 ▼▼▼
            showGroupSelectorModal(contactId); // 去掉 alert，调用真正的函数
            // ▲▲▲ 修改结束 ▲▲▲
            break;
        case 'menu-item-rewind':
            await handleLongPressDelete(contactId); 
            break;
    }
    document.getElementById('contact-item-menu').style.display = 'none';
});
// --- 新增：为联系人列表的“更多操作”菜单添加点击外部关闭的功能 ---
const contactItemMenu = document.getElementById('contact-item-menu');

// 1. 点击菜单内部时，阻止事件冒泡，防止菜单自己关闭自己
contactItemMenu.addEventListener('click', function(event) {
    event.stopPropagation();
});

// 2. 在整个页面上添加点击事件监听
document.addEventListener('click', function(event) {
    // 检查被点击的元素是不是打开菜单的那个“三个点”按钮
    const isOptionsButton = event.target.closest('.contact-options-btn');
    
    // 如果点击的既不是按钮，也不是菜单本身，就隐藏菜单
    if (!isOptionsButton && contactItemMenu.style.display === 'block') {
        contactItemMenu.style.display = 'none';
    }
});
// --- 新增：控制顶栏“更多操作”菜单的显示与隐藏 ---
const moreOptionsBtn = document.getElementById('more-chat-options-btn');
const chatOptionsMenu = document.getElementById('chat-options-menu');

if (moreOptionsBtn) {
    moreOptionsBtn.addEventListener('click', function(event) {
        event.stopPropagation();
        const isShown = chatOptionsMenu.style.display === 'block';
        chatOptionsMenu.style.display = isShown ? 'none' : 'block';
    });

    chatOptionsMenu.addEventListener('click', function(event) {
        event.stopPropagation();
    });

    // --- 重新绑定事件到新菜单项 ---
    document.getElementById('rewind-btn-menu').addEventListener('click', handleRewind);
    document.getElementById('summarize-chat-btn-menu').addEventListener('click', handleChatSummarization);
    document.getElementById('contact-settings-btn-menu').addEventListener('click', showCharProfileScreen);
    
    document.getElementById('toggle-chat-pet-btn-menu').addEventListener('click', () => {
        // 这是原先 toggle-chat-pet-btn 的逻辑
        const contact = state.contacts.find(c => c.id === state.activeChatId);
        if (!contact || !contact.pet) return;
        contact.isChatPetVisible = !contact.isChatPetVisible;
        const chatPetContainer = document.getElementById('chat-pet-container');
        if (contact.isChatPetVisible) {
            chatPetContainer.style.display = 'block';
            updateChatPetVisuals(contact);
        } else {
            chatPetContainer.style.display = 'none';
        }
        kokoMemory.put('contacts', contact);
        chatOptionsMenu.style.display = 'none'; // 点击后关闭菜单
    });

    document.getElementById('delete-history-btn-menu').addEventListener('click', () => {
        // 这是原先 delete-history-btn 的逻辑
        if (editModeState.active) {
            exitEditMode();
        } else {
            enterEditMode();
        }
        chatOptionsMenu.style.display = 'none'; // 点击后关闭菜单
    });
}
// 点击页面其他任何地方，都隐藏菜单
document.addEventListener('click', function(event) {
    // 确保点击的不是按钮本身
    if (moreOptionsBtn && !moreOptionsBtn.contains(event.target)) {
        chatOptionsMenu.style.display = 'none';
    }
});
// --- ▼▼▼ 新增：视频通话界面的事件绑定 ▼▼▼ ---
document.getElementById('hang-up-btn').addEventListener('click', () => {
    endVideoCall('user');
});

document.getElementById('video-call-send-btn').addEventListener('click', sendVideoCallMessage);

document.getElementById('video-call-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendVideoCallMessage();
    }
});
// ... 在 attachEventListeners() 函数内部 ...
// 【新增】处理预设下拉菜单的选择事件
    document.getElementById('api-preset-select').addEventListener('change', (e) => {
        const presetId = e.target.value;
        const preset = state.apiPresets.find(p => p.id === presetId);
        if (preset) {
            document.getElementById('api-key-input').value = preset.apiKey || '';
            document.getElementById('api-endpoint-input').value = preset.endpoint || '';
            updateModelDropdown([preset.model], document.getElementById('model-select'), preset.model);
            
            const fetchBtn = document.getElementById('fetch-models-btn');
            if (fetchBtn) fetchBtn.click();
        }
    });

    // 【新增】处理“另存为预设”按钮点击事件
    document.getElementById('save-as-api-preset-btn').addEventListener('click', async () => {
        const apiKey = document.getElementById('api-key-input').value;
        const endpoint = document.getElementById('api-endpoint-input').value.trim();
        const model = document.getElementById('model-select').value;

        if (!apiKey || !endpoint || !model) {
            return alert('请先将API密钥、地址和模型填写完整再保存为预设。');
        }

        const presetName = await showCustomPrompt('为这个预设取个名字', '');
        if (presetName && presetName.trim()) {
            const newPreset = {
                id: 'api_preset_' + Date.now(),
                name: presetName.trim(),
                apiKey,
                endpoint,
                model
            };

            state.apiPresets.push(newPreset);
            await kokoMemory.put('apiPresets', newPreset);
            await renderApiPresetDropdown(); // 更新下拉菜单
            alert(`预设“${newPreset.name}”已保存！`);
        }
    });

    // 【新增】处理“管理预设”按钮和其页面的返回按钮
    document.getElementById('manage-api-presets-btn').addEventListener('click', showApiPresetManagementScreen);
    document.getElementById('back-from-api-presets').addEventListener('click', () => {
        // 返回时，重新打开API设置页面并刷新下拉菜单
        document.getElementById('api-settings-btn').click();
    });
// --- 外观设置页面的事件绑定 (自由定制版) ---
document.getElementById('appearance-settings-btn').addEventListener('click', () => {
    // 打开设置页面前，先用已保存的设置填充输入框
    document.getElementById('bubble-css-input').value = userSettings.customBubbleCss || '';
    document.getElementById('theme-css-input').value = userSettings.customThemeCss || '';
document.getElementById('narrative-css-input').value = userSettings.customNarrativeCss || '';
// 新增下面这行：如果存在已保存的值，则显示，否则为空
document.getElementById('font-size-input').value = userSettings.customFontSize || ''; // <-- 新增这一行
    document.getElementById('font-url-input').value = userSettings.customFontUrl || '';
    document.getElementById('font-name-input').value = userSettings.customFontName || '';
    
    hideAllScreens();
    document.getElementById('appearance-settings-screen').style.display = 'flex';
});

document.getElementById('back-from-appearance-settings').addEventListener('click', showProfileScreen);

// 背景上传按钮
document.getElementById('upload-background-btn').addEventListener('click', () => {
    document.getElementById('background-file-input').click();
});

// 背景文件选择后的处理
document.getElementById('background-file-input').addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (file.size > 5 * 1024 * 1024) { // 限制5MB大小
        alert('图片文件不能超过 5MB');
        return;
    }

    const reader = new FileReader();
    reader.onload = (event) => {
        const base64String = event.target.result;
        userSettings.chatBackground = base64String; // 实时保存到变量
        document.getElementById('chat-screen').style.backgroundImage = `url(${base64String})`;
        alert('背景已更新，点击“应用并保存”来永久保存。');
    };
    reader.readAsDataURL(file);
    e.target.value = ''; // 清空input，以便可以再次选择同一个文件
});

// 恢复默认背景按钮
document.getElementById('reset-background-btn').addEventListener('click', () => {
    userSettings.chatBackground = null;
    applyAppearanceSettings(); // 立即应用默认样式
    alert('背景已恢复默认，点击“应用并保存”来永久保存。');
});
attachGroupSettingsListeners();
// 保存外观设置按钮
document.getElementById('save-appearance-btn').addEventListener('click', saveAppearanceSettings);
}
attachEventListeners();
await initApp();
}); 
</script>
</body>
</html>
